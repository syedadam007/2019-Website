<!DOCTYPE html>
<html>
    <head>
        <link href="./img/favicon.png" rel="shortcut icon"/>
        <meta charset="utf-8"/>
        <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0" name="viewport"/>
        <title>
            Adam's Website
        </title>
        <!-- Facebook -->
        <meta content="Adam's Website" property="og:site_name"/>
        <meta content="Adam's Website" property="og:title"/>
        <meta content="" property="og:url"/>
        <meta content="website" property="og:type"/>
        <link href="./css/ipadHomeMenuHover.css" rel="stylesheet" type="text/css"/>
        <link href="./css/iphoneXHomeMenuHover.css" rel="stylesheet" type="text/css"/>
        <link href="./css/home.css" rel="stylesheet" type="text/css"/>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.0/jquery.min.js">
        </script>
        <script src="https://animaapp.s3.amazonaws.com/launchpad-static/launchpad.js">
        </script>
        <meta content="AnimaApp.com - Design to code, Automated." name="author"/>
    </head>
    <body style="margin: 0;
 background: rgba(16, 16, 16, 1.0);">
        <input id="anPageName" name="page" type="hidden" value="home"/>
        <div class="bp2-web1366home anima-word-break ">
            <div style="width: 1366px; height: 100%; position:relative; margin:auto;">
                <div class="bp2-sectionhero" id="section-hero">
                    <div class="bp2-darkbg">
                    </div>
                    <div class="bp2-content">
                        <div anima-show-on-scroll="" class="bp2-mission">
                            Adam designs because the world ainâ€™t right. <br />Demystifying the ways the world should be.
                        </div>
                        <div class="bp2-present">
                            Present
                        </div>
                        <style>
                            .bp2-web1366home .bp2-sectionhero .bp2-content .bp2-designco-DoUR * {
                                box-sizing          : border-box;
                            }
                            .bp2-web1366home .bp2-sectionhero .bp2-content .bp2-designco-DoUR {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 235px;
                                height              : 23px;
                                width               : 112px;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionhero .bp2-content .bp2-designco-DoUR .bp2-designco1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 11px);
                                height              : 22px;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 22.4px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.43px;
                                line-height         : 27.0px;
                            }
                            .bp2-web1366home .bp2-sectionhero .bp2-content .bp2-designco-DoUR .bp2-designcohover {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 11px);
                                height              : 22px;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 22.4px;
                                color               : rgba(146, 146, 146, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.43px;
                                line-height         : 27.0px;
                            }
                        </style>
                        <div id="Ib4oy71">
                            <div class="bp2-designco bp2-designco-DoUR component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                <a href="http://www.ucsddesign.co/" target="_blank">
                                    <div class="bp2-designco1">
                                        Design Co
                                    </div>
                                </a>
                                <a href="http://www.ucsddesign.co/" target="_blank">
                                    <div class="bp2-designcohover anima-hidden ">
                                        Design Co
                                    </div>
                                </a>
                            </div>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp2-web1366home .bp2-sectionhero .bp2-content .bp2-designco-DoUR", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp2-designcohover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp2-designcohover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp2-designcohover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                        <div class="bp2-education">
                            Education
                        </div>
                        <style>
                            .bp2-web1366home .bp2-sectionhero .bp2-content .bp2-ucsd-rrTe * {
                                box-sizing          : border-box;
                            }
                            .bp2-web1366home .bp2-sectionhero .bp2-content .bp2-ucsd-rrTe {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 349px;
                                height              : 23px;
                                width               : 153px;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionhero .bp2-content .bp2-ucsd-rrTe .bp2-ucsd1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 11px);
                                height              : 22px;
                                width               : 99.35%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.33%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 22.4px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.43px;
                                line-height         : 27.0px;
                            }
                            .bp2-web1366home .bp2-sectionhero .bp2-content .bp2-ucsd-rrTe .bp2-ucsdhover {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 11px);
                                height              : 22px;
                                width               : 99.35%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.33%;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 22.4px;
                                color               : rgba(146, 146, 146, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.43px;
                                line-height         : 27.0px;
                            }
                        </style>
                        <div id="SlPPvIN">
                            <div class="bp2-ucsd bp2-ucsd-rrTe component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                <a href="https://ucsd.edu/" target="_blank">
                                    <div class="bp2-ucsd1">
                                        UC San Diego
                                    </div>
                                </a>
                                <a href="https://ucsd.edu/" target="_blank">
                                    <div class="bp2-ucsdhover anima-hidden ">
                                        UC San Diego
                                    </div>
                                </a>
                            </div>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp2-web1366home .bp2-sectionhero .bp2-content .bp2-ucsd-rrTe", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp2-ucsdhover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp2-ucsdhover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp2-ucsdhover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                        <div class="bp2-previous">
                            Previous
                        </div>
                        <style>
                            .bp2-web1366home .bp2-sectionhero .bp2-content .bp2-longstorystudios-xCPs * {
                                box-sizing          : border-box;
                            }
                            .bp2-web1366home .bp2-sectionhero .bp2-content .bp2-longstorystudios-xCPs {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 235px;
                                height              : 23px;
                                width               : 204px;
                                position            : absolute;
                                margin              : 0;
                                left                : 397px;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionhero .bp2-content .bp2-longstorystudios-xCPs .bp2-ls {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 11px);
                                height              : 22px;
                                width               : 99.51%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.25%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 22.4px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.43px;
                                line-height         : 27.0px;
                            }
                            .bp2-web1366home .bp2-sectionhero .bp2-content .bp2-longstorystudios-xCPs .bp2-lshover {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 11px);
                                height              : 22px;
                                width               : 99.51%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.25%;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 22.4px;
                                color               : rgba(146, 146, 146, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.43px;
                                line-height         : 27.0px;
                            }
                        </style>
                        <div id="QJBhv34">
                            <div class="bp2-longstorystudios bp2-longstorystudios-xCPs component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                <a href="https://www.longstorystudios.com/" target="_blank">
                                    <div class="bp2-ls">
                                        Long Story Studios
                                    </div>
                                </a>
                                <a href="https://www.longstorystudios.com/" target="_blank">
                                    <div class="bp2-lshover anima-hidden ">
                                        Long Story Studios
                                    </div>
                                </a>
                            </div>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp2-web1366home .bp2-sectionhero .bp2-content .bp2-longstorystudios-xCPs", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp2-lshover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp2-lshover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp2-lshover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                    </div>
                    <style>
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 * {
                            box-sizing          : border-box;
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 203px;
                            height              : 391px;
                            width               : 45px;
                            position            : absolute;
                            margin              : 0;
                            left                : 1321px;
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberoff {
                            background-color    : rgba(255,255,255,0.0);
                            bottom              : 0px;
                            height              : 75.70%;
                            width               : 100%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0px;
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberoff .bp2-lightsaberoff1 {
                            background-color    : rgba(255,255,255,0.0);
                            bottom              : 0px;
                            height              : 37.50%;
                            width               : 75.56%;
                            position            : absolute;
                            margin              : 0;
                            left                : 6.67%;
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberoff .bp2-lightsaberoff1 .bp2-rectangle {
                            background-color    : rgba(84, 82, 82, 1.0);
                            right               : 8.82%;
                            top                 : 39.64%;
                            height              : 20.72%;
                            width               : 76.47%;
                            position            : absolute;
                            margin              : 0;
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberoff .bp2-lightsaberoff1 .bp2-rectangle1 {
                            background-color    : rgba(196, 196, 196, 1.0);
                            top                 : 41.44%;
                            height              : 1.80%;
                            width               : 8.82%;
                            position            : absolute;
                            margin              : 0;
                            left                : 5.88%;
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberoff .bp2-lightsaberoff1 .bp2-rectangle2 {
                            background-color    : rgba(196, 196, 196, 1.0);
                            bottom              : 42.34%;
                            height              : 1.80%;
                            width               : 8.82%;
                            position            : absolute;
                            margin              : 0;
                            left                : 5.88%;
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberoff .bp2-lightsaberoff1 .bp2-rectangle3 {
                            background-color    : rgba(196, 196, 196, 1.0);
                            top                 : 45.95%;
                            height              : 4.50%;
                            width               : 8.82%;
                            position            : absolute;
                            margin              : 0;
                            left                : 5.88%;
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberoff .bp2-lightsaberoff1 .bp2-rectangle4 {
                            background-color    : rgba(196, 196, 196, 1.0);
                            bottom              : 45.95%;
                            height              : 4.50%;
                            width               : 8.82%;
                            position            : absolute;
                            margin              : 0;
                            left                : 5.88%;
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberoff .bp2-lightsaberoff1 .bp2-shape {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 38.74%;
                            height              : 22.52%;
                            width               : 94.12%;
                            position            : absolute;
                            margin              : 0;
                            left                : 2.94%;
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberoff .bp2-lightsaberoff1 .bp2-rectangle5 {
                            background-color    : rgba(255,255,255,0.0);
                            right               : 11.76%;
                            bottom              : 4.50%;
                            height              : 36.04%;
                            box-sizing          : border-box;
                            width               : 64.71%;
                            position            : absolute;
                            margin              : 0;
                            border-style        : solid;
                            border-width        : 2px;
                            border-color        : rgba(0, 0, 0, 1.0);
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberoff .bp2-lightsaberoff1 .bp2-rectangle6 {
                            background-color    : rgba(196, 196, 196, 1.0);
                            right               : 11.76%;
                            top                 : 20.72%;
                            height              : 19.82%;
                            box-sizing          : border-box;
                            width               : 64.71%;
                            position            : absolute;
                            margin              : 0;
                            border-style        : solid;
                            border-width        : 2px;
                            border-color        : rgba(0, 0, 0, 1.0);
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberoff .bp2-lightsaberoff1 .bp2-rectangle7 {
                            background-color    : rgba(141, 141, 141, 1.0);
                            right               : 11.76%;
                            bottom              : 4.50%;
                            height              : 36.04%;
                            box-sizing          : border-box;
                            width               : 64.71%;
                            position            : absolute;
                            margin              : 0;
                            border-style        : solid;
                            border-width        : 2px;
                            border-color        : rgba(0, 0, 0, 1.0);
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberoff .bp2-lightsaberoff1 .bp2-rectangle8 {
                            background-color    : rgba(84, 82, 82, 1.0);
                            right               : 14.71%;
                            top                 : 0px;
                            height              : 13.51%;
                            box-sizing          : border-box;
                            width               : 55.88%;
                            position            : absolute;
                            margin              : 0;
                            border-style        : solid;
                            border-width        : 2px;
                            border-color        : rgba(0, 0, 0, 1.0);
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberoff .bp2-lightsaberoff1 .bp2-rectangle9 {
                            background-color    : rgba(84, 82, 82, 1.0);
                            right               : 0px;
                            top                 : 10.81%;
                            height              : 10.81%;
                            box-sizing          : border-box;
                            width               : 85.29%;
                            position            : absolute;
                            margin              : 0;
                            border-style        : solid;
                            border-width        : 2px;
                            border-color        : rgba(0, 0, 0, 1.0);
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberoff .bp2-lightsaberoff1 .bp2-path {
                            background-color    : rgba(255,255,255,0.0);
                            right               : 14.71%;
                            top                 : 12.61%;
                            height              : 7.21%;
                            width               : 8.82%;
                            position            : absolute;
                            margin              : 0;
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberoff .bp2-lightsaberoff1 .bp2-path1 {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 12.61%;
                            height              : 7.21%;
                            width               : 11.76%;
                            position            : absolute;
                            margin              : 0;
                            left                : 26.47%;
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberoff .bp2-lightsaberoff1 .bp2-rectangle10 {
                            background-color    : rgba(0, 0, 0, 1.0);
                            right               : 41.18%;
                            bottom              : 7.21%;
                            height              : 30.63%;
                            width               : 5.88%;
                            position            : absolute;
                            margin              : 0;
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberoff .bp2-lightsaberoff1 .bp2-rectangle11 {
                            background-color    : rgba(0, 0, 0, 1.0);
                            bottom              : 7.21%;
                            height              : 30.63%;
                            width               : 5.88%;
                            position            : absolute;
                            margin              : 0;
                            left                : 38.24%;
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberoff .bp2-lightsaberoff1 .bp2-rectangle12 {
                            background-color    : rgba(0, 0, 0, 1.0);
                            right               : 26.47%;
                            bottom              : 7.21%;
                            height              : 30.63%;
                            width               : 5.88%;
                            position            : absolute;
                            margin              : 0;
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberoff .bp2-lightsaberoff1 .bp2-rectangle13 {
                            background-color    : rgba(84, 82, 82, 1.0);
                            right               : 17.65%;
                            bottom              : 0px;
                            height              : 7.21%;
                            box-sizing          : border-box;
                            width               : 50.00%;
                            position            : absolute;
                            margin              : 0;
                            border-style        : solid;
                            border-width        : 2px;
                            border-color        : rgba(0, 0, 0, 1.0);
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberoff .bp2-achievements {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 0px;
                            height              : 54.39%;
                            width               : 100%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0px;
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberoff .bp2-achievements .bp2-rectangle14 {
                            background-color    : rgba(255, 255, 255, 1.0);
                            top                 : 0px;
                            height              : 100%;
                            box-sizing          : border-box;
                            width               : 100%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0px;
                            border-style        : solid;
                            border-width        : 0px;
                            border-color        : rgba(150, 150, 150, 1.0);
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberoff .bp2-achievements .bp2-achievements1 {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : calc(50.00% - 11px);
                            height              : 22px;
                            width               : 275.56%;
                            position            : absolute;
                            margin              : 0;
                            left                : -87.78%;
                            transform           : rotate(-90deg);
                            font-family         : "Gilroy-Bold", Helvetica, Arial, serif;
                            font-size           : 22.4px;
                            color               : rgba(0, 0, 0, 1.0);
                            text-align          : left;
                            letter-spacing      : 0.43px;
                            line-height         : 27.0px;
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberon {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 0px;
                            height              : 100.26%;
                            width               : 100%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0px;
                            transform           : rotate(0deg);
                            opacity             : 0.0;
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberon .bp2-lightsaberon1 {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 0px;
                            height              : 100%;
                            width               : 75.56%;
                            position            : absolute;
                            margin              : 0;
                            left                : 6.67%;
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberon .bp2-lightsaberon1 .bp2-group {
                            background-color    : rgba(255,255,255,0.0);
                            right               : 23.53%;
                            top                 : 0px;
                            height              : 72.96%;
                            width               : 38.24%;
                            position            : absolute;
                            margin              : 0;
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberon .bp2-lightsaberon1 .bp2-group .bp2-path2 {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 0.52%;
                            height              : 98.95%;
                            width               : 76.92%;
                            position            : absolute;
                            margin              : 0;
                            left                : 11.54%;
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberon .bp2-lightsaberon1 .bp2-group .bp2-path3 {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 0px;
                            height              : 100%;
                            width               : 100%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0px;
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberon .bp2-lightsaberon1 .bp2-rectangle15 {
                            background-color    : rgba(84, 82, 82, 1.0);
                            right               : 8.82%;
                            bottom              : 11.22%;
                            height              : 5.87%;
                            width               : 76.47%;
                            position            : absolute;
                            margin              : 0;
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberon .bp2-lightsaberon1 .bp2-rectangle16 {
                            background-color    : rgba(196, 196, 196, 1.0);
                            bottom              : 16.07%;
                            height              : 0.51%;
                            width               : 8.82%;
                            position            : absolute;
                            margin              : 0;
                            left                : 5.88%;
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberon .bp2-lightsaberon1 .bp2-rectangle17 {
                            background-color    : rgba(196, 196, 196, 1.0);
                            bottom              : 11.99%;
                            height              : 0.51%;
                            width               : 8.82%;
                            position            : absolute;
                            margin              : 0;
                            left                : 5.88%;
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberon .bp2-lightsaberon1 .bp2-rectangle18 {
                            background-color    : rgba(196, 196, 196, 1.0);
                            bottom              : 14.03%;
                            height              : 1.28%;
                            width               : 8.82%;
                            position            : absolute;
                            margin              : 0;
                            left                : 5.88%;
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberon .bp2-lightsaberon1 .bp2-rectangle19 {
                            background-color    : rgba(196, 196, 196, 1.0);
                            bottom              : 13.01%;
                            height              : 1.28%;
                            width               : 8.82%;
                            position            : absolute;
                            margin              : 0;
                            left                : 5.88%;
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberon .bp2-lightsaberon1 .bp2-shape1 {
                            background-color    : rgba(255,255,255,0.0);
                            bottom              : 10.97%;
                            height              : 6.38%;
                            width               : 94.12%;
                            position            : absolute;
                            margin              : 0;
                            left                : 2.94%;
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberon .bp2-lightsaberon1 .bp2-rectangle20 {
                            background-color    : rgba(255,255,255,0.0);
                            right               : 11.76%;
                            bottom              : 1.28%;
                            height              : 10.20%;
                            box-sizing          : border-box;
                            width               : 64.71%;
                            position            : absolute;
                            margin              : 0;
                            border-style        : solid;
                            border-width        : 2px;
                            border-color        : rgba(0, 0, 0, 1.0);
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberon .bp2-lightsaberon1 .bp2-rectangle21 {
                            background-color    : rgba(196, 196, 196, 1.0);
                            right               : 11.76%;
                            bottom              : 16.84%;
                            height              : 5.61%;
                            box-sizing          : border-box;
                            width               : 64.71%;
                            position            : absolute;
                            margin              : 0;
                            border-style        : solid;
                            border-width        : 2px;
                            border-color        : rgba(0, 0, 0, 1.0);
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberon .bp2-lightsaberon1 .bp2-rectangle22 {
                            background-color    : rgba(141, 141, 141, 1.0);
                            right               : 11.76%;
                            bottom              : 1.28%;
                            height              : 10.20%;
                            box-sizing          : border-box;
                            width               : 64.71%;
                            position            : absolute;
                            margin              : 0;
                            border-style        : solid;
                            border-width        : 2px;
                            border-color        : rgba(0, 0, 0, 1.0);
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberon .bp2-lightsaberon1 .bp2-rectangle23 {
                            background-color    : rgba(84, 82, 82, 1.0);
                            right               : 14.71%;
                            bottom              : 24.49%;
                            height              : 3.83%;
                            box-sizing          : border-box;
                            width               : 55.88%;
                            position            : absolute;
                            margin              : 0;
                            border-style        : solid;
                            border-width        : 2px;
                            border-color        : rgba(0, 0, 0, 1.0);
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberon .bp2-lightsaberon1 .bp2-rectangle24 {
                            background-color    : rgba(84, 82, 82, 1.0);
                            right               : 0px;
                            bottom              : 22.19%;
                            height              : 3.06%;
                            box-sizing          : border-box;
                            width               : 85.29%;
                            position            : absolute;
                            margin              : 0;
                            border-style        : solid;
                            border-width        : 2px;
                            border-color        : rgba(0, 0, 0, 1.0);
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberon .bp2-lightsaberon1 .bp2-path4 {
                            background-color    : rgba(255,255,255,0.0);
                            right               : 14.71%;
                            bottom              : 22.70%;
                            height              : 2.04%;
                            width               : 8.82%;
                            position            : absolute;
                            margin              : 0;
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberon .bp2-lightsaberon1 .bp2-path5 {
                            background-color    : rgba(255,255,255,0.0);
                            bottom              : 22.70%;
                            height              : 2.04%;
                            width               : 11.76%;
                            position            : absolute;
                            margin              : 0;
                            left                : 26.47%;
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberon .bp2-lightsaberon1 .bp2-rectangle25 {
                            background-color    : rgba(0, 0, 0, 1.0);
                            right               : 41.18%;
                            bottom              : 2.04%;
                            height              : 8.67%;
                            width               : 5.88%;
                            position            : absolute;
                            margin              : 0;
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberon .bp2-lightsaberon1 .bp2-rectangle26 {
                            background-color    : rgba(0, 0, 0, 1.0);
                            bottom              : 2.04%;
                            height              : 8.67%;
                            width               : 5.88%;
                            position            : absolute;
                            margin              : 0;
                            left                : 38.24%;
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberon .bp2-lightsaberon1 .bp2-rectangle27 {
                            background-color    : rgba(0, 0, 0, 1.0);
                            right               : 26.47%;
                            bottom              : 2.04%;
                            height              : 8.67%;
                            width               : 5.88%;
                            position            : absolute;
                            margin              : 0;
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberon .bp2-lightsaberon1 .bp2-rectangle28 {
                            background-color    : rgba(84, 82, 82, 1.0);
                            right               : 17.65%;
                            bottom              : 0px;
                            height              : 2.04%;
                            box-sizing          : border-box;
                            width               : 50.00%;
                            position            : absolute;
                            margin              : 0;
                            border-style        : solid;
                            border-width        : 2px;
                            border-color        : rgba(0, 0, 0, 1.0);
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberon .bp2-achievements2 {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 24.49%;
                            height              : 41.07%;
                            width               : 100%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0px;
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberon .bp2-achievements2 .bp2-rectangle29 {
                            background-color    : rgba(255, 255, 255, 1.0);
                            top                 : 0px;
                            height              : 100%;
                            box-sizing          : border-box;
                            width               : 100%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0px;
                            border-style        : solid;
                            border-width        : 0px;
                            border-color        : rgba(150, 150, 150, 1.0);
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4 .bp2-lightsaberon .bp2-achievements2 .bp2-achievements3 {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : calc(50.00% - 11px);
                            height              : 22px;
                            width               : 275.56%;
                            position            : absolute;
                            margin              : 0;
                            left                : -87.78%;
                            transform           : rotate(-90deg);
                            font-family         : "Gilroy-Bold", Helvetica, Arial, serif;
                            font-size           : 22.4px;
                            color               : rgba(0, 0, 0, 1.0);
                            text-align          : left;
                            letter-spacing      : 0.43px;
                            line-height         : 27.0px;
                        }
                    </style>
                    <div id="LEHUjoc">
                        <div class="bp2-lightsaber bp2-lightsaber-8um4 component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                            <div class="bp2-lightsaberoff">
                                <div class="bp2-lightsaberoff1">
                                    <div class="bp2-rectangle">
                                    </div>
                                    <div class="bp2-rectangle1">
                                    </div>
                                    <div class="bp2-rectangle2">
                                    </div>
                                    <div class="bp2-rectangle3">
                                    </div>
                                    <div class="bp2-rectangle4">
                                    </div>
                                    <img alt="Image" class="bp2-shape" src="./img/web-1366-home-shape@2x.png"/>
                                    <div class="bp2-rectangle5">
                                    </div>
                                    <div class="bp2-rectangle6">
                                    </div>
                                    <div class="bp2-rectangle7">
                                    </div>
                                    <div class="bp2-rectangle8">
                                    </div>
                                    <div class="bp2-rectangle9">
                                    </div>
                                    <img alt="Image" class="bp2-path" src="./img/web-1366-home-path@2x.png"/>
                                    <img alt="Image" class="bp2-path1" src="./img/web-1366-home-path-1@2x.png"/>
                                    <div class="bp2-rectangle10">
                                    </div>
                                    <div class="bp2-rectangle11">
                                    </div>
                                    <div class="bp2-rectangle12">
                                    </div>
                                    <div class="bp2-rectangle13">
                                    </div>
                                </div>
                                <a href="playground.html">
                                    <div class="bp2-achievements">
                                        <div class="bp2-rectangle14">
                                        </div>
                                        <div class="bp2-achievements1">
                                            Playground
                                        </div>
                                    </div>
                                </a>
                            </div>
                            <div class="bp2-lightsaberon anima-hidden ">
                                <div class="bp2-lightsaberon1">
                                    <div class="bp2-group">
                                        <img alt="Image" class="bp2-path2" src="./img/web-1366-home-path-2@2x.png"/>
                                        <img alt="Image" class="bp2-path3" src="./img/web-1366-home-path-3@2x.png"/>
                                    </div>
                                    <div class="bp2-rectangle15">
                                    </div>
                                    <div class="bp2-rectangle16">
                                    </div>
                                    <div class="bp2-rectangle17">
                                    </div>
                                    <div class="bp2-rectangle18">
                                    </div>
                                    <div class="bp2-rectangle19">
                                    </div>
                                    <img alt="Image" class="bp2-shape1" src="./img/web-1366-home-shape-1@2x.png"/>
                                    <div class="bp2-rectangle20">
                                    </div>
                                    <div class="bp2-rectangle21">
                                    </div>
                                    <div class="bp2-rectangle22">
                                    </div>
                                    <div class="bp2-rectangle23">
                                    </div>
                                    <div class="bp2-rectangle24">
                                    </div>
                                    <img alt="Image" class="bp2-path4" src="./img/web-1366-home-path@2x.png"/>
                                    <img alt="Image" class="bp2-path5" src="./img/web-1366-home-path-1@2x.png"/>
                                    <div class="bp2-rectangle25">
                                    </div>
                                    <div class="bp2-rectangle26">
                                    </div>
                                    <div class="bp2-rectangle27">
                                    </div>
                                    <div class="bp2-rectangle28">
                                    </div>
                                </div>
                                <a href="playground.html">
                                    <div class="bp2-achievements2">
                                        <div class="bp2-rectangle29">
                                        </div>
                                        <div class="bp2-achievements3">
                                            Playground
                                        </div>
                                    </div>
                                </a>
                            </div>
                        </div>
                    </div>
                    <script>
      (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp2-web1366home .bp2-sectionhero .bp2-lightsaber-8um4", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp2-lightsaberon": {
                "delay": 0, 
                "duration": 400, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ".bp2-lightsaberoff .bp2-achievements"
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp2-lightsaberon": {
                "delay": 0, 
                "duration": 400, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ".bp2-lightsaberon .bp2-achievements2"
          }
        ], 
        "overrides": {
          ".bp2-lightsaberon": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                    </script>
                    <div class="bp2-navbar">
                        <div class="bp2-rectangle">
                        </div>
                        <style>
                            .bp2-web1366home .bp2-sectionhero .bp2-navbar .bp2-logo-WXFX * {
                                box-sizing          : border-box;
                            }
                            .bp2-web1366home .bp2-sectionhero .bp2-navbar .bp2-logo-WXFX {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 55px;
                                height              : 32px;
                                width               : 182px;
                                position            : absolute;
                                margin              : 0;
                                left                : 92px;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionhero .bp2-navbar .bp2-logo-WXFX .bp2-adamoutline {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionhero .bp2-navbar .bp2-logo-WXFX .bp2-adamoutline .bp2-shape {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 93.75%;
                                width               : 81.87%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.55%;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionhero .bp2-navbar .bp2-logo-WXFX .bp2-adamoutline .bp2-path {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 0.55%;
                                top                 : 17.19%;
                                height              : 65.62%;
                                width               : 10.99%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionhero .bp2-navbar .bp2-logo-WXFX .bp2-adamfill {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 0px;
                                top                 : 0px;
                                height              : 93.75%;
                                width               : 98.90%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                            }
                            .bp2-web1366home .bp2-sectionhero .bp2-navbar .bp2-logo-WXFX .bp2-adamfill .bp2-shape1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 81.67%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionhero .bp2-navbar .bp2-logo-WXFX .bp2-adamfill .bp2-path1 {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 0px;
                                bottom              : 10.00%;
                                height              : 73.33%;
                                width               : 11.67%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                        </style>
                        <div id="82Q2swt">
                            <div class="bp2-logo bp2-logo-WXFX component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                <div class="bp2-adamoutline">
                                    <img alt="Image" class="bp2-shape" src="./img/web-1366-about-shape@2x.png"/>
                                    <img alt="Image" class="bp2-path" src="./img/web-1366-work-path@2x.png"/>
                                </div>
                                <div class="bp2-adamfill anima-hidden ">
                                    <img alt="Image" class="bp2-shape1" src="./img/web-1366-home-shape-3@2x.png"/>
                                    <img alt="Image" class="bp2-path1" src="./img/web-1366-about-path-1@2x.png"/>
                                </div>
                            </div>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp2-web1366home .bp2-sectionhero .bp2-navbar .bp2-logo-WXFX", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp2-adamfill": {
                "delay": 0, 
                "duration": 400, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp2-adamfill": {
                "delay": 0, 
                "duration": 500, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp2-adamfill": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                        <div class="bp2-navbar1">
                            <style>
                                .bp2-web1366home .bp2-sectionhero .bp2-navbar .bp2-navbar1 .bp2-resume-1t1y * {
                                    box-sizing          : border-box;
                                }
                                .bp2-web1366home .bp2-sectionhero .bp2-navbar .bp2-navbar1 .bp2-resume-1t1y {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 29px;
                                    width               : 93px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 405px;
                                    transform           : rotate(0deg);
                                }
                                .bp2-web1366home .bp2-sectionhero .bp2-navbar .bp2-navbar1 .bp2-resume-1t1y .bp2-resume1 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 14px);
                                    height              : 28px;
                                    width               : 98.92%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0.54%;
                                    transform           : rotate(0deg);
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 21.0px;
                                    color               : rgba(126, 126, 126, 1.0);
                                    text-align          : center;
                                    letter-spacing      : 0.58px;
                                    line-height         : 25.0px;
                                }
                                .bp2-web1366home .bp2-sectionhero .bp2-navbar .bp2-navbar1 .bp2-resume-1t1y .bp2-resumehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 14px);
                                    height              : 28px;
                                    width               : 98.92%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0.54%;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 21.0px;
                                    color               : rgba(31, 208, 118, 1.0);
                                    text-align          : center;
                                    letter-spacing      : 0.58px;
                                    line-height         : 25.0px;
                                }
                            </style>
                            <div id="3K0zyEu">
                                <a href="https://drive.google.com/file/d/1KxPEStKpGkBtJaURrrckkRjVntkcITWU/view?usp=sharing" target="_blank">
                                    <div class="bp2-resume bp2-resume-1t1y component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <div class="bp2-resume1 anima-valign-text-middle">
                                            Resume
                                        </div>
                                        <div class="bp2-resumehover anima-valign-text-middle anima-hidden ">
                                            Resume
                                        </div>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp2-web1366home .bp2-sectionhero .bp2-navbar .bp2-navbar1 .bp2-resume-1t1y", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp2-resumehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp2-resumehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp2-resumehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <style>
                                .bp2-web1366home .bp2-sectionhero .bp2-navbar .bp2-navbar1 .bp2-about-x3wA * {
                                    box-sizing          : border-box;
                                }
                                .bp2-web1366home .bp2-sectionhero .bp2-navbar .bp2-navbar1 .bp2-about-x3wA {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 29px;
                                    width               : 93px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 270px;
                                    transform           : rotate(0deg);
                                }
                                .bp2-web1366home .bp2-sectionhero .bp2-navbar .bp2-navbar1 .bp2-about-x3wA .bp2-about1 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 14px);
                                    height              : 28px;
                                    width               : 98.92%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0.54%;
                                    transform           : rotate(0deg);
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 21.0px;
                                    color               : rgba(126, 126, 126, 1.0);
                                    text-align          : center;
                                    letter-spacing      : 0.58px;
                                    line-height         : 25.0px;
                                }
                                .bp2-web1366home .bp2-sectionhero .bp2-navbar .bp2-navbar1 .bp2-about-x3wA .bp2-abouthover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 14px);
                                    height              : 28px;
                                    width               : 98.92%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0.54%;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 21.0px;
                                    color               : rgba(214, 214, 214, 1.0);
                                    text-align          : center;
                                    letter-spacing      : 0.58px;
                                    line-height         : 25.0px;
                                }
                            </style>
                            <div id="SlZ7dic">
                                <a href="about.html">
                                    <div class="bp2-about bp2-about-x3wA component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <div class="bp2-about1 anima-valign-text-middle">
                                            About
                                        </div>
                                        <div class="bp2-abouthover anima-valign-text-middle anima-hidden ">
                                            About
                                        </div>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp2-web1366home .bp2-sectionhero .bp2-navbar .bp2-navbar1 .bp2-about-x3wA", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp2-abouthover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp2-abouthover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp2-abouthover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <style>
                                .bp2-web1366home .bp2-sectionhero .bp2-navbar .bp2-navbar1 .bp2-work-i6SH * {
                                    box-sizing          : border-box;
                                }
                                .bp2-web1366home .bp2-sectionhero .bp2-navbar .bp2-navbar1 .bp2-work-i6SH {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 29px;
                                    width               : 93px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 135px;
                                    transform           : rotate(0deg);
                                }
                                .bp2-web1366home .bp2-sectionhero .bp2-navbar .bp2-navbar1 .bp2-work-i6SH .bp2-work1 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 14px);
                                    height              : 28px;
                                    width               : 98.92%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0.54%;
                                    transform           : rotate(0deg);
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 21.0px;
                                    color               : rgba(126, 126, 126, 1.0);
                                    text-align          : center;
                                    letter-spacing      : 0.58px;
                                    line-height         : 25.0px;
                                }
                                .bp2-web1366home .bp2-sectionhero .bp2-navbar .bp2-navbar1 .bp2-work-i6SH .bp2-workhover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 14px);
                                    height              : 28px;
                                    width               : 98.92%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0.54%;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 21.0px;
                                    color               : rgba(215, 215, 215, 1.0);
                                    text-align          : center;
                                    letter-spacing      : 0.58px;
                                    line-height         : 25.0px;
                                }
                            </style>
                            <div id="YJ4Ivqs">
                                <a href="work.html">
                                </a>
                                <div class="bp2-work bp2-work-i6SH component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                    <a href="work.html">
                                    </a>
                                    <a href="work.html">
                                        <div class="bp2-work1 anima-valign-text-middle">
                                            Work
                                        </div>
                                    </a>
                                    <a href="work.html">
                                        <div class="bp2-workhover anima-valign-text-middle anima-hidden ">
                                            Work
                                        </div>
                                    </a>
                                </div>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp2-web1366home .bp2-sectionhero .bp2-navbar .bp2-navbar1 .bp2-work-i6SH", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp2-workhover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp2-workhover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ".bp2-work1"
          }
        ], 
        "overrides": {
          ".bp2-workhover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <style>
                                .bp2-web1366home .bp2-sectionhero .bp2-navbar .bp2-navbar1 .bp2-home-TuJT * {
                                    box-sizing          : border-box;
                                }
                                .bp2-web1366home .bp2-sectionhero .bp2-navbar .bp2-navbar1 .bp2-home-TuJT {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 29px;
                                    width               : 93px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .bp2-web1366home .bp2-sectionhero .bp2-navbar .bp2-navbar1 .bp2-home-TuJT .bp2-home1 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 14px);
                                    height              : 28px;
                                    width               : 98.92%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0.54%;
                                    transform           : rotate(0deg);
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 21.0px;
                                    color               : rgba(255, 255, 255, 1.0);
                                    text-align          : center;
                                    letter-spacing      : 0.58px;
                                    line-height         : 25.0px;
                                }
                                .bp2-web1366home .bp2-sectionhero .bp2-navbar .bp2-navbar1 .bp2-home-TuJT .bp2-homehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 14px);
                                    height              : 28px;
                                    width               : 98.92%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0.54%;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 21.0px;
                                    color               : rgba(146, 146, 146, 1.0);
                                    text-align          : center;
                                    letter-spacing      : 0.58px;
                                    line-height         : 25.0px;
                                }
                            </style>
                            <div id="TcEZkXy">
                                <a href="#section-hero">
                                    <div class="bp2-home bp2-home-TuJT component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <div class="bp2-home1 anima-valign-text-middle">
                                            Home
                                        </div>
                                        <div class="bp2-homehover anima-valign-text-middle anima-hidden ">
                                            Home
                                        </div>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp2-web1366home .bp2-sectionhero .bp2-navbar .bp2-navbar1 .bp2-home-TuJT", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp2-homehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp2-homehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp2-homehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                        </div>
                    </div>
                </div>
                <div class="bp2-sectionwork">
                    <div class="bp2-workbg">
                    </div>
                    <div class="bp2-workcontent">
                        <style>
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card4-XIrS * {
                                box-sizing          : border-box;
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card4-XIrS {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 724px;
                                height              : 420px;
                                width               : 593px;
                                position            : absolute;
                                margin              : 0;
                                left                : 615px;
                                transform           : rotate(0deg);
                                transition          : all 0.2s ease-in-out;
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card4-XIrS .bp2-card11 {
                                background-color    : rgba(248, 17, 34, 1.0);
                                top                 : 2.62%;
                                height              : 88.33%;
                                width               : 95.28%;
                                position            : absolute;
                                margin              : 0;
                                left                : 2.36%;
                                border-radius       : 7px;
                                overflow            : hidden;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card4-XIrS .bp2-card11 .bp2-mask {
                                background-color    : rgba(248, 17, 34, 1.0);
                                top                 : 0px;
                                height              : 99.73%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 7px;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card4-XIrS .bp2-card11 .bp2-adobesystemslogoandwordmark {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 27.63%;
                                height              : 44.74%;
                                width               : 33.27%;
                                position            : absolute;
                                margin              : 0;
                                left                : 33.36%;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card4-XIrS .bp2-card11 .bp2-adobesystemslogoandwordmark .bp2-g4151 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : relative;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card4-XIrS .bp2-card11 .bp2-adobesystemslogoandwordmark .bp2-g4151 .bp2-polygon15 {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 0.53%;
                                top                 : 0px;
                                height              : 100%;
                                width               : 36.70%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card4-XIrS .bp2-card11 .bp2-adobesystemslogoandwordmark .bp2-g4151 .bp2-polygon17 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 37.23%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card4-XIrS .bp2-card11 .bp2-adobesystemslogoandwordmark .bp2-g4151 .bp2-polygon19 {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 26.06%;
                                bottom              : 0px;
                                height              : 63.25%;
                                width               : 39.89%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card4-XIrS .bp2-card1hover {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : -0.48%;
                                height              : 100%;
                                width               : 97.81%;
                                position            : absolute;
                                margin              : 0;
                                left                : 1.10%;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card4-XIrS .bp2-card1hover .bp2-card1hover1 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 2.14%;
                                height              : 88.33%;
                                width               : 97.41%;
                                position            : absolute;
                                margin              : 0;
                                left                : 1.29%;
                                border-radius       : 7px;
                                overflow            : hidden;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card4-XIrS .bp2-card1hover .bp2-card1hover1 .bp2-mask1 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 0px;
                                height              : 99.73%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 7px;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card4-XIrS .bp2-card1hover .bp2-card1hover1 .bp2-mask2 {
                                background-color    : rgba(248, 17, 34, 1.0);
                                top                 : 0px;
                                height              : 99.73%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 7px;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card4-XIrS .bp2-card1hover .bp2-card1hover1 .bp2-adobesystemslogoandwordmark1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 27.63%;
                                height              : 44.74%;
                                width               : 33.27%;
                                position            : absolute;
                                margin              : 0;
                                left                : 33.36%;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card4-XIrS .bp2-card1hover .bp2-card1hover1 .bp2-adobesystemslogoandwordmark1 .bp2-g41511 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : relative;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card4-XIrS .bp2-card1hover .bp2-card1hover1 .bp2-adobesystemslogoandwordmark1 .bp2-g41511 .bp2-polygon151 {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 0.53%;
                                top                 : 0px;
                                height              : 100%;
                                width               : 36.70%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card4-XIrS .bp2-card1hover .bp2-card1hover1 .bp2-adobesystemslogoandwordmark1 .bp2-g41511 .bp2-polygon171 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 37.23%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card4-XIrS .bp2-card1hover .bp2-card1hover1 .bp2-adobesystemslogoandwordmark1 .bp2-g41511 .bp2-polygon191 {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 26.06%;
                                bottom              : 0px;
                                height              : 63.25%;
                                width               : 39.89%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card4-XIrS .bp2-card1hover .bp2-card1hover1 .bp2-maskcopy {
                                background-color    : rgba(0, 0, 0, 1.0);
                                top                 : 0px;
                                height              : 99.73%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 7px;
                                transform           : rotate(0deg);
                                opacity             : 0.77;
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card4-XIrS .bp2-card1hover .bp2-card1hover1 .bp2-group2 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 33.56%;
                                height              : 32.88%;
                                width               : 54.51%;
                                position            : absolute;
                                margin              : 0;
                                left                : 22.74%;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card4-XIrS .bp2-card1hover .bp2-card1hover1 .bp2-group2 .bp2-sslrpfooddeals {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0.82%;
                                height              : 84px;
                                width               : 99.68%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Bold", Helvetica, Arial, serif;
                                font-size           : 42.0px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : center;
                                letter-spacing      : 0.81px;
                                line-height         : 52.0px;
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card4-XIrS .bp2-card1hover .bp2-card1hover1 .bp2-group2 .bp2-productdesign {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 0.82%;
                                height              : 22px;
                                width               : 54.55%;
                                position            : absolute;
                                margin              : 0;
                                left                : 22.40%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 22.4px;
                                color               : rgba(201, 201, 201, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.43px;
                                line-height         : 27.0px;
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card4-XIrS .bp2-card1hover .bp2-bluebox {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card4-XIrS .bp2-card1hover .bp2-bluebox .bp2-pixels {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 0px;
                                height              : 6.67%;
                                width               : 20.00%;
                                position            : absolute;
                                margin              : 0;
                                left                : 40.00%;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card4-XIrS .bp2-card1hover .bp2-bluebox .bp2-pixels .bp2-rectangle1 {
                                background-color    : rgba(59, 172, 247, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 2px;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card4-XIrS .bp2-card1hover .bp2-bluebox .bp2-pixels .bp2-a665x429 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 7px);
                                height              : 14px;
                                width               : 65.52%;
                                position            : absolute;
                                margin              : 0;
                                left                : 17.24%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 14.0px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : center;
                                letter-spacing      : 0.27px;
                                line-height         : 17.0px;
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card4-XIrS .bp2-card1hover .bp2-bluebox .bp2-outline {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 91.90%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card4-XIrS .bp2-card1hover .bp2-bluebox .bp2-outline .bp2-rectangle2 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 1.42%;
                                height              : 97.15%;
                                box-sizing          : border-box;
                                width               : 98.10%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.95%;
                                border-style        : solid;
                                border-width        : 2px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card4-XIrS .bp2-card1hover .bp2-bluebox .bp2-outline .bp2-rectangle3 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                top                 : 0.52%;
                                height              : 3.11%;
                                box-sizing          : border-box;
                                width               : 2.07%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.34%;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card4-XIrS .bp2-card1hover .bp2-bluebox .bp2-outline .bp2-rectanglecopy2 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                bottom              : 0px;
                                height              : 3.11%;
                                box-sizing          : border-box;
                                width               : 2.07%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card4-XIrS .bp2-card1hover .bp2-bluebox .bp2-outline .bp2-rectanglecopy3 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                right               : 0px;
                                bottom              : 0px;
                                height              : 3.11%;
                                box-sizing          : border-box;
                                width               : 2.07%;
                                position            : absolute;
                                margin              : 0;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card4-XIrS .bp2-card1hover .bp2-bluebox .bp2-outline .bp2-rectanglecopy4 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                right               : 0px;
                                top                 : 0px;
                                height              : 3.37%;
                                box-sizing          : border-box;
                                width               : 2.07%;
                                position            : absolute;
                                margin              : 0;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                        </style>
                        <div id="MLaQQDp">
                            <a href="adobe.html">
                                <div class="bp2-card4 bp2-card4-XIrS component anima-component-wrapper anima-not-ready anima-word-break anima-smart-layers-pointers state1" data-initial-state="state1">
                                    <div class="bp2-card11">
                                        <div class="bp2-mask">
                                        </div>
                                        <div class="bp2-adobesystemslogoandwordmark">
                                            <div class="bp2-g4151">
                                                <img alt="Image" class="bp2-polygon15" src="./img/web-1366-home-polygon15-1@2x.png"/>
                                                <img alt="Image" class="bp2-polygon17" src="./img/web-1366-home-polygon17-1@2x.png"/>
                                                <img alt="Image" class="bp2-polygon19" src="./img/web-1366-home-polygon19-1@2x.png"/>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="bp2-card1hover anima-hidden ">
                                        <div class="bp2-card1hover1">
                                            <div class="bp2-mask1">
                                            </div>
                                            <div class="bp2-mask2">
                                            </div>
                                            <div class="bp2-adobesystemslogoandwordmark1">
                                                <div class="bp2-g41511">
                                                    <img alt="Image" class="bp2-polygon151" src="./img/web-1366-home-polygon15-1@2x.png"/>
                                                    <img alt="Image" class="bp2-polygon171" src="./img/web-1366-home-polygon17-1@2x.png"/>
                                                    <img alt="Image" class="bp2-polygon191" src="./img/web-1366-home-polygon19-1@2x.png"/>
                                                </div>
                                            </div>
                                            <div class="bp2-maskcopy">
                                            </div>
                                            <div class="bp2-group2">
                                                <div class="bp2-sslrpfooddeals">
                                                    Adobe x The Ocean Agency
                                                </div>
                                                <div class="bp2-productdesign">
                                                    Product Design
                                                </div>
                                            </div>
                                        </div>
                                        <div class="bp2-bluebox">
                                            <div class="bp2-pixels">
                                                <div class="bp2-rectangle1">
                                                </div>
                                                <div class="bp2-a665x429">
                                                    APR x 2020
                                                </div>
                                            </div>
                                            <div class="bp2-outline">
                                                <div class="bp2-rectangle2">
                                                </div>
                                                <div class="bp2-rectangle3">
                                                </div>
                                                <div class="bp2-rectanglecopy2">
                                                </div>
                                                <div class="bp2-rectanglecopy3">
                                                </div>
                                                <div class="bp2-rectanglecopy4">
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </a>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card4-XIrS", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp2-card1hover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp2-card1hover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp2-card1hover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                        <style>
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card3-R26K * {
                                box-sizing          : border-box;
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card3-R26K {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 723px;
                                height              : 420px;
                                width               : 593px;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                                transition          : all 0.2s ease-in-out;
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card3-R26K .bp2-card11 {
                                background-color    : rgba(97, 0, 238, 1.0);
                                top                 : 2.86%;
                                height              : 88.33%;
                                width               : 95.28%;
                                position            : absolute;
                                margin              : 0;
                                left                : 2.36%;
                                border-radius       : 7px;
                                overflow            : hidden;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card3-R26K .bp2-card11 .bp2-mask {
                                background-color    : rgba(97, 0, 238, 1.0);
                                top                 : 0px;
                                height              : 99.73%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 7px;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card3-R26K .bp2-card11 .bp2-rectangle {
                                background-color    : rgba(98, 0, 238, 1.0);
                                top                 : -0.81%;
                                height              : 100.27%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card3-R26K .bp2-card11 .bp2-swift {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 25px;
                                height              : 325px;
                                width               : 506px;
                                position            : absolute;
                                margin              : 0;
                                left                : 30px;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card3-R26K .bp2-card1hover {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : -0.71%;
                                height              : 100%;
                                width               : 97.81%;
                                position            : absolute;
                                margin              : 0;
                                left                : 1.10%;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card3-R26K .bp2-card1hover .bp2-card1hover1 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 1.90%;
                                height              : 88.33%;
                                width               : 97.59%;
                                position            : absolute;
                                margin              : 0;
                                left                : 1.21%;
                                border-radius       : 7px;
                                overflow            : hidden;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card3-R26K .bp2-card1hover .bp2-card1hover1 .bp2-mask1 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 0px;
                                height              : 99.73%;
                                width               : 99.82%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 7px;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card3-R26K .bp2-card1hover .bp2-card1hover1 .bp2-rectangle {
                                background-color    : rgba(97, 0, 238, 1.0);
                                top                 : -0.54%;
                                height              : 100.54%;
                                box-sizing          : border-box;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-style        : solid;
                                border-width        : 0px;
                                border-color        : rgba(150, 150, 150, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card3-R26K .bp2-card1hover .bp2-card1hover1 .bp2-swift {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 13.78%;
                                bottom              : 14.02%;
                                height              : 70.35%;
                                width               : 71.91%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card3-R26K .bp2-card1hover .bp2-card1hover1 .bp2-swift .bp2-swift1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card3-R26K .bp2-card1hover .bp2-card1hover1 .bp2-mask {
                                background-color    : rgba(0, 0, 0, 1.0);
                                top                 : 0px;
                                height              : 99.73%;
                                width               : 99.82%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 7px;
                                transform           : rotate(0deg);
                                opacity             : 0.77;
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card3-R26K .bp2-card1hover .bp2-card1hover1 .bp2-group3 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 40.30%;
                                height              : 19.41%;
                                width               : 44.35%;
                                position            : absolute;
                                margin              : 0;
                                left                : 27.83%;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card3-R26K .bp2-card1hover .bp2-card1hover1 .bp2-group3 .bp2-sslrpfooddeals {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 42px;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Bold", Helvetica, Arial, serif;
                                font-size           : 42.0px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.81px;
                                line-height         : 52.0px;
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card3-R26K .bp2-card1hover .bp2-card1hover1 .bp2-group3 .bp2-productdesign {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 1.39%;
                                height              : 22px;
                                width               : 66.14%;
                                position            : absolute;
                                margin              : 0;
                                left                : 16.93%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 22.4px;
                                color               : rgba(201, 201, 201, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.43px;
                                line-height         : 27.0px;
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card3-R26K .bp2-card1hover .bp2-bluebox {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card3-R26K .bp2-card1hover .bp2-bluebox .bp2-pixels {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 0px;
                                height              : 6.67%;
                                width               : 20.00%;
                                position            : absolute;
                                margin              : 0;
                                left                : 40.00%;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card3-R26K .bp2-card1hover .bp2-bluebox .bp2-pixels .bp2-rectangle1 {
                                background-color    : rgba(59, 172, 247, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 2px;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card3-R26K .bp2-card1hover .bp2-bluebox .bp2-pixels .bp2-a665x429 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 7px);
                                height              : 14px;
                                width               : 68.97%;
                                position            : absolute;
                                margin              : 0;
                                left                : 15.52%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 14.0px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : center;
                                letter-spacing      : 0.27px;
                                line-height         : 17.0px;
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card3-R26K .bp2-card1hover .bp2-bluebox .bp2-outline {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 91.90%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card3-R26K .bp2-card1hover .bp2-bluebox .bp2-outline .bp2-rectangle2 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 1.42%;
                                height              : 97.15%;
                                box-sizing          : border-box;
                                width               : 98.10%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.95%;
                                border-style        : solid;
                                border-width        : 2px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card3-R26K .bp2-card1hover .bp2-bluebox .bp2-outline .bp2-rectangle3 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                top                 : 0.52%;
                                height              : 3.11%;
                                box-sizing          : border-box;
                                width               : 2.24%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card3-R26K .bp2-card1hover .bp2-bluebox .bp2-outline .bp2-rectanglecopy2 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                bottom              : 0px;
                                height              : 3.11%;
                                box-sizing          : border-box;
                                width               : 2.07%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card3-R26K .bp2-card1hover .bp2-bluebox .bp2-outline .bp2-rectanglecopy3 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                right               : 0px;
                                bottom              : 0px;
                                height              : 3.11%;
                                box-sizing          : border-box;
                                width               : 2.07%;
                                position            : absolute;
                                margin              : 0;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card3-R26K .bp2-card1hover .bp2-bluebox .bp2-outline .bp2-rectanglecopy4 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                right               : 0px;
                                top                 : 0px;
                                height              : 3.37%;
                                box-sizing          : border-box;
                                width               : 2.07%;
                                position            : absolute;
                                margin              : 0;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                        </style>
                        <div id="ZgpQcSx">
                            <a href="swiftrides.html">
                                <div class="bp2-card3 bp2-card3-R26K component anima-component-wrapper anima-not-ready anima-word-break anima-smart-layers-pointers state1" data-initial-state="state1">
                                    <div class="bp2-card11">
                                        <div class="bp2-mask">
                                        </div>
                                        <div class="bp2-rectangle">
                                        </div>
                                        <img alt="Image" class="bp2-swift" src="./img/web-1366-home-swift.png"/>
                                    </div>
                                    <div class="bp2-card1hover anima-hidden ">
                                        <div class="bp2-card1hover1">
                                            <div class="bp2-mask1">
                                            </div>
                                            <div class="bp2-rectangle">
                                            </div>
                                            <div class="bp2-swift">
                                                <img alt="Image" class="bp2-swift1" src="./img/web-1366-home-swift-1.png"/>
                                            </div>
                                            <div class="bp2-mask">
                                            </div>
                                            <div class="bp2-group3">
                                                <div class="bp2-sslrpfooddeals">
                                                    SWIFT Rides
                                                </div>
                                                <div class="bp2-productdesign">
                                                    Product Design
                                                </div>
                                            </div>
                                        </div>
                                        <div class="bp2-bluebox">
                                            <div class="bp2-pixels">
                                                <div class="bp2-rectangle1">
                                                </div>
                                                <div class="bp2-a665x429">
                                                    JUNE x 2017
                                                </div>
                                            </div>
                                            <div class="bp2-outline">
                                                <div class="bp2-rectangle2">
                                                </div>
                                                <div class="bp2-rectangle3">
                                                </div>
                                                <div class="bp2-rectanglecopy2">
                                                </div>
                                                <div class="bp2-rectanglecopy3">
                                                </div>
                                                <div class="bp2-rectanglecopy4">
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </a>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card3-R26K", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp2-card1hover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp2-card1hover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp2-card1hover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                        <style>
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card2-JwOg * {
                                box-sizing          : border-box;
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card2-JwOg {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 282px;
                                height              : 420px;
                                width               : 593px;
                                position            : absolute;
                                margin              : 0;
                                left                : 615px;
                                transform           : rotate(0deg);
                                transition          : all 0.2s ease-in-out;
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card2-JwOg .bp2-card11 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 2.62%;
                                height              : 88.33%;
                                width               : 95.28%;
                                position            : absolute;
                                margin              : 0;
                                left                : 2.36%;
                                border-radius       : 7px;
                                overflow            : hidden;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card2-JwOg .bp2-card11 .bp2-mask {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 0px;
                                height              : 99.73%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 7px;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card2-JwOg .bp2-card11 .bp2-screenshot20200423at83825pm {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : -42px;
                                height              : 426px;
                                width               : 799px;
                                position            : absolute;
                                margin              : 0;
                                left                : -117px;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card2-JwOg .bp2-card1hover {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : -0.71%;
                                height              : 100%;
                                width               : 97.81%;
                                position            : absolute;
                                margin              : 0;
                                left                : 1.10%;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card2-JwOg .bp2-card1hover .bp2-card1hover1 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 1.90%;
                                height              : 88.33%;
                                width               : 97.41%;
                                position            : absolute;
                                margin              : 0;
                                left                : 1.29%;
                                border-radius       : 7px;
                                overflow            : hidden;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card2-JwOg .bp2-card1hover .bp2-card1hover1 .bp2-mask1 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 0px;
                                height              : 99.73%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 7px;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card2-JwOg .bp2-card1hover .bp2-card1hover1 .bp2-screenshot20200423at83825pm {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : -42px;
                                height              : 426px;
                                width               : 799px;
                                position            : absolute;
                                margin              : 0;
                                left                : -117px;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card2-JwOg .bp2-card1hover .bp2-card1hover1 .bp2-mask {
                                background-color    : rgba(0, 0, 0, 1.0);
                                top                 : 0px;
                                height              : 99.73%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 7px;
                                transform           : rotate(0deg);
                                opacity             : 0.77;
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card2-JwOg .bp2-card1hover .bp2-card1hover1 .bp2-sslrpfooddeals {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 40.43%;
                                height              : 42px;
                                width               : 37.17%;
                                position            : absolute;
                                margin              : 0;
                                left                : 31.42%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Bold", Helvetica, Arial, serif;
                                font-size           : 42.0px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.81px;
                                line-height         : 52.0px;
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card2-JwOg .bp2-card1hover .bp2-card1hover1 .bp2-productdesign {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 40.43%;
                                height              : 22px;
                                width               : 29.91%;
                                position            : absolute;
                                margin              : 0;
                                left                : 35.04%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 22.4px;
                                color               : rgba(201, 201, 201, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.43px;
                                line-height         : 27.0px;
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card2-JwOg .bp2-card1hover .bp2-bluebox {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card2-JwOg .bp2-card1hover .bp2-bluebox .bp2-pixels {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 0px;
                                height              : 6.67%;
                                width               : 20.00%;
                                position            : absolute;
                                margin              : 0;
                                left                : 40.00%;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card2-JwOg .bp2-card1hover .bp2-bluebox .bp2-pixels .bp2-rectangle1 {
                                background-color    : rgba(59, 172, 247, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 2px;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card2-JwOg .bp2-card1hover .bp2-bluebox .bp2-pixels .bp2-a665x429 {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 23.28%;
                                top                 : calc(50.00% - 7px);
                                height              : 14px;
                                width               : 51.72%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 14.0px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : center;
                                letter-spacing      : 0.27px;
                                line-height         : 17.0px;
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card2-JwOg .bp2-card1hover .bp2-bluebox .bp2-outline {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 91.90%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card2-JwOg .bp2-card1hover .bp2-bluebox .bp2-outline .bp2-rectangle2 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 1.42%;
                                height              : 97.15%;
                                box-sizing          : border-box;
                                width               : 98.10%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.95%;
                                border-style        : solid;
                                border-width        : 2px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card2-JwOg .bp2-card1hover .bp2-bluebox .bp2-outline .bp2-rectangle3 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                top                 : 0.52%;
                                height              : 3.11%;
                                box-sizing          : border-box;
                                width               : 2.07%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.34%;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card2-JwOg .bp2-card1hover .bp2-bluebox .bp2-outline .bp2-rectanglecopy2 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                bottom              : 0px;
                                height              : 3.11%;
                                box-sizing          : border-box;
                                width               : 2.07%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card2-JwOg .bp2-card1hover .bp2-bluebox .bp2-outline .bp2-rectanglecopy3 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                right               : 0px;
                                bottom              : 0px;
                                height              : 3.11%;
                                box-sizing          : border-box;
                                width               : 2.07%;
                                position            : absolute;
                                margin              : 0;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card2-JwOg .bp2-card1hover .bp2-bluebox .bp2-outline .bp2-rectanglecopy4 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                right               : 0px;
                                top                 : 0px;
                                height              : 3.11%;
                                box-sizing          : border-box;
                                width               : 2.07%;
                                position            : absolute;
                                margin              : 0;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                        </style>
                        <div id="Rj12hv9">
                            <a href="designco.html">
                                <div class="bp2-card2 bp2-card2-JwOg component anima-component-wrapper anima-not-ready anima-word-break anima-smart-layers-pointers state1" data-initial-state="state1">
                                    <div class="bp2-card11">
                                        <div class="bp2-mask">
                                        </div>
                                        <img alt="Image" class="bp2-screenshot20200423at83825pm" src="./img/web-1366-home-screen-shot-2020-04-23-at-83825-pm.png"/>
                                    </div>
                                    <div class="bp2-card1hover anima-hidden ">
                                        <div class="bp2-card1hover1">
                                            <div class="bp2-mask1">
                                            </div>
                                            <img alt="Image" class="bp2-screenshot20200423at83825pm" src="./img/web-1366-home-screen-shot-2020-04-23-at-83825-pm.png"/>
                                            <div class="bp2-mask">
                                            </div>
                                            <div class="bp2-sslrpfooddeals">
                                                Design Co
                                            </div>
                                            <div class="bp2-productdesign">
                                                Student Leader
                                            </div>
                                        </div>
                                        <div class="bp2-bluebox">
                                            <div class="bp2-pixels">
                                                <div class="bp2-rectangle1">
                                                </div>
                                                <div class="bp2-a665x429">
                                                    PRESENT
                                                </div>
                                            </div>
                                            <div class="bp2-outline">
                                                <div class="bp2-rectangle2">
                                                </div>
                                                <div class="bp2-rectangle3">
                                                </div>
                                                <div class="bp2-rectanglecopy2">
                                                </div>
                                                <div class="bp2-rectanglecopy3">
                                                </div>
                                                <div class="bp2-rectanglecopy4">
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </a>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card2-JwOg", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp2-card1hover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp2-card1hover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp2-card1hover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                        <style>
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card1-jP9N * {
                                box-sizing          : border-box;
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card1-jP9N {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 282px;
                                height              : 420px;
                                width               : 593px;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                                transition          : all 0.2s ease-in-out;
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card1-jP9N .bp2-card11 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 2.62%;
                                height              : 88.33%;
                                width               : 95.28%;
                                position            : absolute;
                                margin              : 0;
                                left                : 2.36%;
                                border-radius       : 7px;
                                overflow            : hidden;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card1-jP9N .bp2-card11 .bp2-mask {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 0px;
                                height              : 99.73%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 7px;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card1-jP9N .bp2-card11 .bp2-rotatosnapshot {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 370px;
                                width               : 658px;
                                position            : absolute;
                                margin              : 0;
                                left                : -46px;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card1-jP9N .bp2-card1hover {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : -0.71%;
                                height              : 100%;
                                width               : 97.81%;
                                position            : absolute;
                                margin              : 0;
                                left                : 1.10%;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card1-jP9N .bp2-card1hover .bp2-card1hover1 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 1.90%;
                                height              : 88.33%;
                                width               : 97.41%;
                                position            : absolute;
                                margin              : 0;
                                left                : 1.29%;
                                border-radius       : 7px;
                                overflow            : hidden;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card1-jP9N .bp2-card1hover .bp2-card1hover1 .bp2-mask1 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 0px;
                                height              : 99.73%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 7px;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card1-jP9N .bp2-card1hover .bp2-card1hover1 .bp2-rotatosnapshot1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 370px;
                                width               : 658px;
                                position            : absolute;
                                margin              : 0;
                                left                : -46px;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card1-jP9N .bp2-card1hover .bp2-card1hover1 .bp2-mask {
                                background-color    : rgba(0, 0, 0, 1.0);
                                top                 : 0px;
                                height              : 99.73%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 7px;
                                transform           : rotate(0deg);
                                opacity             : 0.77;
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card1-jP9N .bp2-card1hover .bp2-card1hover1 .bp2-sslrpfooddeals {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 40.43%;
                                height              : 42px;
                                width               : 44.78%;
                                position            : absolute;
                                margin              : 0;
                                left                : 27.61%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Bold", Helvetica, Arial, serif;
                                font-size           : 42.0px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.81px;
                                line-height         : 52.0px;
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card1-jP9N .bp2-card1hover .bp2-card1hover1 .bp2-productdesign {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 40.43%;
                                height              : 22px;
                                width               : 29.73%;
                                position            : absolute;
                                margin              : 0;
                                left                : 35.13%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 22.4px;
                                color               : rgba(201, 201, 201, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.43px;
                                line-height         : 27.0px;
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card1-jP9N .bp2-card1hover .bp2-bluebox {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card1-jP9N .bp2-card1hover .bp2-bluebox .bp2-pixels {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 0px;
                                height              : 6.67%;
                                width               : 20.00%;
                                position            : absolute;
                                margin              : 0;
                                left                : 40.00%;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card1-jP9N .bp2-card1hover .bp2-bluebox .bp2-pixels .bp2-rectangle1 {
                                background-color    : rgba(59, 172, 247, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 2px;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card1-jP9N .bp2-card1hover .bp2-bluebox .bp2-pixels .bp2-a665x429 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 7px);
                                height              : 14px;
                                width               : 60.34%;
                                position            : absolute;
                                margin              : 0;
                                left                : 19.83%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 14.0px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : center;
                                letter-spacing      : 0.27px;
                                line-height         : 17.0px;
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card1-jP9N .bp2-card1hover .bp2-bluebox .bp2-outline {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 91.90%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card1-jP9N .bp2-card1hover .bp2-bluebox .bp2-outline .bp2-rectangle2 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 1.42%;
                                height              : 97.15%;
                                box-sizing          : border-box;
                                width               : 98.10%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.95%;
                                border-style        : solid;
                                border-width        : 2px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card1-jP9N .bp2-card1hover .bp2-bluebox .bp2-outline .bp2-rectangle3 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                top                 : 0.52%;
                                height              : 3.11%;
                                box-sizing          : border-box;
                                width               : 2.24%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card1-jP9N .bp2-card1hover .bp2-bluebox .bp2-outline .bp2-rectanglecopy2 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                bottom              : 0px;
                                height              : 3.11%;
                                box-sizing          : border-box;
                                width               : 2.07%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card1-jP9N .bp2-card1hover .bp2-bluebox .bp2-outline .bp2-rectanglecopy3 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                right               : 0px;
                                bottom              : 0px;
                                height              : 3.11%;
                                box-sizing          : border-box;
                                width               : 2.07%;
                                position            : absolute;
                                margin              : 0;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card1-jP9N .bp2-card1hover .bp2-bluebox .bp2-outline .bp2-rectanglecopy4 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                right               : 0px;
                                top                 : 0px;
                                height              : 3.11%;
                                box-sizing          : border-box;
                                width               : 2.07%;
                                position            : absolute;
                                margin              : 0;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                        </style>
                        <div id="ZCOjYnF">
                            <a href="sslrpdeals.html">
                                <div class="bp2-card1 bp2-card1-jP9N component anima-component-wrapper anima-not-ready anima-word-break anima-smart-layers-pointers state1" data-initial-state="state1">
                                    <div class="bp2-card11">
                                        <div class="bp2-mask">
                                        </div>
                                        <img alt="Image" class="bp2-rotatosnapshot" src="./img/web-1366-home-rotato-snapshot.png"/>
                                    </div>
                                    <div class="bp2-card1hover anima-hidden ">
                                        <div class="bp2-card1hover1">
                                            <div class="bp2-mask1">
                                            </div>
                                            <img alt="Image" class="bp2-rotatosnapshot1" src="./img/web-1366-home-rotato-snapshot.png"/>
                                            <div class="bp2-mask">
                                            </div>
                                            <div class="bp2-sslrpfooddeals">
                                                SSLRP Deals
                                            </div>
                                            <div class="bp2-productdesign">
                                                Product Design
                                            </div>
                                        </div>
                                        <div class="bp2-bluebox">
                                            <div class="bp2-pixels">
                                                <div class="bp2-rectangle1">
                                                </div>
                                                <div class="bp2-a665x429">
                                                    FEB x 2019
                                                </div>
                                            </div>
                                            <div class="bp2-outline">
                                                <div class="bp2-rectangle2">
                                                </div>
                                                <div class="bp2-rectangle3">
                                                </div>
                                                <div class="bp2-rectanglecopy2">
                                                </div>
                                                <div class="bp2-rectanglecopy3">
                                                </div>
                                                <div class="bp2-rectanglecopy4">
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </a>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp2-web1366home .bp2-sectionwork .bp2-workcontent .bp2-card1-jP9N", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp2-card1hover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp2-card1hover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp2-card1hover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                        <div class="bp2-text">
                            <div anima-show-on-scroll="" class="bp2-h2">
                                Crafted with intention. Bringing all attention.
                            </div>
                            <div anima-show-on-scroll="" class="bp2-h1">
                                Embarking on a Journey through Pixels.
                            </div>
                            <div anima-show-on-scroll="" class="bp2-h3">
                                WORK
                            </div>
                        </div>
                    </div>
                </div>
                <div class="bp2-sectionfooter">
                    <img alt="Image" anima-src="./img/web-1366-designco-bg.png" class="bp2-bg" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                    <div class="bp2-footer">
                        <div class="bp2-socialicons">
                            <style>
                                .bp2-web1366home .bp2-sectionfooter .bp2-footer .bp2-socialicons .bp2-dribbble-ewic * {
                                    box-sizing          : border-box;
                                }
                                .bp2-web1366home .bp2-sectionfooter .bp2-footer .bp2-socialicons .bp2-dribbble-ewic {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 43px;
                                    width               : 43px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 85px;
                                    transform           : rotate(0deg);
                                }
                                .bp2-web1366home .bp2-sectionfooter .bp2-footer .bp2-socialicons .bp2-dribbble-ewic .bp2-shape {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .bp2-web1366home .bp2-sectionfooter .bp2-footer .bp2-socialicons .bp2-dribbble-ewic .bp2-shapehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                }
                            </style>
                            <div id="RQwgF0v">
                                <a href="https://dribbble.com/syedadam007" target="_blank">
                                    <div class="bp2-dribbble bp2-dribbble-ewic component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <img alt="Image" class="bp2-shape" src="./img/web-1366-playground-shape-2@2x.png"/>
                                        <img alt="Image" class="bp2-shapehover anima-hidden " src="./img/web-1366-about-shapehover@2x.png"/>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp2-web1366home .bp2-sectionfooter .bp2-footer .bp2-socialicons .bp2-dribbble-ewic", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp2-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp2-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp2-shapehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <style>
                                .bp2-web1366home .bp2-sectionfooter .bp2-footer .bp2-socialicons .bp2-linkedin-Lbxo * {
                                    box-sizing          : border-box;
                                }
                                .bp2-web1366home .bp2-sectionfooter .bp2-footer .bp2-socialicons .bp2-linkedin-Lbxo {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 43px;
                                    width               : 43px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .bp2-web1366home .bp2-sectionfooter .bp2-footer .bp2-socialicons .bp2-linkedin-Lbxo .bp2-shape {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .bp2-web1366home .bp2-sectionfooter .bp2-footer .bp2-socialicons .bp2-linkedin-Lbxo .bp2-shapehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                }
                            </style>
                            <div id="C5fvYVp">
                                <a href="https://www.linkedin.com/in/syedadamemirputra/" target="_blank">
                                    <div class="bp2-linkedin bp2-linkedin-Lbxo component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <img alt="Image" class="bp2-shape" src="./img/web-1366-designco-shape-1@2x.png"/>
                                        <img alt="Image" class="bp2-shapehover anima-hidden " src="./img/web-1366-adobe-shapehover-1@2x.png"/>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp2-web1366home .bp2-sectionfooter .bp2-footer .bp2-socialicons .bp2-linkedin-Lbxo", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp2-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp2-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp2-shapehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <style>
                                .bp2-web1366home .bp2-sectionfooter .bp2-footer .bp2-socialicons .bp2-instagram-DyKd * {
                                    box-sizing          : border-box;
                                }
                                .bp2-web1366home .bp2-sectionfooter .bp2-footer .bp2-socialicons .bp2-instagram-DyKd {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 1px;
                                    height              : 43px;
                                    width               : 43px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 171px;
                                    transform           : rotate(0deg);
                                }
                                .bp2-web1366home .bp2-sectionfooter .bp2-footer .bp2-socialicons .bp2-instagram-DyKd .bp2-shape {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 1.16%;
                                    height              : 97.67%;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .bp2-web1366home .bp2-sectionfooter .bp2-footer .bp2-socialicons .bp2-instagram-DyKd .bp2-shapehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 1.16%;
                                    height              : 97.67%;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                }
                            </style>
                            <div id="EJFO76E">
                                <a href="https://www.instagram.com/syedadam007/" target="_blank">
                                    <div class="bp2-instagram bp2-instagram-DyKd component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <img alt="Image" class="bp2-shape" src="./img/web-1366-sslrpdeals-shape-2@2x.png"/>
                                        <img alt="Image" class="bp2-shapehover anima-hidden " src="./img/web-1366-swiftrides-shapehover-2@2x.png"/>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp2-web1366home .bp2-sectionfooter .bp2-footer .bp2-socialicons .bp2-instagram-DyKd", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp2-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp2-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp2-shapehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                        </div>
                        <div anima-show-on-scroll="" class="bp2-h3">
                            Â© 2020 Lil Adam X
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="bp1-home anima-word-break " id="None">
            <div style="width: 1920px; height: 100%; position:relative; margin:auto;">
                <div class="bp1-sectionfooter">
                    <img alt="Image" anima-src="./img/swiftrides-bg.png" class="bp1-bg" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                    <div class="bp1-footer">
                        <div class="bp1-socialicons">
                            <style>
                                .bp1-home .bp1-sectionfooter .bp1-footer .bp1-socialicons .bp1-dribbble-GCb8 * {
                                    box-sizing          : border-box;
                                }
                                .bp1-home .bp1-sectionfooter .bp1-footer .bp1-socialicons .bp1-dribbble-GCb8 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 60px;
                                    width               : 60px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 120px;
                                    transform           : rotate(0deg);
                                }
                                .bp1-home .bp1-sectionfooter .bp1-footer .bp1-socialicons .bp1-dribbble-GCb8 .bp1-shape {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .bp1-home .bp1-sectionfooter .bp1-footer .bp1-socialicons .bp1-dribbble-GCb8 .bp1-shapehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                }
                            </style>
                            <div id="aUeMplN">
                                <a href="https://dribbble.com/syedadam007" target="_blank">
                                    <div class="bp1-dribbble bp1-dribbble-GCb8 component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <img alt="Image" class="bp1-shape" src="./img/swiftrides-shape@2x.png"/>
                                        <img alt="Image" class="bp1-shapehover anima-hidden " src="./img/adobe-shapehover@2x.png"/>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp1-home .bp1-sectionfooter .bp1-footer .bp1-socialicons .bp1-dribbble-GCb8", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp1-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp1-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp1-shapehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <style>
                                .bp1-home .bp1-sectionfooter .bp1-footer .bp1-socialicons .bp1-linkedin-bIhC * {
                                    box-sizing          : border-box;
                                }
                                .bp1-home .bp1-sectionfooter .bp1-footer .bp1-socialicons .bp1-linkedin-bIhC {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 60px;
                                    width               : 60px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .bp1-home .bp1-sectionfooter .bp1-footer .bp1-socialicons .bp1-linkedin-bIhC .bp1-shape {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .bp1-home .bp1-sectionfooter .bp1-footer .bp1-socialicons .bp1-linkedin-bIhC .bp1-shapehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                }
                            </style>
                            <div id="h02wLRd">
                                <a href="https://www.linkedin.com/in/syedadamemirputra/" target="_blank">
                                    <div class="bp1-linkedin bp1-linkedin-bIhC component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <img alt="Image" class="bp1-shape" src="./img/sslrpdeals-shape-3@2x.png"/>
                                        <img alt="Image" class="bp1-shapehover anima-hidden " src="./img/about-shapehover-1@2x.png"/>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp1-home .bp1-sectionfooter .bp1-footer .bp1-socialicons .bp1-linkedin-bIhC", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp1-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp1-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp1-shapehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <style>
                                .bp1-home .bp1-sectionfooter .bp1-footer .bp1-socialicons .bp1-instagram-3deS * {
                                    box-sizing          : border-box;
                                }
                                .bp1-home .bp1-sectionfooter .bp1-footer .bp1-socialicons .bp1-instagram-3deS {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 1px;
                                    height              : 59px;
                                    width               : 60px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 240px;
                                    transform           : rotate(0deg);
                                }
                                .bp1-home .bp1-sectionfooter .bp1-footer .bp1-socialicons .bp1-instagram-3deS .bp1-shape {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .bp1-home .bp1-sectionfooter .bp1-footer .bp1-socialicons .bp1-instagram-3deS .bp1-shapehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                }
                            </style>
                            <div id="riGgkt4">
                                <a href="https://www.instagram.com/syedadam007/" target="_blank">
                                    <div class="bp1-instagram bp1-instagram-3deS component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <img alt="Image" class="bp1-shape" src="./img/adobe-shape-2@2x.png"/>
                                        <img alt="Image" class="bp1-shapehover anima-hidden " src="./img/sslrpdeals-shapehover-2@2x.png"/>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp1-home .bp1-sectionfooter .bp1-footer .bp1-socialicons .bp1-instagram-3deS", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp1-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp1-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp1-shapehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                        </div>
                        <div anima-show-on-scroll="" class="bp1-h3">
                            Â© 2020 Lil Adam X
                        </div>
                    </div>
                </div>
                <div class="bp1-sectionhero" id="None">
                    <div class="bp1-darkbg">
                    </div>
                    <div class="bp1-content">
                        <div anima-show-on-scroll="" class="bp1-mission">
                            Adam designs because the world ainâ€™t right. <br />Demystifying the ways the world should be.
                        </div>
                        <div class="bp1-present">
                            Present
                        </div>
                        <style>
                            .bp1-home .bp1-sectionhero .bp1-content .bp1-designco-a47C * {
                                box-sizing          : border-box;
                            }
                            .bp1-home .bp1-sectionhero .bp1-content .bp1-designco-a47C {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 330px;
                                height              : 32px;
                                width               : 158px;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionhero .bp1-content .bp1-designco-a47C .bp1-designco1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 16px);
                                height              : 32px;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 32.0px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.62px;
                                line-height         : 39.0px;
                            }
                            .bp1-home .bp1-sectionhero .bp1-content .bp1-designco-a47C .bp1-designcohover {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 16px);
                                height              : 32px;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 32.0px;
                                color               : rgba(146, 146, 146, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.62px;
                                line-height         : 39.0px;
                            }
                        </style>
                        <div id="G7fRISu">
                            <div class="bp1-designco bp1-designco-a47C component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                <a href="http://www.ucsddesign.co/" target="_blank">
                                    <div class="bp1-designco1">
                                        Design Co
                                    </div>
                                </a>
                                <a href="http://www.ucsddesign.co/" target="_blank">
                                    <div class="bp1-designcohover anima-hidden ">
                                        Design Co
                                    </div>
                                </a>
                            </div>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp1-home .bp1-sectionhero .bp1-content .bp1-designco-a47C", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp1-designcohover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp1-designcohover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp1-designcohover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                        <div class="bp1-education">
                            Education
                        </div>
                        <style>
                            .bp1-home .bp1-sectionhero .bp1-content .bp1-ucsd-AAfF * {
                                box-sizing          : border-box;
                            }
                            .bp1-home .bp1-sectionhero .bp1-content .bp1-ucsd-AAfF {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 491px;
                                height              : 32px;
                                width               : 214px;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionhero .bp1-content .bp1-ucsd-AAfF .bp1-ucsd1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 16px);
                                height              : 32px;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 32.0px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.62px;
                                line-height         : 39.0px;
                            }
                            .bp1-home .bp1-sectionhero .bp1-content .bp1-ucsd-AAfF .bp1-ucsdhover {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 16px);
                                height              : 32px;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 32.0px;
                                color               : rgba(146, 146, 146, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.62px;
                                line-height         : 39.0px;
                            }
                        </style>
                        <div id="eFM2CmH">
                            <div class="bp1-ucsd bp1-ucsd-AAfF component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                <a href="https://ucsd.edu/" target="_blank">
                                    <div class="bp1-ucsd1">
                                        UC San Diego
                                    </div>
                                </a>
                                <a href="https://ucsd.edu/" target="_blank">
                                    <div class="bp1-ucsdhover anima-hidden ">
                                        UC San Diego
                                    </div>
                                </a>
                            </div>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp1-home .bp1-sectionhero .bp1-content .bp1-ucsd-AAfF", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp1-ucsdhover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp1-ucsdhover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp1-ucsdhover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                        <div class="bp1-previous">
                            Previous
                        </div>
                        <style>
                            .bp1-home .bp1-sectionhero .bp1-content .bp1-longstorystudios-Vmdm * {
                                box-sizing          : border-box;
                            }
                            .bp1-home .bp1-sectionhero .bp1-content .bp1-longstorystudios-Vmdm {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 330px;
                                height              : 32px;
                                width               : 285px;
                                position            : absolute;
                                margin              : 0;
                                left                : 558px;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionhero .bp1-content .bp1-longstorystudios-Vmdm .bp1-ls {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 16px);
                                height              : 32px;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 32.0px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.62px;
                                line-height         : 39.0px;
                            }
                            .bp1-home .bp1-sectionhero .bp1-content .bp1-longstorystudios-Vmdm .bp1-lshover {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 16px);
                                height              : 32px;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 32.0px;
                                color               : rgba(146, 146, 146, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.62px;
                                line-height         : 39.0px;
                            }
                        </style>
                        <div id="XeTBbHk">
                            <div class="bp1-longstorystudios bp1-longstorystudios-Vmdm component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                <a href="https://www.longstorystudios.com/" target="_blank">
                                    <div class="bp1-ls">
                                        Long Story Studios
                                    </div>
                                </a>
                                <a href="https://www.longstorystudios.com/" target="_blank">
                                    <div class="bp1-lshover anima-hidden ">
                                        Long Story Studios
                                    </div>
                                </a>
                            </div>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp1-home .bp1-sectionhero .bp1-content .bp1-longstorystudios-Vmdm", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp1-lshover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp1-lshover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp1-lshover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                    </div>
                    <style>
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 * {
                            box-sizing          : border-box;
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 286px;
                            height              : 549px;
                            width               : 62px;
                            position            : absolute;
                            margin              : 0;
                            left                : 1858px;
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberoff {
                            background-color    : rgba(255,255,255,0.0);
                            bottom              : 0px;
                            height              : 75.59%;
                            width               : 100%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0px;
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberoff .bp1-lightsaberoff1 {
                            background-color    : rgba(255,255,255,0.0);
                            bottom              : 0px;
                            height              : 37.35%;
                            width               : 75.81%;
                            position            : absolute;
                            margin              : 0;
                            left                : 8.06%;
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberoff .bp1-lightsaberoff1 .bp1-rectangle {
                            background-color    : rgba(84, 82, 82, 1.0);
                            right               : 8.51%;
                            top                 : 39.68%;
                            height              : 20.65%;
                            width               : 78.72%;
                            position            : absolute;
                            margin              : 0;
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberoff .bp1-lightsaberoff1 .bp1-rectangle1 {
                            background-color    : rgba(196, 196, 196, 1.0);
                            top                 : 41.94%;
                            height              : 1.94%;
                            width               : 10.64%;
                            position            : absolute;
                            margin              : 0;
                            left                : 4.26%;
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberoff .bp1-lightsaberoff1 .bp1-rectangle2 {
                            background-color    : rgba(196, 196, 196, 1.0);
                            bottom              : 41.94%;
                            height              : 1.94%;
                            width               : 10.64%;
                            position            : absolute;
                            margin              : 0;
                            left                : 4.26%;
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberoff .bp1-lightsaberoff1 .bp1-rectangle3 {
                            background-color    : rgba(196, 196, 196, 1.0);
                            top                 : 45.81%;
                            height              : 3.87%;
                            width               : 10.64%;
                            position            : absolute;
                            margin              : 0;
                            left                : 4.26%;
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberoff .bp1-lightsaberoff1 .bp1-rectangle4 {
                            background-color    : rgba(196, 196, 196, 1.0);
                            bottom              : 45.81%;
                            height              : 3.87%;
                            width               : 10.64%;
                            position            : absolute;
                            margin              : 0;
                            left                : 4.26%;
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberoff .bp1-lightsaberoff1 .bp1-shape {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 38.71%;
                            height              : 22.58%;
                            width               : 95.74%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0px;
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberoff .bp1-lightsaberoff1 .bp1-rectangle5 {
                            background-color    : rgba(255,255,255,0.0);
                            right               : 12.77%;
                            bottom              : 3.87%;
                            height              : 36.13%;
                            box-sizing          : border-box;
                            width               : 65.96%;
                            position            : absolute;
                            margin              : 0;
                            border-style        : solid;
                            border-width        : 3px;
                            border-color        : rgba(0, 0, 0, 1.0);
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberoff .bp1-lightsaberoff1 .bp1-rectangle6 {
                            background-color    : rgba(196, 196, 196, 1.0);
                            right               : 12.77%;
                            top                 : 20.65%;
                            height              : 19.35%;
                            box-sizing          : border-box;
                            width               : 65.96%;
                            position            : absolute;
                            margin              : 0;
                            border-style        : solid;
                            border-width        : 3px;
                            border-color        : rgba(0, 0, 0, 1.0);
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberoff .bp1-lightsaberoff1 .bp1-rectangle7 {
                            background-color    : rgba(141, 141, 141, 1.0);
                            right               : 12.77%;
                            bottom              : 3.87%;
                            height              : 36.13%;
                            box-sizing          : border-box;
                            width               : 65.96%;
                            position            : absolute;
                            margin              : 0;
                            border-style        : solid;
                            border-width        : 3px;
                            border-color        : rgba(0, 0, 0, 1.0);
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberoff .bp1-lightsaberoff1 .bp1-rectangle8 {
                            background-color    : rgba(84, 82, 82, 1.0);
                            right               : 17.02%;
                            top                 : 0px;
                            height              : 13.55%;
                            box-sizing          : border-box;
                            width               : 55.32%;
                            position            : absolute;
                            margin              : 0;
                            border-style        : solid;
                            border-width        : 3px;
                            border-color        : rgba(0, 0, 0, 1.0);
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberoff .bp1-lightsaberoff1 .bp1-rectangle9 {
                            background-color    : rgba(84, 82, 82, 1.0);
                            right               : 0px;
                            top                 : 10.32%;
                            height              : 10.97%;
                            box-sizing          : border-box;
                            width               : 87.23%;
                            position            : absolute;
                            margin              : 0;
                            border-style        : solid;
                            border-width        : 3px;
                            border-color        : rgba(0, 0, 0, 1.0);
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberoff .bp1-lightsaberoff1 .bp1-path {
                            background-color    : rgba(255,255,255,0.0);
                            right               : 14.89%;
                            top                 : 12.90%;
                            height              : 6.45%;
                            width               : 8.51%;
                            position            : absolute;
                            margin              : 0;
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberoff .bp1-lightsaberoff1 .bp1-path1 {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 12.26%;
                            height              : 7.74%;
                            width               : 10.64%;
                            position            : absolute;
                            margin              : 0;
                            left                : 25.53%;
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberoff .bp1-lightsaberoff1 .bp1-rectangle10 {
                            background-color    : rgba(0, 0, 0, 1.0);
                            right               : 42.55%;
                            bottom              : 6.45%;
                            height              : 30.97%;
                            width               : 4.26%;
                            position            : absolute;
                            margin              : 0;
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberoff .bp1-lightsaberoff1 .bp1-rectangle11 {
                            background-color    : rgba(0, 0, 0, 1.0);
                            bottom              : 6.45%;
                            height              : 30.97%;
                            width               : 4.26%;
                            position            : absolute;
                            margin              : 0;
                            left                : 38.30%;
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberoff .bp1-lightsaberoff1 .bp1-rectangle12 {
                            background-color    : rgba(0, 0, 0, 1.0);
                            right               : 27.66%;
                            bottom              : 6.45%;
                            height              : 30.97%;
                            width               : 4.26%;
                            position            : absolute;
                            margin              : 0;
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberoff .bp1-lightsaberoff1 .bp1-rectangle13 {
                            background-color    : rgba(84, 82, 82, 1.0);
                            right               : 19.15%;
                            bottom              : 0px;
                            height              : 6.45%;
                            box-sizing          : border-box;
                            width               : 51.06%;
                            position            : absolute;
                            margin              : 0;
                            border-style        : solid;
                            border-width        : 3px;
                            border-color        : rgba(0, 0, 0, 1.0);
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberoff .bp1-achievements {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 0px;
                            height              : 54.46%;
                            width               : 100%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0px;
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberoff .bp1-achievements .bp1-rectangle14 {
                            background-color    : rgba(255, 255, 255, 1.0);
                            top                 : 0px;
                            height              : 100%;
                            box-sizing          : border-box;
                            width               : 100%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0px;
                            border-style        : solid;
                            border-width        : 1px;
                            border-color        : rgba(150, 150, 150, 1.0);
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberoff .bp1-achievements .bp1-achievements1 {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : calc(50.00% - 16px);
                            height              : 32px;
                            width               : 283.87%;
                            position            : absolute;
                            margin              : 0;
                            left                : -91.94%;
                            transform           : rotate(-90deg);
                            font-family         : "Gilroy-Bold", Helvetica, Arial, serif;
                            font-size           : 32.0px;
                            color               : rgba(0, 0, 0, 1.0);
                            text-align          : left;
                            letter-spacing      : 0.62px;
                            line-height         : 40.0px;
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberon {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : -0.36%;
                            height              : 100.36%;
                            width               : 100%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0px;
                            transform           : rotate(0deg);
                            opacity             : 0.0;
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberon .bp1-lightsaberon1 {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 0px;
                            height              : 100%;
                            width               : 75.81%;
                            position            : absolute;
                            margin              : 0;
                            left                : 8.06%;
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberon .bp1-lightsaberon1 .bp1-group {
                            background-color    : rgba(255,255,255,0.0);
                            right               : 25.53%;
                            top                 : 0px;
                            height              : 72.96%;
                            width               : 36.17%;
                            position            : absolute;
                            margin              : 0;
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberon .bp1-lightsaberon1 .bp1-group .bp1-path2 {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 0.50%;
                            height              : 99.00%;
                            width               : 82.35%;
                            position            : absolute;
                            margin              : 0;
                            left                : 8.82%;
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberon .bp1-lightsaberon1 .bp1-group .bp1-path3 {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 0px;
                            height              : 100%;
                            width               : 100%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0px;
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberon .bp1-lightsaberon1 .bp1-rectangle15 {
                            background-color    : rgba(84, 82, 82, 1.0);
                            right               : 8.51%;
                            bottom              : 11.07%;
                            height              : 5.81%;
                            width               : 78.72%;
                            position            : absolute;
                            margin              : 0;
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberon .bp1-lightsaberon1 .bp1-rectangle16 {
                            background-color    : rgba(196, 196, 196, 1.0);
                            bottom              : 15.79%;
                            height              : 0.54%;
                            width               : 10.64%;
                            position            : absolute;
                            margin              : 0;
                            left                : 4.26%;
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberon .bp1-lightsaberon1 .bp1-rectangle17 {
                            background-color    : rgba(196, 196, 196, 1.0);
                            bottom              : 11.80%;
                            height              : 0.54%;
                            width               : 10.64%;
                            position            : absolute;
                            margin              : 0;
                            left                : 4.26%;
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberon .bp1-lightsaberon1 .bp1-rectangle18 {
                            background-color    : rgba(196, 196, 196, 1.0);
                            bottom              : 14.16%;
                            height              : 1.09%;
                            width               : 10.64%;
                            position            : absolute;
                            margin              : 0;
                            left                : 4.26%;
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberon .bp1-lightsaberon1 .bp1-rectangle19 {
                            background-color    : rgba(196, 196, 196, 1.0);
                            bottom              : 12.89%;
                            height              : 1.09%;
                            width               : 10.64%;
                            position            : absolute;
                            margin              : 0;
                            left                : 4.26%;
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberon .bp1-lightsaberon1 .bp1-shape1 {
                            background-color    : rgba(255,255,255,0.0);
                            bottom              : 10.89%;
                            height              : 6.35%;
                            width               : 95.74%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0px;
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberon .bp1-lightsaberon1 .bp1-rectangle20 {
                            background-color    : rgba(255,255,255,0.0);
                            right               : 12.77%;
                            bottom              : 1.09%;
                            height              : 10.16%;
                            box-sizing          : border-box;
                            width               : 65.96%;
                            position            : absolute;
                            margin              : 0;
                            border-style        : solid;
                            border-width        : 3px;
                            border-color        : rgba(0, 0, 0, 1.0);
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberon .bp1-lightsaberon1 .bp1-rectangle21 {
                            background-color    : rgba(196, 196, 196, 1.0);
                            right               : 12.77%;
                            bottom              : 16.88%;
                            height              : 5.44%;
                            box-sizing          : border-box;
                            width               : 65.96%;
                            position            : absolute;
                            margin              : 0;
                            border-style        : solid;
                            border-width        : 3px;
                            border-color        : rgba(0, 0, 0, 1.0);
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberon .bp1-lightsaberon1 .bp1-rectangle22 {
                            background-color    : rgba(141, 141, 141, 1.0);
                            right               : 12.77%;
                            bottom              : 1.09%;
                            height              : 10.16%;
                            box-sizing          : border-box;
                            width               : 65.96%;
                            position            : absolute;
                            margin              : 0;
                            border-style        : solid;
                            border-width        : 3px;
                            border-color        : rgba(0, 0, 0, 1.0);
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberon .bp1-lightsaberon1 .bp1-rectangle23 {
                            background-color    : rgba(84, 82, 82, 1.0);
                            right               : 17.02%;
                            bottom              : 24.32%;
                            height              : 3.81%;
                            box-sizing          : border-box;
                            width               : 55.32%;
                            position            : absolute;
                            margin              : 0;
                            border-style        : solid;
                            border-width        : 3px;
                            border-color        : rgba(0, 0, 0, 1.0);
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberon .bp1-lightsaberon1 .bp1-rectangle24 {
                            background-color    : rgba(84, 82, 82, 1.0);
                            right               : 0px;
                            bottom              : 22.14%;
                            height              : 3.09%;
                            box-sizing          : border-box;
                            width               : 87.23%;
                            position            : absolute;
                            margin              : 0;
                            border-style        : solid;
                            border-width        : 3px;
                            border-color        : rgba(0, 0, 0, 1.0);
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberon .bp1-lightsaberon1 .bp1-path4 {
                            background-color    : rgba(255,255,255,0.0);
                            right               : 14.89%;
                            bottom              : 22.69%;
                            height              : 1.81%;
                            width               : 8.51%;
                            position            : absolute;
                            margin              : 0;
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberon .bp1-lightsaberon1 .bp1-path5 {
                            background-color    : rgba(255,255,255,0.0);
                            bottom              : 22.50%;
                            height              : 2.18%;
                            width               : 10.64%;
                            position            : absolute;
                            margin              : 0;
                            left                : 25.53%;
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberon .bp1-lightsaberon1 .bp1-rectangle25 {
                            background-color    : rgba(0, 0, 0, 1.0);
                            right               : 42.55%;
                            bottom              : 1.81%;
                            height              : 8.71%;
                            width               : 4.26%;
                            position            : absolute;
                            margin              : 0;
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberon .bp1-lightsaberon1 .bp1-rectangle26 {
                            background-color    : rgba(0, 0, 0, 1.0);
                            bottom              : 1.81%;
                            height              : 8.71%;
                            width               : 4.26%;
                            position            : absolute;
                            margin              : 0;
                            left                : 38.30%;
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberon .bp1-lightsaberon1 .bp1-rectangle27 {
                            background-color    : rgba(0, 0, 0, 1.0);
                            right               : 27.66%;
                            bottom              : 1.81%;
                            height              : 8.71%;
                            width               : 4.26%;
                            position            : absolute;
                            margin              : 0;
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberon .bp1-lightsaberon1 .bp1-rectangle28 {
                            background-color    : rgba(84, 82, 82, 1.0);
                            right               : 19.15%;
                            bottom              : 0px;
                            height              : 1.81%;
                            box-sizing          : border-box;
                            width               : 51.06%;
                            position            : absolute;
                            margin              : 0;
                            border-style        : solid;
                            border-width        : 3px;
                            border-color        : rgba(0, 0, 0, 1.0);
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberon .bp1-achievements2 {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 24.68%;
                            height              : 41.02%;
                            width               : 100%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0px;
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberon .bp1-achievements2 .bp1-rectangle29 {
                            background-color    : rgba(255, 255, 255, 1.0);
                            top                 : 0px;
                            height              : 100%;
                            width               : 100%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0px;
                            transform           : rotate(0deg);
                        }
                        .bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5 .bp1-lightsaberon .bp1-achievements2 .bp1-achievements3 {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : calc(50.00% - 16px);
                            height              : 32px;
                            width               : 283.87%;
                            position            : absolute;
                            margin              : 0;
                            left                : -91.94%;
                            transform           : rotate(-90deg);
                            font-family         : "Gilroy-Bold", Helvetica, Arial, serif;
                            font-size           : 32.0px;
                            color               : rgba(0, 0, 0, 1.0);
                            text-align          : left;
                            letter-spacing      : 0.62px;
                            line-height         : 40.0px;
                        }
                    </style>
                    <div id="oPj2pUT">
                        <div class="bp1-lightsaber bp1-lightsaber-yFd5 component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                            <div class="bp1-lightsaberoff">
                                <div class="bp1-lightsaberoff1">
                                    <div class="bp1-rectangle">
                                    </div>
                                    <div class="bp1-rectangle1">
                                    </div>
                                    <div class="bp1-rectangle2">
                                    </div>
                                    <div class="bp1-rectangle3">
                                    </div>
                                    <div class="bp1-rectangle4">
                                    </div>
                                    <img alt="Image" class="bp1-shape" src="./img/about-shape@2x.png"/>
                                    <div class="bp1-rectangle5">
                                    </div>
                                    <div class="bp1-rectangle6">
                                    </div>
                                    <div class="bp1-rectangle7">
                                    </div>
                                    <div class="bp1-rectangle8">
                                    </div>
                                    <div class="bp1-rectangle9">
                                    </div>
                                    <img alt="Image" class="bp1-path" src="./img/about-path@2x.png"/>
                                    <img alt="Image" class="bp1-path1" src="./img/home-path-1@2x.png"/>
                                    <div class="bp1-rectangle10">
                                    </div>
                                    <div class="bp1-rectangle11">
                                    </div>
                                    <div class="bp1-rectangle12">
                                    </div>
                                    <div class="bp1-rectangle13">
                                    </div>
                                </div>
                                <a href="playground.html">
                                    <div class="bp1-achievements">
                                        <div class="bp1-rectangle14">
                                        </div>
                                        <div class="bp1-achievements1">
                                            Playground
                                        </div>
                                    </div>
                                </a>
                            </div>
                            <div class="bp1-lightsaberon anima-hidden ">
                                <div class="bp1-lightsaberon1">
                                    <div class="bp1-group">
                                        <img alt="Image" class="bp1-path2" src="./img/home-path-2.png"/>
                                        <img alt="Image" class="bp1-path3" src="./img/home-path-3.png"/>
                                    </div>
                                    <div class="bp1-rectangle15">
                                    </div>
                                    <div class="bp1-rectangle16">
                                    </div>
                                    <div class="bp1-rectangle17">
                                    </div>
                                    <div class="bp1-rectangle18">
                                    </div>
                                    <div class="bp1-rectangle19">
                                    </div>
                                    <img alt="Image" class="bp1-shape1" src="./img/about-shape-1@2x.png"/>
                                    <div class="bp1-rectangle20">
                                    </div>
                                    <div class="bp1-rectangle21">
                                    </div>
                                    <div class="bp1-rectangle22">
                                    </div>
                                    <div class="bp1-rectangle23">
                                    </div>
                                    <div class="bp1-rectangle24">
                                    </div>
                                    <img alt="Image" class="bp1-path4" src="./img/about-path-4@2x.png"/>
                                    <img alt="Image" class="bp1-path5" src="./img/home-path-1@2x.png"/>
                                    <div class="bp1-rectangle25">
                                    </div>
                                    <div class="bp1-rectangle26">
                                    </div>
                                    <div class="bp1-rectangle27">
                                    </div>
                                    <div class="bp1-rectangle28">
                                    </div>
                                </div>
                                <a href="playground.html">
                                    <div class="bp1-achievements2">
                                        <div class="bp1-rectangle29">
                                        </div>
                                        <div class="bp1-achievements3">
                                            Playground
                                        </div>
                                    </div>
                                </a>
                            </div>
                        </div>
                    </div>
                    <script>
      (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp1-home .bp1-sectionhero .bp1-lightsaber-yFd5", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp1-lightsaberon": {
                "delay": 0, 
                "duration": 400, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ".bp1-lightsaberoff .bp1-achievements"
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp1-lightsaberon": {
                "delay": 0, 
                "duration": 400, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ".bp1-lightsaberon .bp1-achievements2"
          }
        ], 
        "overrides": {
          ".bp1-lightsaberon": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                    </script>
                    <div class="bp1-navbar">
                        <div class="bp1-rectangle">
                        </div>
                        <style>
                            .bp1-home .bp1-sectionhero .bp1-navbar .bp1-logo-Ewvv * {
                                box-sizing          : border-box;
                            }
                            .bp1-home .bp1-sectionhero .bp1-navbar .bp1-logo-Ewvv {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 77px;
                                height              : 44px;
                                width               : 256px;
                                position            : absolute;
                                margin              : 0;
                                left                : 130px;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionhero .bp1-navbar .bp1-logo-Ewvv .bp1-adamoutline {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 99.61%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionhero .bp1-navbar .bp1-logo-Ewvv .bp1-adamoutline .bp1-shape {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 1.14%;
                                height              : 97.73%;
                                width               : 82.35%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionhero .bp1-navbar .bp1-logo-Ewvv .bp1-adamoutline .bp1-path {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 0.39%;
                                bottom              : 13.64%;
                                height              : 65.91%;
                                width               : 10.98%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionhero .bp1-navbar .bp1-logo-Ewvv .bp1-adamfill {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 0px;
                                top                 : 2.27%;
                                height              : 95.45%;
                                width               : 99.22%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                            }
                            .bp1-home .bp1-sectionhero .bp1-navbar .bp1-logo-Ewvv .bp1-adamfill .bp1-shape1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 81.50%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionhero .bp1-navbar .bp1-logo-Ewvv .bp1-adamfill .bp1-path1 {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 0.39%;
                                bottom              : 11.90%;
                                height              : 71.43%;
                                width               : 11.42%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                        </style>
                        <div id="NB8BVug">
                            <div class="bp1-logo bp1-logo-Ewvv component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                <div class="bp1-adamoutline">
                                    <img alt="Image" class="bp1-shape" src="./img/about-shape-2@2x.png"/>
                                    <img alt="Image" class="bp1-path" src="./img/home-path-6@2x.png"/>
                                </div>
                                <div class="bp1-adamfill anima-hidden ">
                                    <img alt="Image" class="bp1-shape1" src="./img/work-shape-4@2x.png"/>
                                    <img alt="Image" class="bp1-path1" src="./img/about-path-7@2x.png"/>
                                </div>
                            </div>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp1-home .bp1-sectionhero .bp1-navbar .bp1-logo-Ewvv", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp1-adamfill": {
                "delay": 0, 
                "duration": 400, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp1-adamfill": {
                "delay": 0, 
                "duration": 500, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp1-adamfill": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                        <div class="bp1-navbar1">
                            <style>
                                .bp1-home .bp1-sectionhero .bp1-navbar .bp1-navbar1 .bp1-resume-Afl8 * {
                                    box-sizing          : border-box;
                                }
                                .bp1-home .bp1-sectionhero .bp1-navbar .bp1-navbar1 .bp1-resume-Afl8 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 40px;
                                    width               : 130px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 570px;
                                    transform           : rotate(0deg);
                                }
                                .bp1-home .bp1-sectionhero .bp1-navbar .bp1-navbar1 .bp1-resume-Afl8 .bp1-resume1 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 20px);
                                    height              : 40px;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 30.0px;
                                    color               : rgba(126, 126, 126, 1.0);
                                    text-align          : center;
                                    letter-spacing      : 0.83px;
                                    line-height         : 36.0px;
                                }
                                .bp1-home .bp1-sectionhero .bp1-navbar .bp1-navbar1 .bp1-resume-Afl8 .bp1-resumehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 20px);
                                    height              : 40px;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 30.0px;
                                    color               : rgba(31, 208, 118, 1.0);
                                    text-align          : center;
                                    letter-spacing      : 0.83px;
                                    line-height         : 36.0px;
                                }
                            </style>
                            <div id="2WWN47o">
                                <a href="https://drive.google.com/file/d/1KxPEStKpGkBtJaURrrckkRjVntkcITWU/view?usp=sharing" target="_blank">
                                    <div class="bp1-resume bp1-resume-Afl8 component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <div class="bp1-resume1 anima-valign-text-middle">
                                            Resume
                                        </div>
                                        <div class="bp1-resumehover anima-valign-text-middle anima-hidden ">
                                            Resume
                                        </div>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp1-home .bp1-sectionhero .bp1-navbar .bp1-navbar1 .bp1-resume-Afl8", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp1-resumehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp1-resumehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp1-resumehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <style>
                                .bp1-home .bp1-sectionhero .bp1-navbar .bp1-navbar1 .bp1-about-foAC * {
                                    box-sizing          : border-box;
                                }
                                .bp1-home .bp1-sectionhero .bp1-navbar .bp1-navbar1 .bp1-about-foAC {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 40px;
                                    width               : 130px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 380px;
                                    transform           : rotate(0deg);
                                }
                                .bp1-home .bp1-sectionhero .bp1-navbar .bp1-navbar1 .bp1-about-foAC .bp1-about1 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 20px);
                                    height              : 40px;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 30.0px;
                                    color               : rgba(126, 126, 126, 1.0);
                                    text-align          : center;
                                    letter-spacing      : 0.83px;
                                    line-height         : 36.0px;
                                }
                                .bp1-home .bp1-sectionhero .bp1-navbar .bp1-navbar1 .bp1-about-foAC .bp1-abouthover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 20px);
                                    height              : 40px;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 30.0px;
                                    color               : rgba(214, 214, 214, 1.0);
                                    text-align          : center;
                                    letter-spacing      : 0.83px;
                                    line-height         : 36.0px;
                                }
                            </style>
                            <div id="EoksQmn">
                                <a href="about.html">
                                    <div class="bp1-about bp1-about-foAC component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <div class="bp1-about1 anima-valign-text-middle">
                                            About
                                        </div>
                                        <div class="bp1-abouthover anima-valign-text-middle anima-hidden ">
                                            About
                                        </div>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp1-home .bp1-sectionhero .bp1-navbar .bp1-navbar1 .bp1-about-foAC", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp1-abouthover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp1-abouthover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp1-abouthover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <style>
                                .bp1-home .bp1-sectionhero .bp1-navbar .bp1-navbar1 .bp1-work-4khe * {
                                    box-sizing          : border-box;
                                }
                                .bp1-home .bp1-sectionhero .bp1-navbar .bp1-navbar1 .bp1-work-4khe {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 40px;
                                    width               : 130px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 190px;
                                    transform           : rotate(0deg);
                                }
                                .bp1-home .bp1-sectionhero .bp1-navbar .bp1-navbar1 .bp1-work-4khe .bp1-work1 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 20px);
                                    height              : 40px;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 30.0px;
                                    color               : rgba(126, 126, 126, 1.0);
                                    text-align          : center;
                                    letter-spacing      : 0.83px;
                                    line-height         : 36.0px;
                                }
                                .bp1-home .bp1-sectionhero .bp1-navbar .bp1-navbar1 .bp1-work-4khe .bp1-workhover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 20px);
                                    height              : 40px;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 30.0px;
                                    color               : rgba(215, 215, 215, 1.0);
                                    text-align          : center;
                                    letter-spacing      : 0.83px;
                                    line-height         : 36.0px;
                                }
                            </style>
                            <div id="Ltkl5Rq">
                                <a href="work.html">
                                </a>
                                <div class="bp1-work bp1-work-4khe component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                    <a href="work.html">
                                    </a>
                                    <a href="work.html">
                                        <div class="bp1-work1 anima-valign-text-middle">
                                            Work
                                        </div>
                                    </a>
                                    <a href="work.html">
                                        <div class="bp1-workhover anima-valign-text-middle anima-hidden ">
                                            Work
                                        </div>
                                    </a>
                                </div>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp1-home .bp1-sectionhero .bp1-navbar .bp1-navbar1 .bp1-work-4khe", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp1-workhover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp1-workhover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ".bp1-work1"
          }
        ], 
        "overrides": {
          ".bp1-workhover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <style>
                                .bp1-home .bp1-sectionhero .bp1-navbar .bp1-navbar1 .bp1-home1-I3Mo * {
                                    box-sizing          : border-box;
                                }
                                .bp1-home .bp1-sectionhero .bp1-navbar .bp1-navbar1 .bp1-home1-I3Mo {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 40px;
                                    width               : 130px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .bp1-home .bp1-sectionhero .bp1-navbar .bp1-navbar1 .bp1-home1-I3Mo .bp1-home2 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 20px);
                                    height              : 40px;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 30.0px;
                                    color               : rgba(255, 255, 255, 1.0);
                                    text-align          : center;
                                    letter-spacing      : 0.83px;
                                    line-height         : 36.0px;
                                }
                                .bp1-home .bp1-sectionhero .bp1-navbar .bp1-navbar1 .bp1-home1-I3Mo .bp1-homehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 20px);
                                    height              : 40px;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 30.0px;
                                    color               : rgba(146, 146, 146, 1.0);
                                    text-align          : center;
                                    letter-spacing      : 0.83px;
                                    line-height         : 36.0px;
                                }
                            </style>
                            <div id="pBownV4">
                                <div class="bp1-home1 bp1-home1-I3Mo component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                    <div class="bp1-home2 anima-valign-text-middle">
                                        Home
                                    </div>
                                    <div class="bp1-homehover anima-valign-text-middle anima-hidden ">
                                        Home
                                    </div>
                                </div>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp1-home .bp1-sectionhero .bp1-navbar .bp1-navbar1 .bp1-home1-I3Mo", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp1-homehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp1-homehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp1-homehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                        </div>
                    </div>
                </div>
                <div class="bp1-sectionwork">
                    <div class="bp1-workbg">
                    </div>
                    <div class="bp1-workcontent">
                        <style>
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card4-Huiu * {
                                box-sizing          : border-box;
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card4-Huiu {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 1016px;
                                height              : 589px;
                                width               : 834px;
                                position            : absolute;
                                margin              : 0;
                                left                : 865px;
                                transform           : rotate(0deg);
                                transition          : all 0.2s ease-in-out;
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card4-Huiu .bp1-card11 {
                                background-color    : rgba(248, 17, 34, 1.0);
                                top                 : 2.72%;
                                height              : 88.29%;
                                width               : 95.20%;
                                position            : absolute;
                                margin              : 0;
                                left                : 2.40%;
                                border-radius       : 10px;
                                overflow            : hidden;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card4-Huiu .bp1-card11 .bp1-mask {
                                background-color    : rgba(248, 17, 34, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 10px;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card4-Huiu .bp1-card11 .bp1-adobesystemslogoandwordmark {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 27.60%;
                                height              : 44.81%;
                                width               : 33.12%;
                                position            : absolute;
                                margin              : 0;
                                left                : 33.44%;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card4-Huiu .bp1-card11 .bp1-adobesystemslogoandwordmark .bp1-g4151 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : relative;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card4-Huiu .bp1-card11 .bp1-adobesystemslogoandwordmark .bp1-g4151 .bp1-polygon15 {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 0px;
                                top                 : 0px;
                                height              : 100%;
                                width               : 36.88%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card4-Huiu .bp1-card11 .bp1-adobesystemslogoandwordmark .bp1-g4151 .bp1-polygon17 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 37.26%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card4-Huiu .bp1-card11 .bp1-adobesystemslogoandwordmark .bp1-g4151 .bp1-polygon19 {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 26.24%;
                                bottom              : 0px;
                                height              : 63.09%;
                                width               : 39.92%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card4-Huiu .bp1-card1hover {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : -0.85%;
                                height              : 100%;
                                width               : 97.72%;
                                position            : absolute;
                                margin              : 0;
                                left                : 1.14%;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card4-Huiu .bp1-card1hover .bp1-card1hover1 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 1.87%;
                                height              : 88.29%;
                                width               : 97.42%;
                                position            : absolute;
                                margin              : 0;
                                left                : 1.29%;
                                border-radius       : 10px;
                                overflow            : hidden;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card4-Huiu .bp1-card1hover .bp1-card1hover1 .bp1-mask1 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 10px;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card4-Huiu .bp1-card1hover .bp1-card1hover1 .bp1-mask2 {
                                background-color    : rgba(248, 17, 34, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 10px;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card4-Huiu .bp1-card1hover .bp1-card1hover1 .bp1-adobesystemslogoandwordmark1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 27.60%;
                                height              : 44.81%;
                                width               : 33.12%;
                                position            : absolute;
                                margin              : 0;
                                left                : 33.44%;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card4-Huiu .bp1-card1hover .bp1-card1hover1 .bp1-adobesystemslogoandwordmark1 .bp1-g41511 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : relative;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card4-Huiu .bp1-card1hover .bp1-card1hover1 .bp1-adobesystemslogoandwordmark1 .bp1-g41511 .bp1-polygon151 {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 0px;
                                top                 : 0px;
                                height              : 100%;
                                width               : 36.88%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card4-Huiu .bp1-card1hover .bp1-card1hover1 .bp1-adobesystemslogoandwordmark1 .bp1-g41511 .bp1-polygon171 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 37.26%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card4-Huiu .bp1-card1hover .bp1-card1hover1 .bp1-adobesystemslogoandwordmark1 .bp1-g41511 .bp1-polygon191 {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 26.24%;
                                bottom              : 0px;
                                height              : 63.09%;
                                width               : 39.92%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card4-Huiu .bp1-card1hover .bp1-card1hover1 .bp1-maskcopy {
                                background-color    : rgba(0, 0, 0, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 10px;
                                transform           : rotate(0deg);
                                opacity             : 0.77;
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card4-Huiu .bp1-card1hover .bp1-card1hover1 .bp1-group2 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 33.56%;
                                height              : 32.88%;
                                width               : 54.41%;
                                position            : absolute;
                                margin              : 0;
                                left                : 22.80%;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card4-Huiu .bp1-card1hover .bp1-card1hover1 .bp1-group2 .bp1-sslrpfooddeals {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 120px;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Bold", Helvetica, Arial, serif;
                                font-size           : 60.0px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : center;
                                letter-spacing      : 1.15px;
                                line-height         : 74.0px;
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card4-Huiu .bp1-card1hover .bp1-card1hover1 .bp1-group2 .bp1-productdesign {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 0px;
                                height              : 32px;
                                width               : 54.86%;
                                position            : absolute;
                                margin              : 0;
                                left                : 22.57%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 32.0px;
                                color               : rgba(201, 201, 201, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.62px;
                                line-height         : 39.0px;
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card4-Huiu .bp1-card1hover .bp1-bluebox {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card4-Huiu .bp1-card1hover .bp1-bluebox .bp1-pixels {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 0px;
                                height              : 6.62%;
                                width               : 20.00%;
                                position            : absolute;
                                margin              : 0;
                                left                : 40.00%;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card4-Huiu .bp1-card1hover .bp1-bluebox .bp1-pixels .bp1-rectangle1 {
                                background-color    : rgba(59, 172, 247, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 3px;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card4-Huiu .bp1-card1hover .bp1-bluebox .bp1-pixels .bp1-a665x429 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 10px);
                                height              : 20px;
                                width               : 65.64%;
                                position            : absolute;
                                margin              : 0;
                                left                : 17.18%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 20.0px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : center;
                                letter-spacing      : 0.38px;
                                line-height         : 24.0px;
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card4-Huiu .bp1-card1hover .bp1-bluebox .bp1-outline {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 91.85%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card4-Huiu .bp1-card1hover .bp1-bluebox .bp1-outline .bp1-rectangle2 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 1.39%;
                                height              : 97.23%;
                                box-sizing          : border-box;
                                width               : 98.16%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.92%;
                                border-style        : solid;
                                border-width        : 3px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card4-Huiu .bp1-card1hover .bp1-bluebox .bp1-outline .bp1-rectangle3 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                top                 : 0.37%;
                                height              : 3.14%;
                                box-sizing          : border-box;
                                width               : 2.09%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.25%;
                                border-style        : solid;
                                border-width        : 2px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card4-Huiu .bp1-card1hover .bp1-bluebox .bp1-outline .bp1-rectanglecopy2 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                bottom              : 0px;
                                height              : 2.96%;
                                box-sizing          : border-box;
                                width               : 1.96%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-style        : solid;
                                border-width        : 2px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card4-Huiu .bp1-card1hover .bp1-bluebox .bp1-outline .bp1-rectanglecopy3 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                right               : 0px;
                                bottom              : 0px;
                                height              : 2.96%;
                                box-sizing          : border-box;
                                width               : 1.96%;
                                position            : absolute;
                                margin              : 0;
                                border-style        : solid;
                                border-width        : 2px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card4-Huiu .bp1-card1hover .bp1-bluebox .bp1-outline .bp1-rectanglecopy4 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                right               : 0px;
                                top                 : 0px;
                                height              : 2.96%;
                                box-sizing          : border-box;
                                width               : 1.96%;
                                position            : absolute;
                                margin              : 0;
                                border-style        : solid;
                                border-width        : 2px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                        </style>
                        <div id="pelivmI">
                            <a href="adobe.html">
                                <div class="bp1-card4 bp1-card4-Huiu component anima-component-wrapper anima-not-ready anima-word-break anima-smart-layers-pointers state1" data-initial-state="state1">
                                    <div class="bp1-card11">
                                        <div class="bp1-mask">
                                        </div>
                                        <div class="bp1-adobesystemslogoandwordmark">
                                            <div class="bp1-g4151">
                                                <img alt="Image" class="bp1-polygon15" src="./img/work-polygon15-1@2x.png"/>
                                                <img alt="Image" class="bp1-polygon17" src="./img/home-polygon17-1@2x.png"/>
                                                <img alt="Image" class="bp1-polygon19" src="./img/home-polygon19@2x.png"/>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="bp1-card1hover anima-hidden ">
                                        <div class="bp1-card1hover1">
                                            <div class="bp1-mask1">
                                            </div>
                                            <div class="bp1-mask2">
                                            </div>
                                            <div class="bp1-adobesystemslogoandwordmark1">
                                                <div class="bp1-g41511">
                                                    <img alt="Image" class="bp1-polygon151" src="./img/work-polygon15-1@2x.png"/>
                                                    <img alt="Image" class="bp1-polygon171" src="./img/home-polygon17-1@2x.png"/>
                                                    <img alt="Image" class="bp1-polygon191" src="./img/home-polygon19@2x.png"/>
                                                </div>
                                            </div>
                                            <div class="bp1-maskcopy">
                                            </div>
                                            <div class="bp1-group2">
                                                <div class="bp1-sslrpfooddeals">
                                                    Adobe x The Ocean Agency
                                                </div>
                                                <div class="bp1-productdesign">
                                                    Product Design
                                                </div>
                                            </div>
                                        </div>
                                        <div class="bp1-bluebox">
                                            <div class="bp1-pixels">
                                                <div class="bp1-rectangle1">
                                                </div>
                                                <div class="bp1-a665x429">
                                                    APR x 2020
                                                </div>
                                            </div>
                                            <div class="bp1-outline">
                                                <div class="bp1-rectangle2">
                                                </div>
                                                <div class="bp1-rectangle3">
                                                </div>
                                                <div class="bp1-rectanglecopy2">
                                                </div>
                                                <div class="bp1-rectanglecopy3">
                                                </div>
                                                <div class="bp1-rectanglecopy4">
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </a>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card4-Huiu", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp1-card1hover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp1-card1hover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp1-card1hover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                        <style>
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card3-Cgxt * {
                                box-sizing          : border-box;
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card3-Cgxt {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 1016px;
                                height              : 589px;
                                width               : 834px;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                                transition          : all 0.2s ease-in-out;
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card3-Cgxt .bp1-card11 {
                                background-color    : rgba(97, 0, 238, 1.0);
                                top                 : 2.72%;
                                height              : 88.29%;
                                width               : 95.20%;
                                position            : absolute;
                                margin              : 0;
                                left                : 2.40%;
                                border-radius       : 10px;
                                overflow            : hidden;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card3-Cgxt .bp1-card11 .bp1-mask {
                                background-color    : rgba(97, 0, 238, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 10px;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card3-Cgxt .bp1-card11 .bp1-rectangle {
                                background-color    : rgba(98, 0, 238, 1.0);
                                top                 : -0.58%;
                                height              : 100.58%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card3-Cgxt .bp1-card11 .bp1-swift {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 36px;
                                height              : 456px;
                                width               : 712px;
                                position            : absolute;
                                margin              : 0;
                                left                : 42px;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card3-Cgxt .bp1-card1hover {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : -0.85%;
                                height              : 100%;
                                width               : 97.72%;
                                position            : absolute;
                                margin              : 0;
                                left                : 1.14%;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card3-Cgxt .bp1-card1hover .bp1-card1hover1 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 1.87%;
                                height              : 88.29%;
                                width               : 97.42%;
                                position            : absolute;
                                margin              : 0;
                                left                : 1.29%;
                                border-radius       : 10px;
                                overflow            : hidden;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card3-Cgxt .bp1-card1hover .bp1-card1hover1 .bp1-mask1 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 10px;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card3-Cgxt .bp1-card1hover .bp1-card1hover1 .bp1-rectangle {
                                background-color    : rgba(97, 0, 238, 1.0);
                                top                 : -0.58%;
                                height              : 100.58%;
                                box-sizing          : border-box;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(150, 150, 150, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card3-Cgxt .bp1-card1hover .bp1-card1hover1 .bp1-swift {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 13.85%;
                                bottom              : 14.04%;
                                height              : 70.38%;
                                width               : 71.91%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card3-Cgxt .bp1-card1hover .bp1-card1hover1 .bp1-swift .bp1-swift1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card3-Cgxt .bp1-card1hover .bp1-card1hover1 .bp1-mask {
                                background-color    : rgba(0, 0, 0, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 10px;
                                transform           : rotate(0deg);
                                opacity             : 0.77;
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card3-Cgxt .bp1-card1hover .bp1-card1hover1 .bp1-group3 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 40.29%;
                                height              : 19.42%;
                                width               : 44.33%;
                                position            : absolute;
                                margin              : 0;
                                left                : 27.83%;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card3-Cgxt .bp1-card1hover .bp1-card1hover1 .bp1-group3 .bp1-sslrpfooddeals {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 60px;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Bold", Helvetica, Arial, serif;
                                font-size           : 60.0px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : left;
                                letter-spacing      : 1.15px;
                                line-height         : 74.0px;
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card3-Cgxt .bp1-card1hover .bp1-card1hover1 .bp1-group3 .bp1-productdesign {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 0px;
                                height              : 32px;
                                width               : 66.19%;
                                position            : absolute;
                                margin              : 0;
                                left                : 16.90%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 32.0px;
                                color               : rgba(201, 201, 201, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.62px;
                                line-height         : 39.0px;
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card3-Cgxt .bp1-card1hover .bp1-bluebox {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card3-Cgxt .bp1-card1hover .bp1-bluebox .bp1-pixels {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 0px;
                                height              : 6.62%;
                                width               : 20.00%;
                                position            : absolute;
                                margin              : 0;
                                left                : 40.00%;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card3-Cgxt .bp1-card1hover .bp1-bluebox .bp1-pixels .bp1-rectangle1 {
                                background-color    : rgba(59, 172, 247, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 3px;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card3-Cgxt .bp1-card1hover .bp1-bluebox .bp1-pixels .bp1-a665x429 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 10px);
                                height              : 20px;
                                width               : 69.33%;
                                position            : absolute;
                                margin              : 0;
                                left                : 15.34%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 20.0px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : center;
                                letter-spacing      : 0.38px;
                                line-height         : 24.0px;
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card3-Cgxt .bp1-card1hover .bp1-bluebox .bp1-outline {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 91.85%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card3-Cgxt .bp1-card1hover .bp1-bluebox .bp1-outline .bp1-rectangle2 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 1.39%;
                                height              : 97.23%;
                                box-sizing          : border-box;
                                width               : 98.16%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.92%;
                                border-style        : solid;
                                border-width        : 3px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card3-Cgxt .bp1-card1hover .bp1-bluebox .bp1-outline .bp1-rectangle3 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                top                 : 0.37%;
                                height              : 3.14%;
                                box-sizing          : border-box;
                                width               : 2.09%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.25%;
                                border-style        : solid;
                                border-width        : 2px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card3-Cgxt .bp1-card1hover .bp1-bluebox .bp1-outline .bp1-rectanglecopy2 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                bottom              : 0px;
                                height              : 2.96%;
                                box-sizing          : border-box;
                                width               : 1.96%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-style        : solid;
                                border-width        : 2px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card3-Cgxt .bp1-card1hover .bp1-bluebox .bp1-outline .bp1-rectanglecopy3 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                right               : 0px;
                                bottom              : 0px;
                                height              : 2.96%;
                                box-sizing          : border-box;
                                width               : 1.96%;
                                position            : absolute;
                                margin              : 0;
                                border-style        : solid;
                                border-width        : 2px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card3-Cgxt .bp1-card1hover .bp1-bluebox .bp1-outline .bp1-rectanglecopy4 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                right               : 0px;
                                top                 : 0px;
                                height              : 2.96%;
                                box-sizing          : border-box;
                                width               : 1.96%;
                                position            : absolute;
                                margin              : 0;
                                border-style        : solid;
                                border-width        : 2px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                        </style>
                        <div id="Wv8Joz9">
                            <a href="swiftrides.html">
                                <div class="bp1-card3 bp1-card3-Cgxt component anima-component-wrapper anima-not-ready anima-word-break anima-smart-layers-pointers state1" data-initial-state="state1">
                                    <div class="bp1-card11">
                                        <div class="bp1-mask">
                                        </div>
                                        <div class="bp1-rectangle">
                                        </div>
                                        <img alt="Image" class="bp1-swift" src="./img/work-swift.png"/>
                                    </div>
                                    <div class="bp1-card1hover anima-hidden ">
                                        <div class="bp1-card1hover1">
                                            <div class="bp1-mask1">
                                            </div>
                                            <div class="bp1-rectangle">
                                            </div>
                                            <div class="bp1-swift">
                                                <img alt="Image" class="bp1-swift1" src="./img/work-swift-1.png"/>
                                            </div>
                                            <div class="bp1-mask">
                                            </div>
                                            <div class="bp1-group3">
                                                <div class="bp1-sslrpfooddeals">
                                                    SWIFT Rides
                                                </div>
                                                <div class="bp1-productdesign">
                                                    Product Design
                                                </div>
                                            </div>
                                        </div>
                                        <div class="bp1-bluebox">
                                            <div class="bp1-pixels">
                                                <div class="bp1-rectangle1">
                                                </div>
                                                <div class="bp1-a665x429">
                                                    JUNE x 2017
                                                </div>
                                            </div>
                                            <div class="bp1-outline">
                                                <div class="bp1-rectangle2">
                                                </div>
                                                <div class="bp1-rectangle3">
                                                </div>
                                                <div class="bp1-rectanglecopy2">
                                                </div>
                                                <div class="bp1-rectanglecopy3">
                                                </div>
                                                <div class="bp1-rectanglecopy4">
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </a>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card3-Cgxt", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp1-card1hover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp1-card1hover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp1-card1hover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                        <style>
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card2-Lc18 * {
                                box-sizing          : border-box;
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card2-Lc18 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 396px;
                                height              : 589px;
                                width               : 834px;
                                position            : absolute;
                                margin              : 0;
                                left                : 865px;
                                transform           : rotate(0deg);
                                transition          : all 0.2s ease-in-out;
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card2-Lc18 .bp1-card11 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 2.72%;
                                height              : 88.29%;
                                width               : 95.20%;
                                position            : absolute;
                                margin              : 0;
                                left                : 2.40%;
                                border-radius       : 10px;
                                overflow            : hidden;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card2-Lc18 .bp1-card11 .bp1-mask {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 10px;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card2-Lc18 .bp1-card11 .bp1-screenshot20200423at83825pm {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : -59px;
                                height              : 598px;
                                width               : 1123px;
                                position            : absolute;
                                margin              : 0;
                                left                : -165px;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card2-Lc18 .bp1-card1hover {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : -0.85%;
                                height              : 100%;
                                width               : 97.72%;
                                position            : absolute;
                                margin              : 0;
                                left                : 1.14%;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card2-Lc18 .bp1-card1hover .bp1-card1hover1 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 1.87%;
                                height              : 88.29%;
                                width               : 97.42%;
                                position            : absolute;
                                margin              : 0;
                                left                : 1.29%;
                                border-radius       : 10px;
                                overflow            : hidden;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card2-Lc18 .bp1-card1hover .bp1-card1hover1 .bp1-mask1 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 10px;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card2-Lc18 .bp1-card1hover .bp1-card1hover1 .bp1-screenshot20200423at83825pm {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : -59px;
                                height              : 598px;
                                width               : 1123px;
                                position            : absolute;
                                margin              : 0;
                                left                : -165px;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card2-Lc18 .bp1-card1hover .bp1-card1hover1 .bp1-mask {
                                background-color    : rgba(0, 0, 0, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 10px;
                                transform           : rotate(0deg);
                                opacity             : 0.77;
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card2-Lc18 .bp1-card1hover .bp1-card1hover1 .bp1-sslrpfooddeals {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 40.38%;
                                height              : 60px;
                                width               : 37.28%;
                                position            : absolute;
                                margin              : 0;
                                left                : 31.36%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Bold", Helvetica, Arial, serif;
                                font-size           : 60.0px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : left;
                                letter-spacing      : 1.15px;
                                line-height         : 74.0px;
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card2-Lc18 .bp1-card1hover .bp1-card1hover1 .bp1-productdesign {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 40.19%;
                                height              : 32px;
                                width               : 29.97%;
                                position            : absolute;
                                margin              : 0;
                                left                : 35.01%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 32.0px;
                                color               : rgba(201, 201, 201, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.62px;
                                line-height         : 39.0px;
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card2-Lc18 .bp1-card1hover .bp1-bluebox {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card2-Lc18 .bp1-card1hover .bp1-bluebox .bp1-pixels {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 0px;
                                height              : 6.62%;
                                width               : 20.00%;
                                position            : absolute;
                                margin              : 0;
                                left                : 40.00%;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card2-Lc18 .bp1-card1hover .bp1-bluebox .bp1-pixels .bp1-rectangle1 {
                                background-color    : rgba(59, 172, 247, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 3px;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card2-Lc18 .bp1-card1hover .bp1-bluebox .bp1-pixels .bp1-a665x429 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 10px);
                                height              : 20px;
                                width               : 51.53%;
                                position            : absolute;
                                margin              : 0;
                                left                : 24.23%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 20.0px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : center;
                                letter-spacing      : 0.38px;
                                line-height         : 24.0px;
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card2-Lc18 .bp1-card1hover .bp1-bluebox .bp1-outline {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 91.85%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card2-Lc18 .bp1-card1hover .bp1-bluebox .bp1-outline .bp1-rectangle2 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 1.39%;
                                height              : 97.23%;
                                box-sizing          : border-box;
                                width               : 98.16%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.92%;
                                border-style        : solid;
                                border-width        : 3px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card2-Lc18 .bp1-card1hover .bp1-bluebox .bp1-outline .bp1-rectangle3 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                top                 : 0.37%;
                                height              : 3.14%;
                                box-sizing          : border-box;
                                width               : 2.09%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.25%;
                                border-style        : solid;
                                border-width        : 2px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card2-Lc18 .bp1-card1hover .bp1-bluebox .bp1-outline .bp1-rectanglecopy2 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                bottom              : 0px;
                                height              : 2.96%;
                                box-sizing          : border-box;
                                width               : 1.96%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-style        : solid;
                                border-width        : 2px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card2-Lc18 .bp1-card1hover .bp1-bluebox .bp1-outline .bp1-rectanglecopy3 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                right               : 0px;
                                bottom              : 0px;
                                height              : 2.96%;
                                box-sizing          : border-box;
                                width               : 1.96%;
                                position            : absolute;
                                margin              : 0;
                                border-style        : solid;
                                border-width        : 2px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card2-Lc18 .bp1-card1hover .bp1-bluebox .bp1-outline .bp1-rectanglecopy4 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                right               : 0px;
                                top                 : 0px;
                                height              : 2.96%;
                                box-sizing          : border-box;
                                width               : 1.96%;
                                position            : absolute;
                                margin              : 0;
                                border-style        : solid;
                                border-width        : 2px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                        </style>
                        <div id="aQFpMxp">
                            <a href="designco.html">
                                <div class="bp1-card2 bp1-card2-Lc18 component anima-component-wrapper anima-not-ready anima-word-break anima-smart-layers-pointers state1" data-initial-state="state1">
                                    <div class="bp1-card11">
                                        <div class="bp1-mask">
                                        </div>
                                        <img alt="Image" class="bp1-screenshot20200423at83825pm" src="./img/home-screen-shot-2020-04-23-at-83825-pm-1.png"/>
                                    </div>
                                    <div class="bp1-card1hover anima-hidden ">
                                        <div class="bp1-card1hover1">
                                            <div class="bp1-mask1">
                                            </div>
                                            <img alt="Image" class="bp1-screenshot20200423at83825pm" src="./img/home-screen-shot-2020-04-23-at-83825-pm-1.png"/>
                                            <div class="bp1-mask">
                                            </div>
                                            <div class="bp1-sslrpfooddeals">
                                                Design Co
                                            </div>
                                            <div class="bp1-productdesign">
                                                Student Leader
                                            </div>
                                        </div>
                                        <div class="bp1-bluebox">
                                            <div class="bp1-pixels">
                                                <div class="bp1-rectangle1">
                                                </div>
                                                <div class="bp1-a665x429">
                                                    PRESENT
                                                </div>
                                            </div>
                                            <div class="bp1-outline">
                                                <div class="bp1-rectangle2">
                                                </div>
                                                <div class="bp1-rectangle3">
                                                </div>
                                                <div class="bp1-rectanglecopy2">
                                                </div>
                                                <div class="bp1-rectanglecopy3">
                                                </div>
                                                <div class="bp1-rectanglecopy4">
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </a>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card2-Lc18", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp1-card1hover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp1-card1hover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp1-card1hover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                        <style>
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card1-ISsO * {
                                box-sizing          : border-box;
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card1-ISsO {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 396px;
                                height              : 589px;
                                width               : 834px;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                                transition          : all 0.2s ease-in-out;
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card1-ISsO .bp1-card11 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 2.72%;
                                height              : 88.29%;
                                width               : 95.20%;
                                position            : absolute;
                                margin              : 0;
                                left                : 2.40%;
                                border-radius       : 10px;
                                overflow            : hidden;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card1-ISsO .bp1-card11 .bp1-mask {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 10px;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card1-ISsO .bp1-card11 .bp1-rotatosnapshot {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 520px;
                                width               : 924px;
                                position            : absolute;
                                margin              : 0;
                                left                : -65px;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card1-ISsO .bp1-card1hover {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : -0.85%;
                                height              : 100%;
                                width               : 97.72%;
                                position            : absolute;
                                margin              : 0;
                                left                : 1.14%;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card1-ISsO .bp1-card1hover .bp1-card1hover1 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 1.87%;
                                height              : 88.29%;
                                width               : 97.42%;
                                position            : absolute;
                                margin              : 0;
                                left                : 1.29%;
                                border-radius       : 10px;
                                overflow            : hidden;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card1-ISsO .bp1-card1hover .bp1-card1hover1 .bp1-mask1 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 10px;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card1-ISsO .bp1-card1hover .bp1-card1hover1 .bp1-rotatosnapshot1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 520px;
                                width               : 924px;
                                position            : absolute;
                                margin              : 0;
                                left                : -65px;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card1-ISsO .bp1-card1hover .bp1-card1hover1 .bp1-mask {
                                background-color    : rgba(0, 0, 0, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 10px;
                                transform           : rotate(0deg);
                                opacity             : 0.77;
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card1-ISsO .bp1-card1hover .bp1-card1hover1 .bp1-sslrpfooddeals {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 40.38%;
                                height              : 60px;
                                width               : 44.71%;
                                position            : absolute;
                                margin              : 0;
                                left                : 27.64%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Bold", Helvetica, Arial, serif;
                                font-size           : 60.0px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : left;
                                letter-spacing      : 1.15px;
                                line-height         : 74.0px;
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card1-ISsO .bp1-card1hover .bp1-card1hover1 .bp1-productdesign {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 40.19%;
                                height              : 32px;
                                width               : 29.85%;
                                position            : absolute;
                                margin              : 0;
                                left                : 35.08%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 32.0px;
                                color               : rgba(201, 201, 201, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.62px;
                                line-height         : 39.0px;
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card1-ISsO .bp1-card1hover .bp1-bluebox {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card1-ISsO .bp1-card1hover .bp1-bluebox .bp1-pixels {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 0px;
                                height              : 6.62%;
                                width               : 20.00%;
                                position            : absolute;
                                margin              : 0;
                                left                : 40.00%;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card1-ISsO .bp1-card1hover .bp1-bluebox .bp1-pixels .bp1-rectangle1 {
                                background-color    : rgba(59, 172, 247, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 3px;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card1-ISsO .bp1-card1hover .bp1-bluebox .bp1-pixels .bp1-a665x429 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 10px);
                                height              : 20px;
                                width               : 60.12%;
                                position            : absolute;
                                margin              : 0;
                                left                : 19.94%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 20.0px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : center;
                                letter-spacing      : 0.38px;
                                line-height         : 24.0px;
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card1-ISsO .bp1-card1hover .bp1-bluebox .bp1-outline {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 91.85%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card1-ISsO .bp1-card1hover .bp1-bluebox .bp1-outline .bp1-rectangle2 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 1.39%;
                                height              : 97.23%;
                                box-sizing          : border-box;
                                width               : 98.16%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.92%;
                                border-style        : solid;
                                border-width        : 3px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card1-ISsO .bp1-card1hover .bp1-bluebox .bp1-outline .bp1-rectangle3 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                top                 : 0.37%;
                                height              : 3.14%;
                                box-sizing          : border-box;
                                width               : 2.09%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.25%;
                                border-style        : solid;
                                border-width        : 2px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card1-ISsO .bp1-card1hover .bp1-bluebox .bp1-outline .bp1-rectanglecopy2 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                bottom              : 0px;
                                height              : 2.96%;
                                box-sizing          : border-box;
                                width               : 1.96%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-style        : solid;
                                border-width        : 2px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card1-ISsO .bp1-card1hover .bp1-bluebox .bp1-outline .bp1-rectanglecopy3 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                right               : 0px;
                                bottom              : 0px;
                                height              : 2.96%;
                                box-sizing          : border-box;
                                width               : 1.96%;
                                position            : absolute;
                                margin              : 0;
                                border-style        : solid;
                                border-width        : 2px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card1-ISsO .bp1-card1hover .bp1-bluebox .bp1-outline .bp1-rectanglecopy4 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                right               : 0px;
                                top                 : 0px;
                                height              : 2.96%;
                                box-sizing          : border-box;
                                width               : 1.96%;
                                position            : absolute;
                                margin              : 0;
                                border-style        : solid;
                                border-width        : 2px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                        </style>
                        <div id="PntdqQm">
                            <a href="sslrpdeals.html">
                                <div class="bp1-card1 bp1-card1-ISsO component anima-component-wrapper anima-not-ready anima-word-break anima-smart-layers-pointers state1" data-initial-state="state1">
                                    <div class="bp1-card11">
                                        <div class="bp1-mask">
                                        </div>
                                        <img alt="Image" class="bp1-rotatosnapshot" src="./img/home-rotato-snapshot-1.png"/>
                                    </div>
                                    <div class="bp1-card1hover anima-hidden ">
                                        <div class="bp1-card1hover1">
                                            <div class="bp1-mask1">
                                            </div>
                                            <img alt="Image" class="bp1-rotatosnapshot1" src="./img/home-rotato-snapshot-1.png"/>
                                            <div class="bp1-mask">
                                            </div>
                                            <div class="bp1-sslrpfooddeals">
                                                SSLRP Deals
                                            </div>
                                            <div class="bp1-productdesign">
                                                Product Design
                                            </div>
                                        </div>
                                        <div class="bp1-bluebox">
                                            <div class="bp1-pixels">
                                                <div class="bp1-rectangle1">
                                                </div>
                                                <div class="bp1-a665x429">
                                                    FEB x 2019
                                                </div>
                                            </div>
                                            <div class="bp1-outline">
                                                <div class="bp1-rectangle2">
                                                </div>
                                                <div class="bp1-rectangle3">
                                                </div>
                                                <div class="bp1-rectanglecopy2">
                                                </div>
                                                <div class="bp1-rectanglecopy3">
                                                </div>
                                                <div class="bp1-rectanglecopy4">
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </a>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp1-home .bp1-sectionwork .bp1-workcontent .bp1-card1-ISsO", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp1-card1hover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp1-card1hover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp1-card1hover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                        <div class="bp1-text">
                            <div anima-show-on-scroll="" class="bp1-h2">
                                Crafted with intention. Bringing all attention.
                            </div>
                            <div anima-show-on-scroll="" class="bp1-h1">
                                Embarking on a Journey through Pixels.
                            </div>
                            <div anima-show-on-scroll="" class="bp1-h3">
                                WORK
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="bp5-ipadhome anima-word-break ">
            <div style="width: 768px; height: 100%; position:relative; margin:auto;">
                <div class="bp5-sectionhero" id="None">
                    <div class="bp5-darkbg">
                    </div>
                    <div class="bp5-content">
                        <div anima-show-on-scroll="" class="bp5-mission">
                            Adam designs because the world ainâ€™t right. <br />Demystifying the ways the world should be.
                        </div>
                        <div class="bp5-present">
                            Present
                        </div>
                        <style>
                            .bp5-ipadhome .bp5-sectionhero .bp5-content .bp5-designco-Iezw * {
                                box-sizing          : border-box;
                            }
                            .bp5-ipadhome .bp5-sectionhero .bp5-content .bp5-designco-Iezw {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 175px;
                                height              : 17px;
                                width               : 84px;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionhero .bp5-content .bp5-designco-Iezw .bp5-designco1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 8px);
                                height              : 16px;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 16.13px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.31px;
                                line-height         : 19.0px;
                            }
                            .bp5-ipadhome .bp5-sectionhero .bp5-content .bp5-designco-Iezw .bp5-designcohover {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 8px);
                                height              : 16px;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 16.13px;
                                color               : rgba(146, 146, 146, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.31px;
                                line-height         : 19.0px;
                            }
                        </style>
                        <div id="kZguKPy">
                            <div class="bp5-designco bp5-designco-Iezw component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                <a href="http://www.ucsddesign.co/" target="_blank">
                                    <div class="bp5-designco1">
                                        Design Co
                                    </div>
                                </a>
                                <a href="http://www.ucsddesign.co/" target="_blank">
                                    <div class="bp5-designcohover anima-hidden ">
                                        Design Co
                                    </div>
                                </a>
                            </div>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp5-ipadhome .bp5-sectionhero .bp5-content .bp5-designco-Iezw", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp5-designcohover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp5-designcohover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp5-designcohover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                        <div class="bp5-education">
                            Education
                        </div>
                        <style>
                            .bp5-ipadhome .bp5-sectionhero .bp5-content .bp5-ucsd-wfig * {
                                box-sizing          : border-box;
                            }
                            .bp5-ipadhome .bp5-sectionhero .bp5-content .bp5-ucsd-wfig {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 261px;
                                height              : 17px;
                                width               : 115px;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionhero .bp5-content .bp5-ucsd-wfig .bp5-ucsd1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 8px);
                                height              : 16px;
                                width               : 99.13%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.43%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 16.13px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.31px;
                                line-height         : 19.0px;
                            }
                            .bp5-ipadhome .bp5-sectionhero .bp5-content .bp5-ucsd-wfig .bp5-ucsdhover {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 8px);
                                height              : 16px;
                                width               : 99.13%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.43%;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 16.13px;
                                color               : rgba(146, 146, 146, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.31px;
                                line-height         : 19.0px;
                            }
                        </style>
                        <div id="VrE9QVE">
                            <div class="bp5-ucsd bp5-ucsd-wfig component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                <a href="https://ucsd.edu/" target="_blank">
                                    <div class="bp5-ucsd1">
                                        UC San Diego
                                    </div>
                                </a>
                                <a href="https://ucsd.edu/" target="_blank">
                                    <div class="bp5-ucsdhover anima-hidden ">
                                        UC San Diego
                                    </div>
                                </a>
                            </div>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp5-ipadhome .bp5-sectionhero .bp5-content .bp5-ucsd-wfig", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp5-ucsdhover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp5-ucsdhover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp5-ucsdhover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                        <div class="bp5-previous">
                            Previous
                        </div>
                        <style>
                            .bp5-ipadhome .bp5-sectionhero .bp5-content .bp5-longstorystudios-Obf9 * {
                                box-sizing          : border-box;
                            }
                            .bp5-ipadhome .bp5-sectionhero .bp5-content .bp5-longstorystudios-Obf9 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 175px;
                                height              : 17px;
                                width               : 153px;
                                position            : absolute;
                                margin              : 0;
                                left                : 297px;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionhero .bp5-content .bp5-longstorystudios-Obf9 .bp5-ls {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 8px);
                                height              : 16px;
                                width               : 99.35%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.33%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 16.13px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.31px;
                                line-height         : 19.0px;
                            }
                            .bp5-ipadhome .bp5-sectionhero .bp5-content .bp5-longstorystudios-Obf9 .bp5-lshover {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 8px);
                                height              : 16px;
                                width               : 99.35%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.33%;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 16.13px;
                                color               : rgba(146, 146, 146, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.31px;
                                line-height         : 19.0px;
                            }
                        </style>
                        <div id="N3Fpv2j">
                            <div class="bp5-longstorystudios bp5-longstorystudios-Obf9 component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                <a href="https://www.longstorystudios.com/" target="_blank">
                                    <div class="bp5-ls">
                                        Long Story Studios
                                    </div>
                                </a>
                                <a href="https://www.longstorystudios.com/" target="_blank">
                                    <div class="bp5-lshover anima-hidden ">
                                        Long Story Studios
                                    </div>
                                </a>
                            </div>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp5-ipadhome .bp5-sectionhero .bp5-content .bp5-longstorystudios-Obf9", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp5-lshover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp5-lshover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp5-lshover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                    </div>
                    <div class="bp5-lightsaber">
                        <div class="bp5-lightsaberoff">
                            <div class="bp5-lightsaberoff1">
                                <div class="bp5-rectangle">
                                </div>
                                <div class="bp5-rectangle1">
                                </div>
                                <div class="bp5-rectangle2">
                                </div>
                                <div class="bp5-rectangle3">
                                </div>
                                <div class="bp5-rectangle4">
                                </div>
                                <img alt="Image" anima-src="./img/ipad-about-shape-1@2x.png" class="bp5-shape" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                                <div class="bp5-rectangle5">
                                </div>
                                <div class="bp5-rectangle6">
                                </div>
                                <div class="bp5-rectangle7">
                                </div>
                                <div class="bp5-rectangle8">
                                </div>
                                <div class="bp5-rectangle9">
                                </div>
                                <img alt="Image" anima-src="./img/ipad-light-menu-hover-path-4@2x.png" class="bp5-path" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                                <img alt="Image" anima-src="./img/ipad-home-path-5@2x.png" class="bp5-path1" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                                <div class="bp5-rectangle10">
                                </div>
                                <div class="bp5-rectangle11">
                                </div>
                                <div class="bp5-rectangle12">
                                </div>
                                <div class="bp5-rectangle13">
                                </div>
                            </div>
                            <a href="playground.html">
                                <div class="bp5-playground">
                                    <div class="bp5-rectangle">
                                    </div>
                                    <div class="bp5-playground1">
                                        Playground
                                    </div>
                                </div>
                            </a>
                        </div>
                        <div class="bp5-lightsaberon">
                            <div class="bp5-lightsaberon1">
                                <div class="bp5-group">
                                    <img alt="Image" anima-src="./img/ipad-pro-129-home-path-2@2x.png" class="bp5-path2" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                                    <img alt="Image" anima-src="./img/ipad-about-path-3@2x.png" class="bp5-path11" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                                </div>
                                <div class="bp5-rectangle">
                                </div>
                                <div class="bp5-rectangle1">
                                </div>
                                <div class="bp5-rectangle2">
                                </div>
                                <div class="bp5-rectangle3">
                                </div>
                                <div class="bp5-rectangle4">
                                </div>
                                <img alt="Image" anima-src="./img/ipad-about-shape-1@2x.png" class="bp5-shape" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                                <div class="bp5-rectangle5">
                                </div>
                                <div class="bp5-rectangle6">
                                </div>
                                <div class="bp5-rectangle7">
                                </div>
                                <div class="bp5-rectangle8">
                                </div>
                                <div class="bp5-rectangle9">
                                </div>
                                <img alt="Image" anima-src="./img/ipad-light-menu-hover-path-4@2x.png" class="bp5-path" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                                <img alt="Image" anima-src="./img/ipad-home-path-5@2x.png" class="bp5-path1" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                                <div class="bp5-rectangle10">
                                </div>
                                <div class="bp5-rectangle11">
                                </div>
                                <div class="bp5-rectangle12">
                                </div>
                                <div class="bp5-rectangle13">
                                </div>
                            </div>
                            <a href="playground.html">
                                <div class="bp5-playground">
                                    <div class="bp5-rectangle">
                                    </div>
                                    <div class="bp5-playground1">
                                        Playground
                                    </div>
                                </div>
                            </a>
                        </div>
                    </div>
                    <div class="bp5-navbar">
                        <div class="bp5-rectangle">
                        </div>
                        <style>
                            .bp5-ipadhome .bp5-sectionhero .bp5-navbar .bp5-logo-GswC * {
                                box-sizing          : border-box;
                            }
                            .bp5-ipadhome .bp5-sectionhero .bp5-navbar .bp5-logo-GswC {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 41px;
                                height              : 24px;
                                width               : 137px;
                                position            : absolute;
                                margin              : 0;
                                left                : 50px;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionhero .bp5-navbar .bp5-logo-GswC .bp5-adamoutline {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 99.27%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.36%;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionhero .bp5-navbar .bp5-logo-GswC .bp5-adamoutline .bp5-shape1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 2.08%;
                                height              : 95.83%;
                                width               : 82.35%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionhero .bp5-navbar .bp5-logo-GswC .bp5-adamoutline .bp5-path {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 0px;
                                top                 : 18.75%;
                                height              : 62.50%;
                                width               : 11.03%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionhero .bp5-navbar .bp5-logo-GswC .bp5-adamfill {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 2.08%;
                                height              : 95.83%;
                                width               : 98.54%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.73%;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                            }
                            .bp5-ipadhome .bp5-sectionhero .bp5-navbar .bp5-logo-GswC .bp5-adamfill .bp5-shape1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 2.17%;
                                height              : 95.65%;
                                width               : 81.48%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionhero .bp5-navbar .bp5-logo-GswC .bp5-adamfill .bp5-path1 {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 0px;
                                top                 : 15.22%;
                                height              : 69.57%;
                                width               : 11.11%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                        </style>
                        <div id="LbkcwZu">
                            <div class="bp5-logo bp5-logo-GswC component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                <div class="bp5-adamoutline">
                                    <img alt="Image" class="bp5-shape1" src="./img/ipad-home-menu-hover-shape-4@2x.png"/>
                                    <img alt="Image" class="bp5-path" src="./img/ipad-home-menu-hover-path-6@2x.png"/>
                                </div>
                                <div class="bp5-adamfill anima-hidden ">
                                    <img alt="Image" class="bp5-shape1" src="./img/ipad-home-shape-3@2x.png"/>
                                    <img alt="Image" class="bp5-path1" src="./img/ipad-home-path-7@2x.png"/>
                                </div>
                            </div>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp5-ipadhome .bp5-sectionhero .bp5-navbar .bp5-logo-GswC", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp5-adamfill": {
                "delay": 0, 
                "duration": 400, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp5-adamfill": {
                "delay": 0, 
                "duration": 500, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp5-adamfill": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                        <a href="javascript:animaShowOverlay('ipadhomemenuhover', 'anima-animate-appear'); anima_loadAsyncSrc(); ">
                            <img alt="Image" anima-src="./img/ipad-work-shape-2@2x.png" class="bp5-shape" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                        </a>
                    </div>
                </div>
                <div class="bp5-sectionwork">
                    <div class="bp5-workbg">
                    </div>
                    <div class="bp5-workcontent">
                        <style>
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card4-Ma7o * {
                                box-sizing          : border-box;
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card4-Ma7o {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 405px;
                                height              : 236px;
                                width               : 332px;
                                position            : absolute;
                                margin              : 0;
                                left                : 346px;
                                transform           : rotate(0deg);
                                transition          : all 0.2s ease-in-out;
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card4-Ma7o .bp5-card11 {
                                background-color    : rgba(248, 17, 34, 1.0);
                                top                 : 2.97%;
                                height              : 88.14%;
                                width               : 95.78%;
                                position            : absolute;
                                margin              : 0;
                                left                : 2.11%;
                                border-radius       : 3px;
                                overflow            : hidden;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card4-Ma7o .bp5-card11 .bp5-mask {
                                background-color    : rgba(248, 17, 34, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 3px;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card4-Ma7o .bp5-card11 .bp5-adobesystemslogoandwordmark {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 33.02%;
                                top                 : 27.40%;
                                height              : 45.19%;
                                width               : 33.33%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card4-Ma7o .bp5-card11 .bp5-adobesystemslogoandwordmark .bp5-g4151 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : relative;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card4-Ma7o .bp5-card11 .bp5-adobesystemslogoandwordmark .bp5-g4151 .bp5-polygon15 {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 0.94%;
                                top                 : 0.53%;
                                height              : 98.94%;
                                width               : 36.79%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card4-Ma7o .bp5-card11 .bp5-adobesystemslogoandwordmark .bp5-g4151 .bp5-polygon17 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0.53%;
                                height              : 98.94%;
                                width               : 36.79%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card4-Ma7o .bp5-card11 .bp5-adobesystemslogoandwordmark .bp5-g4151 .bp5-polygon19 {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 27.36%;
                                bottom              : 0px;
                                height              : 62.77%;
                                width               : 39.62%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card4-Ma7o .bp5-card1hover {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : -0.85%;
                                height              : 100%;
                                width               : 98.49%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.75%;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card4-Ma7o .bp5-card1hover .bp5-card1hover1 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 2.12%;
                                height              : 88.14%;
                                width               : 97.25%;
                                position            : absolute;
                                margin              : 0;
                                left                : 1.38%;
                                border-radius       : 3px;
                                overflow            : hidden;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card4-Ma7o .bp5-card1hover .bp5-card1hover1 .bp5-mask1 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 3px;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card4-Ma7o .bp5-card1hover .bp5-card1hover1 .bp5-mask2 {
                                background-color    : rgba(248, 17, 34, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 3px;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card4-Ma7o .bp5-card1hover .bp5-card1hover1 .bp5-adobesystemslogoandwordmark1 {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 33.02%;
                                top                 : 27.40%;
                                height              : 45.19%;
                                width               : 33.33%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card4-Ma7o .bp5-card1hover .bp5-card1hover1 .bp5-adobesystemslogoandwordmark1 .bp5-g41511 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : relative;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card4-Ma7o .bp5-card1hover .bp5-card1hover1 .bp5-adobesystemslogoandwordmark1 .bp5-g41511 .bp5-polygon151 {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 0.94%;
                                top                 : 0.53%;
                                height              : 98.94%;
                                width               : 36.79%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card4-Ma7o .bp5-card1hover .bp5-card1hover1 .bp5-adobesystemslogoandwordmark1 .bp5-g41511 .bp5-polygon171 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0.53%;
                                height              : 98.94%;
                                width               : 36.79%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card4-Ma7o .bp5-card1hover .bp5-card1hover1 .bp5-adobesystemslogoandwordmark1 .bp5-g41511 .bp5-polygon191 {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 27.36%;
                                bottom              : 0px;
                                height              : 62.77%;
                                width               : 39.62%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card4-Ma7o .bp5-card1hover .bp5-card1hover1 .bp5-maskcopy {
                                background-color    : rgba(0, 0, 0, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 3px;
                                transform           : rotate(0deg);
                                opacity             : 0.77;
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card4-Ma7o .bp5-card1hover .bp5-card1hover1 .bp5-group2 {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 33.17%;
                                height              : 32.21%;
                                width               : 54.40%;
                                position            : absolute;
                                margin              : 0;
                                left                : 22.80%;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card4-Ma7o .bp5-card1hover .bp5-card1hover1 .bp5-group2 .bp5-sslrpfooddeals {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 1.49%;
                                height              : 42px;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Bold", Helvetica, Arial, serif;
                                font-size           : 21.17px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : center;
                                letter-spacing      : 0.41px;
                                line-height         : 26.0px;
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card4-Ma7o .bp5-card1hover .bp5-card1hover1 .bp5-group2 .bp5-productdesign {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 1.49%;
                                height              : 12px;
                                width               : 54.91%;
                                position            : absolute;
                                margin              : 0;
                                left                : 21.97%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 11.29px;
                                color               : rgba(201, 201, 201, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.22px;
                                line-height         : 14.0px;
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card4-Ma7o .bp5-card1hover .bp5-bluebox {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card4-Ma7o .bp5-card1hover .bp5-bluebox .bp5-pixels {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 0px;
                                height              : 6.78%;
                                width               : 20.18%;
                                position            : absolute;
                                margin              : 0;
                                left                : 39.91%;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card4-Ma7o .bp5-card1hover .bp5-bluebox .bp5-pixels .bp5-rectangle1 {
                                background-color    : rgba(59, 172, 247, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 98.48%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.76%;
                                border-radius       : 1px;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card4-Ma7o .bp5-card1hover .bp5-bluebox .bp5-pixels .bp5-a665x429 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 4px);
                                height              : 7px;
                                width               : 65.15%;
                                position            : absolute;
                                margin              : 0;
                                left                : 17.42%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 7.06px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : center;
                                letter-spacing      : 0.14px;
                                line-height         : 9.0px;
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card4-Ma7o .bp5-card1hover .bp5-bluebox .bp5-outline {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 91.95%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card4-Ma7o .bp5-card1hover .bp5-bluebox .bp5-outline .bp5-rectangle2 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 1.38%;
                                height              : 97.24%;
                                box-sizing          : border-box;
                                width               : 97.86%;
                                position            : absolute;
                                margin              : 0;
                                left                : 1.07%;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card4-Ma7o .bp5-card1hover .bp5-bluebox .bp5-outline .bp5-rectangle3 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                top                 : 0.46%;
                                height              : 3.23%;
                                box-sizing          : border-box;
                                width               : 2.45%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.31%;
                                border-style        : solid;
                                border-width        : 0px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card4-Ma7o .bp5-card1hover .bp5-bluebox .bp5-outline .bp5-rectanglecopy2 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                bottom              : 0px;
                                height              : 3.23%;
                                box-sizing          : border-box;
                                width               : 2.45%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-style        : solid;
                                border-width        : 0px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card4-Ma7o .bp5-card1hover .bp5-bluebox .bp5-outline .bp5-rectanglecopy3 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                right               : 0px;
                                bottom              : 0px;
                                height              : 3.23%;
                                box-sizing          : border-box;
                                width               : 2.14%;
                                position            : absolute;
                                margin              : 0;
                                border-style        : solid;
                                border-width        : 0px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card4-Ma7o .bp5-card1hover .bp5-bluebox .bp5-outline .bp5-rectanglecopy4 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                right               : 0px;
                                top                 : 0px;
                                height              : 3.23%;
                                box-sizing          : border-box;
                                width               : 2.14%;
                                position            : absolute;
                                margin              : 0;
                                border-style        : solid;
                                border-width        : 0px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                        </style>
                        <div id="qhyGNO7">
                            <a href="adobe.html">
                                <div class="bp5-card4 bp5-card4-Ma7o component anima-component-wrapper anima-not-ready anima-word-break anima-smart-layers-pointers state1" data-initial-state="state1">
                                    <div class="bp5-card11">
                                        <div class="bp5-mask">
                                        </div>
                                        <div class="bp5-adobesystemslogoandwordmark">
                                            <div class="bp5-g4151">
                                                <img alt="Image" class="bp5-polygon15" src="./img/ipad-home-polygon15@2x.png"/>
                                                <img alt="Image" class="bp5-polygon17" src="./img/ipad-home-polygon17-1@2x.png"/>
                                                <img alt="Image" class="bp5-polygon19" src="./img/ipad-home-polygon19@2x.png"/>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="bp5-card1hover anima-hidden ">
                                        <div class="bp5-card1hover1">
                                            <div class="bp5-mask1">
                                            </div>
                                            <div class="bp5-mask2">
                                            </div>
                                            <div class="bp5-adobesystemslogoandwordmark1">
                                                <div class="bp5-g41511">
                                                    <img alt="Image" class="bp5-polygon151" src="./img/ipad-home-polygon15@2x.png"/>
                                                    <img alt="Image" class="bp5-polygon171" src="./img/ipad-home-polygon17-1@2x.png"/>
                                                    <img alt="Image" class="bp5-polygon191" src="./img/ipad-home-polygon19@2x.png"/>
                                                </div>
                                            </div>
                                            <div class="bp5-maskcopy">
                                            </div>
                                            <div class="bp5-group2">
                                                <div class="bp5-sslrpfooddeals">
                                                    Adobe x The Ocean Agency
                                                </div>
                                                <div class="bp5-productdesign">
                                                    Product Design
                                                </div>
                                            </div>
                                        </div>
                                        <div class="bp5-bluebox">
                                            <div class="bp5-pixels">
                                                <div class="bp5-rectangle1">
                                                </div>
                                                <div class="bp5-a665x429">
                                                    APR x 2020
                                                </div>
                                            </div>
                                            <div class="bp5-outline">
                                                <div class="bp5-rectangle2">
                                                </div>
                                                <div class="bp5-rectangle3">
                                                </div>
                                                <div class="bp5-rectanglecopy2">
                                                </div>
                                                <div class="bp5-rectanglecopy3">
                                                </div>
                                                <div class="bp5-rectanglecopy4">
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </a>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card4-Ma7o", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp5-card1hover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp5-card1hover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp5-card1hover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                        <style>
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card3-k8dx * {
                                box-sizing          : border-box;
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card3-k8dx {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 406px;
                                height              : 236px;
                                width               : 332px;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                                transition          : all 0.2s ease-in-out;
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card3-k8dx .bp5-card11 {
                                background-color    : rgba(97, 0, 238, 1.0);
                                top                 : 2.54%;
                                height              : 88.14%;
                                width               : 95.78%;
                                position            : absolute;
                                margin              : 0;
                                left                : 2.11%;
                                border-radius       : 3px;
                                overflow            : hidden;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card3-k8dx .bp5-card11 .bp5-mask {
                                background-color    : rgba(97, 0, 238, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 3px;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card3-k8dx .bp5-card11 .bp5-rectangle {
                                background-color    : rgba(98, 0, 238, 1.0);
                                top                 : -0.24%;
                                height              : 100.48%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card3-k8dx .bp5-card11 .bp5-swift {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 14px;
                                height              : 182px;
                                width               : 285px;
                                position            : absolute;
                                margin              : 0;
                                left                : 17px;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card3-k8dx .bp5-card1hover {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : -0.42%;
                                height              : 100%;
                                width               : 98.19%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.90%;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card3-k8dx .bp5-card1hover .bp5-card1hover1 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 1.69%;
                                height              : 88.56%;
                                width               : 97.55%;
                                position            : absolute;
                                margin              : 0;
                                left                : 1.23%;
                                border-radius       : 3px;
                                overflow            : hidden;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card3-k8dx .bp5-card1hover .bp5-card1hover1 .bp5-mask1 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 0.24%;
                                height              : 99.52%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 3px;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card3-k8dx .bp5-card1hover .bp5-card1hover1 .bp5-rectangle {
                                background-color    : rgba(97, 0, 238, 1.0);
                                top                 : -0.24%;
                                height              : 100.48%;
                                box-sizing          : border-box;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-style        : solid;
                                border-width        : 0px;
                                border-color        : rgba(150, 150, 150, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card3-k8dx .bp5-card1hover .bp5-card1hover1 .bp5-swift {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 13.52%;
                                bottom              : 13.88%;
                                height              : 70.33%;
                                width               : 72.01%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card3-k8dx .bp5-card1hover .bp5-card1hover1 .bp5-swift .bp5-swift1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card3-k8dx .bp5-card1hover .bp5-card1hover1 .bp5-mask {
                                background-color    : rgba(0, 0, 0, 1.0);
                                top                 : 0.24%;
                                height              : 99.52%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 3px;
                                transform           : rotate(0deg);
                                opacity             : 0.77;
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card3-k8dx .bp5-card1hover .bp5-card1hover1 .bp5-group3 {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 27.36%;
                                top                 : 40.43%;
                                height              : 19.14%;
                                width               : 44.65%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card3-k8dx .bp5-card1hover .bp5-card1hover1 .bp5-group3 .bp5-sslrpfooddeals {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 2.50%;
                                height              : 21px;
                                width               : 99.30%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.35%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Bold", Helvetica, Arial, serif;
                                font-size           : 21.17px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.41px;
                                line-height         : 26.0px;
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card3-k8dx .bp5-card1hover .bp5-card1hover1 .bp5-group3 .bp5-productdesign {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 0px;
                                height              : 12px;
                                width               : 65.49%;
                                position            : absolute;
                                margin              : 0;
                                left                : 17.25%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 11.29px;
                                color               : rgba(201, 201, 201, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.22px;
                                line-height         : 14.0px;
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card3-k8dx .bp5-card1hover .bp5-bluebox {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card3-k8dx .bp5-card1hover .bp5-bluebox .bp5-pixels {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 0px;
                                height              : 6.78%;
                                width               : 20.25%;
                                position            : absolute;
                                margin              : 0;
                                left                : 39.88%;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card3-k8dx .bp5-card1hover .bp5-bluebox .bp5-pixels .bp5-rectangle1 {
                                background-color    : rgba(59, 172, 247, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 98.48%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.76%;
                                border-radius       : 1px;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card3-k8dx .bp5-card1hover .bp5-bluebox .bp5-pixels .bp5-a665x429 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 4px);
                                height              : 7px;
                                width               : 68.18%;
                                position            : absolute;
                                margin              : 0;
                                left                : 15.91%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 7.06px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : center;
                                letter-spacing      : 0.14px;
                                line-height         : 9.0px;
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card3-k8dx .bp5-card1hover .bp5-bluebox .bp5-outline {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 91.95%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card3-k8dx .bp5-card1hover .bp5-bluebox .bp5-outline .bp5-rectangle2 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 1.38%;
                                height              : 97.24%;
                                box-sizing          : border-box;
                                width               : 98.16%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.92%;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card3-k8dx .bp5-card1hover .bp5-bluebox .bp5-outline .bp5-rectangle3 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                top                 : 0.46%;
                                height              : 3.23%;
                                box-sizing          : border-box;
                                width               : 2.45%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-style        : solid;
                                border-width        : 0px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card3-k8dx .bp5-card1hover .bp5-bluebox .bp5-outline .bp5-rectanglecopy2 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                bottom              : 0px;
                                height              : 3.23%;
                                box-sizing          : border-box;
                                width               : 2.15%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-style        : solid;
                                border-width        : 0px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card3-k8dx .bp5-card1hover .bp5-bluebox .bp5-outline .bp5-rectanglecopy3 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                right               : 0px;
                                bottom              : 0px;
                                height              : 3.23%;
                                box-sizing          : border-box;
                                width               : 2.15%;
                                position            : absolute;
                                margin              : 0;
                                border-style        : solid;
                                border-width        : 0px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card3-k8dx .bp5-card1hover .bp5-bluebox .bp5-outline .bp5-rectanglecopy4 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                right               : 0px;
                                top                 : 0px;
                                height              : 3.23%;
                                box-sizing          : border-box;
                                width               : 2.15%;
                                position            : absolute;
                                margin              : 0;
                                border-style        : solid;
                                border-width        : 0px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                        </style>
                        <div id="IJ1wFWC">
                            <a href="swiftrides.html">
                                <div class="bp5-card3 bp5-card3-k8dx component anima-component-wrapper anima-not-ready anima-word-break anima-smart-layers-pointers state1" data-initial-state="state1">
                                    <div class="bp5-card11">
                                        <div class="bp5-mask">
                                        </div>
                                        <div class="bp5-rectangle">
                                        </div>
                                        <img alt="Image" class="bp5-swift" src="./img/ipad-home-swift@2x.png"/>
                                    </div>
                                    <div class="bp5-card1hover anima-hidden ">
                                        <div class="bp5-card1hover1">
                                            <div class="bp5-mask1">
                                            </div>
                                            <div class="bp5-rectangle">
                                            </div>
                                            <div class="bp5-swift">
                                                <img alt="Image" class="bp5-swift1" src="./img/ipad-home-swift-1@2x.png"/>
                                            </div>
                                            <div class="bp5-mask">
                                            </div>
                                            <div class="bp5-group3">
                                                <div class="bp5-sslrpfooddeals">
                                                    SWIFT Rides
                                                </div>
                                                <div class="bp5-productdesign">
                                                    Product Design
                                                </div>
                                            </div>
                                        </div>
                                        <div class="bp5-bluebox">
                                            <div class="bp5-pixels">
                                                <div class="bp5-rectangle1">
                                                </div>
                                                <div class="bp5-a665x429">
                                                    JUNE x 2017
                                                </div>
                                            </div>
                                            <div class="bp5-outline">
                                                <div class="bp5-rectangle2">
                                                </div>
                                                <div class="bp5-rectangle3">
                                                </div>
                                                <div class="bp5-rectanglecopy2">
                                                </div>
                                                <div class="bp5-rectanglecopy3">
                                                </div>
                                                <div class="bp5-rectanglecopy4">
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </a>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card3-k8dx", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp5-card1hover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp5-card1hover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp5-card1hover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                        <style>
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card2-AaVf * {
                                box-sizing          : border-box;
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card2-AaVf {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 157px;
                                height              : 236px;
                                width               : 332px;
                                position            : absolute;
                                margin              : 0;
                                left                : 346px;
                                transform           : rotate(0deg);
                                transition          : all 0.2s ease-in-out;
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card2-AaVf .bp5-card11 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 2.97%;
                                height              : 88.14%;
                                width               : 95.78%;
                                position            : absolute;
                                margin              : 0;
                                left                : 2.11%;
                                border-radius       : 3px;
                                overflow            : hidden;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card2-AaVf .bp5-card11 .bp5-mask {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 3px;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card2-AaVf .bp5-card11 .bp5-screenshot20200423at83825pm {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : -24px;
                                height              : 239px;
                                width               : 449px;
                                position            : absolute;
                                margin              : 0;
                                left                : -66px;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card2-AaVf .bp5-card1hover {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : -0.85%;
                                height              : 100%;
                                width               : 98.49%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.75%;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card2-AaVf .bp5-card1hover .bp5-card1hover1 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 2.12%;
                                height              : 88.14%;
                                width               : 97.25%;
                                position            : absolute;
                                margin              : 0;
                                left                : 1.38%;
                                border-radius       : 3px;
                                overflow            : hidden;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card2-AaVf .bp5-card1hover .bp5-card1hover1 .bp5-mask1 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 3px;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card2-AaVf .bp5-card1hover .bp5-card1hover1 .bp5-screenshot20200423at83825pm {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : -24px;
                                height              : 239px;
                                width               : 449px;
                                position            : absolute;
                                margin              : 0;
                                left                : -66px;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card2-AaVf .bp5-card1hover .bp5-card1hover1 .bp5-mask {
                                background-color    : rgba(0, 0, 0, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 3px;
                                transform           : rotate(0deg);
                                opacity             : 0.77;
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card2-AaVf .bp5-card1hover .bp5-card1hover1 .bp5-sslrpfooddeals {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 40.87%;
                                height              : 21px;
                                width               : 37.11%;
                                position            : absolute;
                                margin              : 0;
                                left                : 31.45%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Bold", Helvetica, Arial, serif;
                                font-size           : 21.17px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.41px;
                                line-height         : 26.0px;
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card2-AaVf .bp5-card1hover .bp5-card1hover1 .bp5-productdesign {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 40.38%;
                                height              : 12px;
                                width               : 29.87%;
                                position            : absolute;
                                margin              : 0;
                                left                : 35.06%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 11.29px;
                                color               : rgba(201, 201, 201, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.22px;
                                line-height         : 14.0px;
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card2-AaVf .bp5-card1hover .bp5-bluebox {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card2-AaVf .bp5-card1hover .bp5-bluebox .bp5-pixels {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 0px;
                                height              : 6.78%;
                                width               : 20.18%;
                                position            : absolute;
                                margin              : 0;
                                left                : 39.91%;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card2-AaVf .bp5-card1hover .bp5-bluebox .bp5-pixels .bp5-rectangle1 {
                                background-color    : rgba(59, 172, 247, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 98.48%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.76%;
                                border-radius       : 1px;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card2-AaVf .bp5-card1hover .bp5-bluebox .bp5-pixels .bp5-a665x429 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 4px);
                                height              : 7px;
                                width               : 51.52%;
                                position            : absolute;
                                margin              : 0;
                                left                : 24.24%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 7.06px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : center;
                                letter-spacing      : 0.14px;
                                line-height         : 9.0px;
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card2-AaVf .bp5-card1hover .bp5-bluebox .bp5-outline {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 91.95%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card2-AaVf .bp5-card1hover .bp5-bluebox .bp5-outline .bp5-rectangle2 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 1.38%;
                                height              : 97.24%;
                                box-sizing          : border-box;
                                width               : 97.86%;
                                position            : absolute;
                                margin              : 0;
                                left                : 1.07%;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card2-AaVf .bp5-card1hover .bp5-bluebox .bp5-outline .bp5-rectangle3 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                top                 : 0.46%;
                                height              : 3.23%;
                                box-sizing          : border-box;
                                width               : 2.45%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.31%;
                                border-style        : solid;
                                border-width        : 0px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card2-AaVf .bp5-card1hover .bp5-bluebox .bp5-outline .bp5-rectanglecopy2 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                bottom              : 0px;
                                height              : 3.23%;
                                box-sizing          : border-box;
                                width               : 2.45%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-style        : solid;
                                border-width        : 0px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card2-AaVf .bp5-card1hover .bp5-bluebox .bp5-outline .bp5-rectanglecopy3 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                right               : 0px;
                                bottom              : 0px;
                                height              : 3.23%;
                                box-sizing          : border-box;
                                width               : 2.14%;
                                position            : absolute;
                                margin              : 0;
                                border-style        : solid;
                                border-width        : 0px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card2-AaVf .bp5-card1hover .bp5-bluebox .bp5-outline .bp5-rectanglecopy4 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                right               : 0px;
                                top                 : 0px;
                                height              : 3.23%;
                                box-sizing          : border-box;
                                width               : 2.14%;
                                position            : absolute;
                                margin              : 0;
                                border-style        : solid;
                                border-width        : 0px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                        </style>
                        <div id="KupEdwB">
                            <a href="designco.html">
                                <div class="bp5-card2 bp5-card2-AaVf component anima-component-wrapper anima-not-ready anima-word-break anima-smart-layers-pointers state1" data-initial-state="state1">
                                    <div class="bp5-card11">
                                        <div class="bp5-mask">
                                        </div>
                                        <img alt="Image" class="bp5-screenshot20200423at83825pm" src="./img/ipad-home-screen-shot-2020-04-23-at-83825-pm-1.png"/>
                                    </div>
                                    <div class="bp5-card1hover anima-hidden ">
                                        <div class="bp5-card1hover1">
                                            <div class="bp5-mask1">
                                            </div>
                                            <img alt="Image" class="bp5-screenshot20200423at83825pm" src="./img/ipad-home-screen-shot-2020-04-23-at-83825-pm-1.png"/>
                                            <div class="bp5-mask">
                                            </div>
                                            <div class="bp5-sslrpfooddeals">
                                                Design Co
                                            </div>
                                            <div class="bp5-productdesign">
                                                Student Leader
                                            </div>
                                        </div>
                                        <div class="bp5-bluebox">
                                            <div class="bp5-pixels">
                                                <div class="bp5-rectangle1">
                                                </div>
                                                <div class="bp5-a665x429">
                                                    PRESENT
                                                </div>
                                            </div>
                                            <div class="bp5-outline">
                                                <div class="bp5-rectangle2">
                                                </div>
                                                <div class="bp5-rectangle3">
                                                </div>
                                                <div class="bp5-rectanglecopy2">
                                                </div>
                                                <div class="bp5-rectanglecopy3">
                                                </div>
                                                <div class="bp5-rectanglecopy4">
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </a>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card2-AaVf", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp5-card1hover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp5-card1hover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp5-card1hover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                        <style>
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card1-9S5L * {
                                box-sizing          : border-box;
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card1-9S5L {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 158px;
                                height              : 236px;
                                width               : 332px;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                                transition          : all 0.2s ease-in-out;
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card1-9S5L .bp5-card11 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 2.54%;
                                height              : 88.14%;
                                width               : 95.78%;
                                position            : absolute;
                                margin              : 0;
                                left                : 2.11%;
                                border-radius       : 3px;
                                overflow            : hidden;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card1-9S5L .bp5-card11 .bp5-mask {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 3px;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card1-9S5L .bp5-card11 .bp5-rotatosnapshot {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 208px;
                                width               : 370px;
                                position            : absolute;
                                margin              : 0;
                                left                : -26px;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card1-9S5L .bp5-card1hover {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : -0.42%;
                                height              : 100%;
                                width               : 98.19%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.90%;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card1-9S5L .bp5-card1hover .bp5-card1hover1 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 2.12%;
                                height              : 88.14%;
                                width               : 97.55%;
                                position            : absolute;
                                margin              : 0;
                                left                : 1.23%;
                                border-radius       : 3px;
                                overflow            : hidden;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card1-9S5L .bp5-card1hover .bp5-card1hover1 .bp5-mask1 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 3px;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card1-9S5L .bp5-card1hover .bp5-card1hover1 .bp5-rotatosnapshot1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 208px;
                                width               : 370px;
                                position            : absolute;
                                margin              : 0;
                                left                : -26px;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card1-9S5L .bp5-card1hover .bp5-card1hover1 .bp5-mask {
                                background-color    : rgba(0, 0, 0, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 3px;
                                transform           : rotate(0deg);
                                opacity             : 0.77;
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card1-9S5L .bp5-card1hover .bp5-card1hover1 .bp5-sslrpfooddeals {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 40.87%;
                                height              : 21px;
                                width               : 44.65%;
                                position            : absolute;
                                margin              : 0;
                                left                : 27.67%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Bold", Helvetica, Arial, serif;
                                font-size           : 21.17px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.41px;
                                line-height         : 26.0px;
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card1-9S5L .bp5-card1hover .bp5-card1hover1 .bp5-productdesign {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 40.38%;
                                height              : 12px;
                                width               : 29.87%;
                                position            : absolute;
                                margin              : 0;
                                left                : 35.06%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 11.29px;
                                color               : rgba(201, 201, 201, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.22px;
                                line-height         : 14.0px;
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card1-9S5L .bp5-card1hover .bp5-bluebox {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card1-9S5L .bp5-card1hover .bp5-bluebox .bp5-pixels {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 0px;
                                height              : 6.78%;
                                width               : 20.25%;
                                position            : absolute;
                                margin              : 0;
                                left                : 39.88%;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card1-9S5L .bp5-card1hover .bp5-bluebox .bp5-pixels .bp5-rectangle1 {
                                background-color    : rgba(59, 172, 247, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 98.48%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.76%;
                                border-radius       : 1px;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card1-9S5L .bp5-card1hover .bp5-bluebox .bp5-pixels .bp5-a665x429 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 4px);
                                height              : 7px;
                                width               : 59.09%;
                                position            : absolute;
                                margin              : 0;
                                left                : 20.45%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 7.06px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : center;
                                letter-spacing      : 0.14px;
                                line-height         : 9.0px;
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card1-9S5L .bp5-card1hover .bp5-bluebox .bp5-outline {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 91.95%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card1-9S5L .bp5-card1hover .bp5-bluebox .bp5-outline .bp5-rectangle2 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 1.38%;
                                height              : 97.24%;
                                box-sizing          : border-box;
                                width               : 98.16%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.92%;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card1-9S5L .bp5-card1hover .bp5-bluebox .bp5-outline .bp5-rectangle3 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                top                 : 0.46%;
                                height              : 3.23%;
                                box-sizing          : border-box;
                                width               : 2.45%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-style        : solid;
                                border-width        : 0px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card1-9S5L .bp5-card1hover .bp5-bluebox .bp5-outline .bp5-rectanglecopy2 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                bottom              : 0px;
                                height              : 3.23%;
                                box-sizing          : border-box;
                                width               : 2.15%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-style        : solid;
                                border-width        : 0px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card1-9S5L .bp5-card1hover .bp5-bluebox .bp5-outline .bp5-rectanglecopy3 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                right               : 0px;
                                bottom              : 0px;
                                height              : 3.23%;
                                box-sizing          : border-box;
                                width               : 2.15%;
                                position            : absolute;
                                margin              : 0;
                                border-style        : solid;
                                border-width        : 0px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card1-9S5L .bp5-card1hover .bp5-bluebox .bp5-outline .bp5-rectanglecopy4 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                right               : 0px;
                                top                 : 0px;
                                height              : 3.23%;
                                box-sizing          : border-box;
                                width               : 2.15%;
                                position            : absolute;
                                margin              : 0;
                                border-style        : solid;
                                border-width        : 0px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                        </style>
                        <div id="lR5QE0u">
                            <a href="sslrpdeals.html">
                                <div class="bp5-card1 bp5-card1-9S5L component anima-component-wrapper anima-not-ready anima-word-break anima-smart-layers-pointers state1" data-initial-state="state1">
                                    <div class="bp5-card11">
                                        <div class="bp5-mask">
                                        </div>
                                        <img alt="Image" class="bp5-rotatosnapshot" src="./img/ipad-home-rotato-snapshot-1.png"/>
                                    </div>
                                    <div class="bp5-card1hover anima-hidden ">
                                        <div class="bp5-card1hover1">
                                            <div class="bp5-mask1">
                                            </div>
                                            <img alt="Image" class="bp5-rotatosnapshot1" src="./img/ipad-home-rotato-snapshot-1.png"/>
                                            <div class="bp5-mask">
                                            </div>
                                            <div class="bp5-sslrpfooddeals">
                                                SSLRP Deals
                                            </div>
                                            <div class="bp5-productdesign">
                                                Product Design
                                            </div>
                                        </div>
                                        <div class="bp5-bluebox">
                                            <div class="bp5-pixels">
                                                <div class="bp5-rectangle1">
                                                </div>
                                                <div class="bp5-a665x429">
                                                    FEB x 2019
                                                </div>
                                            </div>
                                            <div class="bp5-outline">
                                                <div class="bp5-rectangle2">
                                                </div>
                                                <div class="bp5-rectangle3">
                                                </div>
                                                <div class="bp5-rectanglecopy2">
                                                </div>
                                                <div class="bp5-rectanglecopy3">
                                                </div>
                                                <div class="bp5-rectanglecopy4">
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </a>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp5-ipadhome .bp5-sectionwork .bp5-workcontent .bp5-card1-9S5L", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp5-card1hover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp5-card1hover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp5-card1hover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                        <div class="bp5-text">
                            <div anima-show-on-scroll="" class="bp5-h2">
                                Crafted with intention. Bringing all attention.
                            </div>
                            <div anima-show-on-scroll="" class="bp5-h1">
                                Embarking on a Journey through Pixels.
                            </div>
                            <div anima-show-on-scroll="" class="bp5-h3">
                                WORK
                            </div>
                        </div>
                    </div>
                </div>
                <div class="bp5-sectionfooter">
                    <img alt="Image" anima-src="./img/ipad-swiftrides-bg.png" class="bp5-bg" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                    <div class="bp5-footer">
                        <div class="bp5-socialicons">
                            <style>
                                .bp5-ipadhome .bp5-sectionfooter .bp5-footer .bp5-socialicons .bp5-dribbble-JdPB * {
                                    box-sizing          : border-box;
                                }
                                .bp5-ipadhome .bp5-sectionfooter .bp5-footer .bp5-socialicons .bp5-dribbble-JdPB {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 24px;
                                    width               : 24px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 48px;
                                    transform           : rotate(0deg);
                                }
                                .bp5-ipadhome .bp5-sectionfooter .bp5-footer .bp5-socialicons .bp5-dribbble-JdPB .bp5-shape {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .bp5-ipadhome .bp5-sectionfooter .bp5-footer .bp5-socialicons .bp5-dribbble-JdPB .bp5-shapehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                }
                            </style>
                            <div id="OJ11XM5">
                                <a href="https://dribbble.com/syedadam007" target="_blank">
                                    <div class="bp5-dribbble bp5-dribbble-JdPB component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <img alt="Image" class="bp5-shape" src="./img/ipad-adobe-shape-3@2x.png"/>
                                        <img alt="Image" class="bp5-shapehover anima-hidden " src="./img/ipad-sslrpdeals-shapehover@2x.png"/>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp5-ipadhome .bp5-sectionfooter .bp5-footer .bp5-socialicons .bp5-dribbble-JdPB", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp5-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp5-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp5-shapehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <style>
                                .bp5-ipadhome .bp5-sectionfooter .bp5-footer .bp5-socialicons .bp5-linkedin-x7cn * {
                                    box-sizing          : border-box;
                                }
                                .bp5-ipadhome .bp5-sectionfooter .bp5-footer .bp5-socialicons .bp5-linkedin-x7cn {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 24px;
                                    width               : 24px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .bp5-ipadhome .bp5-sectionfooter .bp5-footer .bp5-socialicons .bp5-linkedin-x7cn .bp5-shape {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .bp5-ipadhome .bp5-sectionfooter .bp5-footer .bp5-socialicons .bp5-linkedin-x7cn .bp5-shapehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                }
                            </style>
                            <div id="sfhes13">
                                <a href="https://www.linkedin.com/in/syedadamemirputra/" target="_blank">
                                    <div class="bp5-linkedin bp5-linkedin-x7cn component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <img alt="Image" class="bp5-shape" src="./img/ipad-swiftrides-shape-4@2x.png"/>
                                        <img alt="Image" class="bp5-shapehover anima-hidden " src="./img/ipad-about-shapehover-1@2x.png"/>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp5-ipadhome .bp5-sectionfooter .bp5-footer .bp5-socialicons .bp5-linkedin-x7cn", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp5-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp5-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp5-shapehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <style>
                                .bp5-ipadhome .bp5-sectionfooter .bp5-footer .bp5-socialicons .bp5-instagram-7g1r * {
                                    box-sizing          : border-box;
                                }
                                .bp5-ipadhome .bp5-sectionfooter .bp5-footer .bp5-socialicons .bp5-instagram-7g1r {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 24px;
                                    width               : 24px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 95px;
                                    transform           : rotate(0deg);
                                }
                                .bp5-ipadhome .bp5-sectionfooter .bp5-footer .bp5-socialicons .bp5-instagram-7g1r .bp5-shape {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 2.08%;
                                    height              : 95.83%;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .bp5-ipadhome .bp5-sectionfooter .bp5-footer .bp5-socialicons .bp5-instagram-7g1r .bp5-shapehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 2.08%;
                                    height              : 95.83%;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                }
                            </style>
                            <div id="QGSBnAm">
                                <a href="https://www.instagram.com/syedadam007/" target="_blank">
                                    <div class="bp5-instagram bp5-instagram-7g1r component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <img alt="Image" class="bp5-shape" src="./img/ipad-adobe-shape-5@2x.png"/>
                                        <img alt="Image" class="bp5-shapehover anima-hidden " src="./img/ipad-adobe-shapehover-2@2x.png"/>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp5-ipadhome .bp5-sectionfooter .bp5-footer .bp5-socialicons .bp5-instagram-7g1r", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp5-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp5-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp5-shapehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                        </div>
                        <div anima-show-on-scroll="" class="bp5-h3">
                            Â© 2020 Lil Adam X
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="bp6-iphonexhome anima-word-break ">
            <div style="width: 375px; height: 100%; position:relative; margin:auto;">
                <div class="bp6-sectionhero" id="None">
                    <div class="bp6-darkbg">
                    </div>
                    <div class="bp6-content">
                        <div anima-show-on-scroll="" class="bp6-mission">
                            Adam designs because the world ainâ€™t right. Demystifying the ways the world should be.
                        </div>
                        <div class="bp6-present">
                            Present
                        </div>
                        <style>
                            .bp6-iphonexhome .bp6-sectionhero .bp6-content .bp6-designco-rrKq * {
                                box-sizing          : border-box;
                            }
                            .bp6-iphonexhome .bp6-sectionhero .bp6-content .bp6-designco-rrKq {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 211px;
                                height              : 14px;
                                width               : 67px;
                                position            : absolute;
                                margin              : 0;
                                left                : 1px;
                                transform           : rotate(0deg);
                            }
                            .bp6-iphonexhome .bp6-sectionhero .bp6-content .bp6-designco-rrKq .bp6-designco1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 7px);
                                height              : 13px;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 12.9px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.25px;
                                line-height         : 16.0px;
                            }
                            .bp6-iphonexhome .bp6-sectionhero .bp6-content .bp6-designco-rrKq .bp6-designcohover {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 7px);
                                height              : 13px;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 12.9px;
                                color               : rgba(146, 146, 146, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.25px;
                                line-height         : 16.0px;
                            }
                        </style>
                        <div id="GjAKSgX">
                            <div class="bp6-designco bp6-designco-rrKq component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                <a href="http://www.ucsddesign.co/" target="_blank">
                                    <div class="bp6-designco1">
                                        Design Co
                                    </div>
                                </a>
                                <a href="http://www.ucsddesign.co/" target="_blank">
                                    <div class="bp6-designcohover anima-hidden ">
                                        Design Co
                                    </div>
                                </a>
                            </div>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp6-iphonexhome .bp6-sectionhero .bp6-content .bp6-designco-rrKq", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp6-designcohover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp6-designcohover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp6-designcohover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                        <div class="bp6-education">
                            Education
                        </div>
                        <style>
                            .bp6-iphonexhome .bp6-sectionhero .bp6-content .bp6-ucsd-WgF6 * {
                                box-sizing          : border-box;
                            }
                            .bp6-iphonexhome .bp6-sectionhero .bp6-content .bp6-ucsd-WgF6 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 284px;
                                height              : 14px;
                                width               : 92px;
                                position            : absolute;
                                margin              : 0;
                                left                : 1px;
                                transform           : rotate(0deg);
                            }
                            .bp6-iphonexhome .bp6-sectionhero .bp6-content .bp6-ucsd-WgF6 .bp6-ucsd1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 7px);
                                height              : 13px;
                                width               : 98.91%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.54%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 12.9px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.25px;
                                line-height         : 16.0px;
                            }
                            .bp6-iphonexhome .bp6-sectionhero .bp6-content .bp6-ucsd-WgF6 .bp6-ucsdhover {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 7px);
                                height              : 13px;
                                width               : 98.91%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.54%;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 12.9px;
                                color               : rgba(146, 146, 146, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.25px;
                                line-height         : 16.0px;
                            }
                        </style>
                        <div id="xQ2qPp4">
                            <div class="bp6-ucsd bp6-ucsd-WgF6 component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                <a href="https://ucsd.edu/" target="_blank">
                                    <div class="bp6-ucsd1">
                                        UC San Diego
                                    </div>
                                </a>
                                <a href="https://ucsd.edu/" target="_blank">
                                    <div class="bp6-ucsdhover anima-hidden ">
                                        UC San Diego
                                    </div>
                                </a>
                            </div>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp6-iphonexhome .bp6-sectionhero .bp6-content .bp6-ucsd-WgF6", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp6-ucsdhover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp6-ucsdhover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp6-ucsdhover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                        <div class="bp6-previous">
                            Previous
                        </div>
                        <style>
                            .bp6-iphonexhome .bp6-sectionhero .bp6-content .bp6-longstorystudios-5jLb * {
                                box-sizing          : border-box;
                            }
                            .bp6-iphonexhome .bp6-sectionhero .bp6-content .bp6-longstorystudios-5jLb {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 206px;
                                height              : 35px;
                                width               : 108px;
                                position            : absolute;
                                margin              : 0;
                                left                : 178px;
                                transform           : rotate(0deg);
                            }
                            .bp6-iphonexhome .bp6-sectionhero .bp6-content .bp6-longstorystudios-5jLb .bp6-ls {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 17px);
                                height              : 34px;
                                width               : 65.74%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 12.9px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.25px;
                                line-height         : 17.0px;
                            }
                            .bp6-iphonexhome .bp6-sectionhero .bp6-content .bp6-longstorystudios-5jLb .bp6-lshover {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 0.93%;
                                top                 : calc(50.00% - 13px);
                                height              : 26px;
                                width               : 65.74%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 12.9px;
                                color               : rgba(146, 146, 146, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.25px;
                                line-height         : 16.0px;
                            }
                        </style>
                        <div id="UoN2uxS">
                            <div class="bp6-longstorystudios bp6-longstorystudios-5jLb component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                <a href="https://www.longstorystudios.com/" target="_blank">
                                    <div class="bp6-ls">
                                        Long Story Studios
                                    </div>
                                </a>
                                <a href="https://www.longstorystudios.com/" target="_blank">
                                    <div class="bp6-lshover anima-hidden ">
                                        Long Story Studios
                                    </div>
                                </a>
                            </div>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp6-iphonexhome .bp6-sectionhero .bp6-content .bp6-longstorystudios-5jLb", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp6-lshover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp6-lshover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp6-lshover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                    </div>
                    <div class="bp6-group3">
                        <div class="bp6-navbar">
                        </div>
                        <div class="bp6-rectangle">
                        </div>
                        <style>
                            .bp6-iphonexhome .bp6-sectionhero .bp6-group3 .bp6-logo-5YjI * {
                                box-sizing          : border-box;
                            }
                            .bp6-iphonexhome .bp6-sectionhero .bp6-group3 .bp6-logo-5YjI {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 33px;
                                height              : 19px;
                                width               : 110px;
                                position            : absolute;
                                margin              : 0;
                                left                : 38px;
                                transform           : rotate(0deg);
                            }
                            .bp6-iphonexhome .bp6-sectionhero .bp6-group3 .bp6-logo-5YjI .bp6-adamoutline {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 99.09%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.45%;
                                transform           : rotate(0deg);
                            }
                            .bp6-iphonexhome .bp6-sectionhero .bp6-group3 .bp6-logo-5YjI .bp6-adamoutline .bp6-shape1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 2.63%;
                                height              : 94.74%;
                                width               : 82.57%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.92%;
                                transform           : rotate(0deg);
                            }
                            .bp6-iphonexhome .bp6-sectionhero .bp6-group3 .bp6-logo-5YjI .bp6-adamoutline .bp6-path {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 0px;
                                top                 : 18.42%;
                                height              : 63.16%;
                                width               : 11.01%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                            .bp6-iphonexhome .bp6-sectionhero .bp6-group3 .bp6-logo-5YjI .bp6-adamfill {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 2.63%;
                                height              : 94.74%;
                                width               : 97.27%;
                                position            : absolute;
                                margin              : 0;
                                left                : 1.36%;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                            }
                            .bp6-iphonexhome .bp6-sectionhero .bp6-group3 .bp6-logo-5YjI .bp6-adamfill .bp6-shape1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 82.24%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.93%;
                                transform           : rotate(0deg);
                            }
                            .bp6-iphonexhome .bp6-sectionhero .bp6-group3 .bp6-logo-5YjI .bp6-adamfill .bp6-path1 {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 0px;
                                top                 : 13.89%;
                                height              : 72.22%;
                                width               : 11.21%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                        </style>
                        <div id="Rvtz5o9">
                            <div class="bp6-logo bp6-logo-5YjI component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                <div class="bp6-adamoutline">
                                    <img alt="Image" class="bp6-shape1" src="./img/iphone-x-work-shape@2x.png"/>
                                    <img alt="Image" class="bp6-path" src="./img/iphone-x-home-path@2x.png"/>
                                </div>
                                <div class="bp6-adamfill anima-hidden ">
                                    <img alt="Image" class="bp6-shape1" src="./img/iphone-x-home-menu-hover-shape-4@2x.png"/>
                                    <img alt="Image" class="bp6-path1" src="./img/iphone-x-menu-light-hover-path-1@2x.png"/>
                                </div>
                            </div>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp6-iphonexhome .bp6-sectionhero .bp6-group3 .bp6-logo-5YjI", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp6-adamfill": {
                "delay": 0, 
                "duration": 400, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp6-adamfill": {
                "delay": 0, 
                "duration": 500, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp6-adamfill": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                        <a href="javascript:animaShowOverlay('iphonexhomemenuhover', 'anima-animate-appear'); anima_loadAsyncSrc(); ">
                            <img alt="Image" anima-src="./img/iphone-x-home-menu-hover-shape-2@2x.png" class="bp6-shape" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                        </a>
                    </div>
                </div>
                <div class="bp6-workcontent">
                    <a href="adobe.html">
                        <div class="bp6-card4 anima-smart-layers-pointers ">
                            <div class="bp6-card11">
                                <div class="bp6-mask">
                                </div>
                                <div class="bp6-adobesystemslogoandwordmark">
                                    <div class="bp6-g4151">
                                        <img alt="Image" anima-src="./img/iphone-x-home-polygon15@2x.png" class="bp6-polygon15" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                                        <img alt="Image" anima-src="./img/iphone-x-home-polygon17@2x.png" class="bp6-polygon17" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                                        <img alt="Image" anima-src="./img/iphone-x-home-polygon19@2x.png" class="bp6-polygon19" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </a>
                    <a href="swiftrides.html">
                        <div class="bp6-card3 anima-smart-layers-pointers ">
                            <div class="bp6-card11">
                                <div class="bp6-mask">
                                </div>
                                <div class="bp6-rectangle">
                                </div>
                                <img alt="Image" anima-src="./img/iphone-x-home-swift@2x.png" class="bp6-swift" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                            </div>
                        </div>
                    </a>
                    <a href="designco.html">
                        <div class="bp6-card2 anima-smart-layers-pointers ">
                            <div class="bp6-card11">
                                <div class="bp6-mask">
                                </div>
                                <img alt="Image" anima-src="./img/iphone-x-home-screen-shot-2020-04-23-at-83825-pm.png" class="bp6-screenshot20200423at83825pm" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                            </div>
                        </div>
                    </a>
                    <a href="sslrpdeals.html">
                        <div class="bp6-card1 anima-smart-layers-pointers ">
                            <div class="bp6-card11">
                                <div class="bp6-mask">
                                </div>
                                <img alt="Image" anima-src="./img/iphone-x-home-rotato-snapshot@2x.png" class="bp6-rotatosnapshot" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                            </div>
                        </div>
                    </a>
                    <div class="bp6-text">
                        <div anima-show-on-scroll="" class="bp6-h2">
                            Crafted with intention. Bringing all attention.
                        </div>
                        <div anima-show-on-scroll="" class="bp6-h1">
                            Embarking on a Journey through Pixels.
                        </div>
                        <div anima-show-on-scroll="" class="bp6-h3">
                            WORK
                        </div>
                    </div>
                </div>
                <div class="bp6-sectionfooter">
                    <img alt="Image" anima-src="./img/iphone-x-home-bg.png" class="bp6-bg" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                    <div class="bp6-footer">
                        <div class="bp6-socialicons">
                            <style>
                                .bp6-iphonexhome .bp6-sectionfooter .bp6-footer .bp6-socialicons .bp6-dribbble-twer * {
                                    box-sizing          : border-box;
                                }
                                .bp6-iphonexhome .bp6-sectionfooter .bp6-footer .bp6-socialicons .bp6-dribbble-twer {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 19px;
                                    width               : 20px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 39px;
                                    transform           : rotate(0deg);
                                }
                                .bp6-iphonexhome .bp6-sectionfooter .bp6-footer .bp6-socialicons .bp6-dribbble-twer .bp6-shape {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 95.00%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 2.50%;
                                    transform           : rotate(0deg);
                                }
                                .bp6-iphonexhome .bp6-sectionfooter .bp6-footer .bp6-socialicons .bp6-dribbble-twer .bp6-shapehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 95.00%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 2.50%;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                }
                            </style>
                            <div id="RsssA4H">
                                <a href="https://dribbble.com/syedadam007" target="_blank">
                                    <div class="bp6-dribbble bp6-dribbble-twer component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <img alt="Image" class="bp6-shape" src="./img/iphone-x-adobe-shape-3@2x.png"/>
                                        <img alt="Image" class="bp6-shapehover anima-hidden " src="./img/iphone-x-about-shapehover@2x.png"/>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp6-iphonexhome .bp6-sectionfooter .bp6-footer .bp6-socialicons .bp6-dribbble-twer", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp6-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp6-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp6-shapehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <style>
                                .bp6-iphonexhome .bp6-sectionfooter .bp6-footer .bp6-socialicons .bp6-linkedin-ylYw * {
                                    box-sizing          : border-box;
                                }
                                .bp6-iphonexhome .bp6-sectionfooter .bp6-footer .bp6-socialicons .bp6-linkedin-ylYw {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 19px;
                                    width               : 20px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .bp6-iphonexhome .bp6-sectionfooter .bp6-footer .bp6-socialicons .bp6-linkedin-ylYw .bp6-shape {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 95.00%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 2.50%;
                                    transform           : rotate(0deg);
                                }
                                .bp6-iphonexhome .bp6-sectionfooter .bp6-footer .bp6-socialicons .bp6-linkedin-ylYw .bp6-shapehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 95.00%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 2.50%;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                }
                            </style>
                            <div id="Lhy3cKG">
                                <a href="https://www.linkedin.com/in/syedadamemirputra/" target="_blank">
                                    <div class="bp6-linkedin bp6-linkedin-ylYw component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <img alt="Image" class="bp6-shape" src="./img/iphone-x-swiftrides-shape-4@2x.png"/>
                                        <img alt="Image" class="bp6-shapehover anima-hidden " src="./img/iphone-x-about-shapehover-1@2x.png"/>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp6-iphonexhome .bp6-sectionfooter .bp6-footer .bp6-socialicons .bp6-linkedin-ylYw", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp6-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp6-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp6-shapehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <style>
                                .bp6-iphonexhome .bp6-sectionfooter .bp6-footer .bp6-socialicons .bp6-instagram-M6HI * {
                                    box-sizing          : border-box;
                                }
                                .bp6-iphonexhome .bp6-sectionfooter .bp6-footer .bp6-socialicons .bp6-instagram-M6HI {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 19px;
                                    width               : 20px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 77px;
                                    transform           : rotate(0deg);
                                }
                                .bp6-iphonexhome .bp6-sectionfooter .bp6-footer .bp6-socialicons .bp6-instagram-M6HI .bp6-shape {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 95.00%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 2.50%;
                                    transform           : rotate(0deg);
                                }
                                .bp6-iphonexhome .bp6-sectionfooter .bp6-footer .bp6-socialicons .bp6-instagram-M6HI .bp6-shapehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 95.00%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 2.50%;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                }
                            </style>
                            <div id="J0M0k1N">
                                <a href="https://www.instagram.com/syedadam007/" target="_blank">
                                    <div class="bp6-instagram bp6-instagram-M6HI component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <img alt="Image" class="bp6-shape" src="./img/iphone-x-designco-shape-5@2x.png"/>
                                        <img alt="Image" class="bp6-shapehover anima-hidden " src="./img/iphone-x-designco-shapehover-2@2x.png"/>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp6-iphonexhome .bp6-sectionfooter .bp6-footer .bp6-socialicons .bp6-instagram-M6HI", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp6-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp6-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp6-shapehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                        </div>
                        <div anima-show-on-scroll="" class="bp6-h3">
                            Â© 2020 Lil Adam X
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="bp3-web1280home anima-word-break ">
            <div style="width: 1280px; height: 100%; position:relative; margin:auto;">
                <div class="bp3-sectionhero" id="None">
                    <div class="bp3-rectangle">
                    </div>
                    <div class="bp3-content">
                        <div anima-show-on-scroll="" class="bp3-mission">
                            Adam designs because the world ainâ€™t right. <br />Demystifying the ways the world should be.
                        </div>
                        <div class="bp3-present">
                            Present
                        </div>
                        <style>
                            .bp3-web1280home .bp3-sectionhero .bp3-content .bp3-designco-vvMx * {
                                box-sizing          : border-box;
                            }
                            .bp3-web1280home .bp3-sectionhero .bp3-content .bp3-designco-vvMx {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 218px;
                                height              : 22px;
                                width               : 105px;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionhero .bp3-content .bp3-designco-vvMx .bp3-designco1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 11px);
                                height              : 21px;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 20.16px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.39px;
                                line-height         : 25.0px;
                            }
                            .bp3-web1280home .bp3-sectionhero .bp3-content .bp3-designco-vvMx .bp3-designcohover {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 11px);
                                height              : 21px;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 20.16px;
                                color               : rgba(146, 146, 146, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.39px;
                                line-height         : 25.0px;
                            }
                        </style>
                        <div id="cHpAjO9">
                            <div class="bp3-designco bp3-designco-vvMx component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                <a href="http://www.ucsddesign.co/" target="_blank">
                                    <div class="bp3-designco1">
                                        Design Co
                                    </div>
                                </a>
                                <a href="http://www.ucsddesign.co/" target="_blank">
                                    <div class="bp3-designcohover anima-hidden ">
                                        Design Co
                                    </div>
                                </a>
                            </div>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp3-web1280home .bp3-sectionhero .bp3-content .bp3-designco-vvMx", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp3-designcohover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp3-designcohover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp3-designcohover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                        <div class="bp3-education">
                            Education
                        </div>
                        <style>
                            .bp3-web1280home .bp3-sectionhero .bp3-content .bp3-ucsd-40b0 * {
                                box-sizing          : border-box;
                            }
                            .bp3-web1280home .bp3-sectionhero .bp3-content .bp3-ucsd-40b0 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 325px;
                                height              : 22px;
                                width               : 143px;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionhero .bp3-content .bp3-ucsd-40b0 .bp3-ucsd1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 11px);
                                height              : 21px;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 20.16px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.39px;
                                line-height         : 25.0px;
                            }
                            .bp3-web1280home .bp3-sectionhero .bp3-content .bp3-ucsd-40b0 .bp3-ucsdhover {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 11px);
                                height              : 21px;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 20.16px;
                                color               : rgba(146, 146, 146, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.39px;
                                line-height         : 25.0px;
                            }
                        </style>
                        <div id="ctWPf3H">
                            <div class="bp3-ucsd bp3-ucsd-40b0 component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                <a href="https://ucsd.edu/" target="_blank">
                                    <div class="bp3-ucsd1">
                                        UC San Diego
                                    </div>
                                </a>
                                <a href="https://ucsd.edu/" target="_blank">
                                    <div class="bp3-ucsdhover anima-hidden ">
                                        UC San Diego
                                    </div>
                                </a>
                            </div>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp3-web1280home .bp3-sectionhero .bp3-content .bp3-ucsd-40b0", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp3-ucsdhover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp3-ucsdhover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp3-ucsdhover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                        <div class="bp3-previous">
                            Previous
                        </div>
                        <style>
                            .bp3-web1280home .bp3-sectionhero .bp3-content .bp3-longstorystudios-zGc8 * {
                                box-sizing          : border-box;
                            }
                            .bp3-web1280home .bp3-sectionhero .bp3-content .bp3-longstorystudios-zGc8 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 218px;
                                height              : 22px;
                                width               : 191px;
                                position            : absolute;
                                margin              : 0;
                                left                : 372px;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionhero .bp3-content .bp3-longstorystudios-zGc8 .bp3-ls {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 11px);
                                height              : 21px;
                                width               : 99.48%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.26%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 20.16px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.39px;
                                line-height         : 25.0px;
                            }
                            .bp3-web1280home .bp3-sectionhero .bp3-content .bp3-longstorystudios-zGc8 .bp3-lshover {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 11px);
                                height              : 21px;
                                width               : 99.48%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.26%;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 20.16px;
                                color               : rgba(146, 146, 146, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.39px;
                                line-height         : 25.0px;
                            }
                        </style>
                        <div id="yAtTmmg">
                            <div class="bp3-longstorystudios bp3-longstorystudios-zGc8 component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                <a href="https://www.longstorystudios.com/" target="_blank">
                                    <div class="bp3-ls">
                                        Long Story Studios
                                    </div>
                                </a>
                                <a href="https://www.longstorystudios.com/" target="_blank">
                                    <div class="bp3-lshover anima-hidden ">
                                        Long Story Studios
                                    </div>
                                </a>
                            </div>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp3-web1280home .bp3-sectionhero .bp3-content .bp3-longstorystudios-zGc8", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp3-lshover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp3-lshover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp3-lshover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                    </div>
                    <style>
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP * {
                            box-sizing          : border-box;
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 190px;
                            height              : 366px;
                            width               : 42px;
                            position            : absolute;
                            margin              : 0;
                            left                : 1237px;
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberoff {
                            background-color    : rgba(255,255,255,0.0);
                            bottom              : 0px;
                            height              : 75.68%;
                            width               : 100%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0px;
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberoff .bp3-lightsaberoff1 {
                            background-color    : rgba(255,255,255,0.0);
                            bottom              : 0px;
                            height              : 37.55%;
                            width               : 76.19%;
                            position            : absolute;
                            margin              : 0;
                            left                : 7.14%;
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberoff .bp3-lightsaberoff1 .bp3-rectangle14 {
                            background-color    : rgba(84, 82, 82, 1.0);
                            right               : 6.25%;
                            top                 : 39.90%;
                            height              : 20.19%;
                            width               : 78.12%;
                            position            : absolute;
                            margin              : 0;
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberoff .bp3-lightsaberoff1 .bp3-rectangle1 {
                            background-color    : rgba(196, 196, 196, 1.0);
                            top                 : 41.35%;
                            height              : 1.92%;
                            width               : 9.38%;
                            position            : absolute;
                            margin              : 0;
                            left                : 3.12%;
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberoff .bp3-lightsaberoff1 .bp3-rectangle2 {
                            background-color    : rgba(196, 196, 196, 1.0);
                            bottom              : 42.31%;
                            height              : 1.92%;
                            width               : 9.38%;
                            position            : absolute;
                            margin              : 0;
                            left                : 3.12%;
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberoff .bp3-lightsaberoff1 .bp3-rectangle3 {
                            background-color    : rgba(196, 196, 196, 1.0);
                            top                 : 46.15%;
                            height              : 3.85%;
                            width               : 9.38%;
                            position            : absolute;
                            margin              : 0;
                            left                : 3.12%;
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberoff .bp3-lightsaberoff1 .bp3-rectangle4 {
                            background-color    : rgba(196, 196, 196, 1.0);
                            bottom              : 46.15%;
                            height              : 3.85%;
                            width               : 9.38%;
                            position            : absolute;
                            margin              : 0;
                            left                : 3.12%;
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberoff .bp3-lightsaberoff1 .bp3-shape {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 38.94%;
                            height              : 22.12%;
                            width               : 93.75%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0px;
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberoff .bp3-lightsaberoff1 .bp3-rectangle5 {
                            background-color    : rgba(255,255,255,0.0);
                            right               : 12.50%;
                            bottom              : 4.81%;
                            height              : 35.58%;
                            box-sizing          : border-box;
                            width               : 65.62%;
                            position            : absolute;
                            margin              : 0;
                            border-style        : solid;
                            border-width        : 2px;
                            border-color        : rgba(0, 0, 0, 1.0);
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberoff .bp3-lightsaberoff1 .bp3-rectangle6 {
                            background-color    : rgba(196, 196, 196, 1.0);
                            right               : 12.50%;
                            top                 : 21.15%;
                            height              : 19.23%;
                            box-sizing          : border-box;
                            width               : 65.62%;
                            position            : absolute;
                            margin              : 0;
                            border-style        : solid;
                            border-width        : 2px;
                            border-color        : rgba(0, 0, 0, 1.0);
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberoff .bp3-lightsaberoff1 .bp3-rectangle7 {
                            background-color    : rgba(141, 141, 141, 1.0);
                            right               : 12.50%;
                            bottom              : 4.81%;
                            height              : 35.58%;
                            box-sizing          : border-box;
                            width               : 65.62%;
                            position            : absolute;
                            margin              : 0;
                            border-style        : solid;
                            border-width        : 2px;
                            border-color        : rgba(0, 0, 0, 1.0);
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberoff .bp3-lightsaberoff1 .bp3-rectangle8 {
                            background-color    : rgba(84, 82, 82, 1.0);
                            right               : 15.62%;
                            top                 : 0px;
                            height              : 13.46%;
                            box-sizing          : border-box;
                            width               : 56.25%;
                            position            : absolute;
                            margin              : 0;
                            border-style        : solid;
                            border-width        : 2px;
                            border-color        : rgba(0, 0, 0, 1.0);
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberoff .bp3-lightsaberoff1 .bp3-rectangle9 {
                            background-color    : rgba(84, 82, 82, 1.0);
                            right               : 0px;
                            top                 : 10.58%;
                            height              : 10.58%;
                            box-sizing          : border-box;
                            width               : 84.38%;
                            position            : absolute;
                            margin              : 0;
                            border-style        : solid;
                            border-width        : 2px;
                            border-color        : rgba(0, 0, 0, 1.0);
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberoff .bp3-lightsaberoff1 .bp3-path {
                            background-color    : rgba(255,255,255,0.0);
                            right               : 15.62%;
                            top                 : 12.50%;
                            height              : 6.73%;
                            width               : 9.38%;
                            position            : absolute;
                            margin              : 0;
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberoff .bp3-lightsaberoff1 .bp3-path1 {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 12.50%;
                            height              : 7.69%;
                            width               : 9.38%;
                            position            : absolute;
                            margin              : 0;
                            left                : 28.12%;
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberoff .bp3-lightsaberoff1 .bp3-rectangle10 {
                            background-color    : rgba(0, 0, 0, 1.0);
                            right               : 40.62%;
                            bottom              : 6.73%;
                            height              : 30.77%;
                            width               : 6.25%;
                            position            : absolute;
                            margin              : 0;
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberoff .bp3-lightsaberoff1 .bp3-rectangle11 {
                            background-color    : rgba(0, 0, 0, 1.0);
                            bottom              : 6.73%;
                            height              : 30.77%;
                            width               : 6.25%;
                            position            : absolute;
                            margin              : 0;
                            left                : 37.50%;
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberoff .bp3-lightsaberoff1 .bp3-rectangle12 {
                            background-color    : rgba(0, 0, 0, 1.0);
                            right               : 25.00%;
                            bottom              : 6.73%;
                            height              : 30.77%;
                            width               : 6.25%;
                            position            : absolute;
                            margin              : 0;
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberoff .bp3-lightsaberoff1 .bp3-rectangle13 {
                            background-color    : rgba(84, 82, 82, 1.0);
                            right               : 18.75%;
                            bottom              : 0px;
                            height              : 7.69%;
                            box-sizing          : border-box;
                            width               : 50.00%;
                            position            : absolute;
                            margin              : 0;
                            border-style        : solid;
                            border-width        : 2px;
                            border-color        : rgba(0, 0, 0, 1.0);
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberoff .bp3-achievements {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 0px;
                            height              : 54.51%;
                            width               : 100%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0px;
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberoff .bp3-achievements .bp3-rectangle14 {
                            background-color    : rgba(255, 255, 255, 1.0);
                            top                 : 0px;
                            height              : 100%;
                            box-sizing          : border-box;
                            width               : 100%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0px;
                            border-style        : solid;
                            border-width        : 0px;
                            border-color        : rgba(150, 150, 150, 1.0);
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberoff .bp3-achievements .bp3-achievements1 {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : calc(50.00% - 11px);
                            height              : 21px;
                            width               : 264.29%;
                            position            : absolute;
                            margin              : 0;
                            left                : -82.14%;
                            transform           : rotate(-90deg);
                            font-family         : "Gilroy-Bold", Helvetica, Arial, serif;
                            font-size           : 20.16px;
                            color               : rgba(0, 0, 0, 1.0);
                            text-align          : left;
                            letter-spacing      : 0.39px;
                            line-height         : 26.0px;
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberon {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 0px;
                            height              : 100.27%;
                            width               : 100%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0px;
                            transform           : rotate(0deg);
                            opacity             : 0.0;
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberon .bp3-lightsaberon1 {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 0px;
                            height              : 100%;
                            width               : 76.19%;
                            position            : absolute;
                            margin              : 0;
                            left                : 7.14%;
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberon .bp3-lightsaberon1 .bp3-group {
                            background-color    : rgba(255,255,255,0.0);
                            right               : 25.00%;
                            top                 : 0px;
                            height              : 72.48%;
                            width               : 37.50%;
                            position            : absolute;
                            margin              : 0;
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberon .bp3-lightsaberon1 .bp3-group .bp3-path2 {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 0px;
                            height              : 99.62%;
                            width               : 83.33%;
                            position            : absolute;
                            margin              : 0;
                            left                : 8.33%;
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberon .bp3-lightsaberon1 .bp3-group .bp3-path3 {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 0px;
                            height              : 100.38%;
                            width               : 100%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0px;
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberon .bp3-lightsaberon1 .bp3-rectangle15 {
                            background-color    : rgba(84, 82, 82, 1.0);
                            right               : 6.25%;
                            bottom              : 11.44%;
                            height              : 5.72%;
                            width               : 78.12%;
                            position            : absolute;
                            margin              : 0;
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberon .bp3-lightsaberon1 .bp3-rectangle16 {
                            background-color    : rgba(196, 196, 196, 1.0);
                            bottom              : 16.08%;
                            height              : 0.54%;
                            width               : 9.38%;
                            position            : absolute;
                            margin              : 0;
                            left                : 3.12%;
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberon .bp3-lightsaberon1 .bp3-rectangle17 {
                            background-color    : rgba(196, 196, 196, 1.0);
                            bottom              : 11.99%;
                            height              : 0.54%;
                            width               : 9.38%;
                            position            : absolute;
                            margin              : 0;
                            left                : 3.12%;
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberon .bp3-lightsaberon1 .bp3-rectangle18 {
                            background-color    : rgba(196, 196, 196, 1.0);
                            bottom              : 14.17%;
                            height              : 1.09%;
                            width               : 9.38%;
                            position            : absolute;
                            margin              : 0;
                            left                : 3.12%;
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberon .bp3-lightsaberon1 .bp3-rectangle19 {
                            background-color    : rgba(196, 196, 196, 1.0);
                            bottom              : 13.08%;
                            height              : 1.09%;
                            width               : 9.38%;
                            position            : absolute;
                            margin              : 0;
                            left                : 3.12%;
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberon .bp3-lightsaberon1 .bp3-shape1 {
                            background-color    : rgba(255,255,255,0.0);
                            bottom              : 11.17%;
                            height              : 6.27%;
                            width               : 93.75%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0px;
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberon .bp3-lightsaberon1 .bp3-rectangle20 {
                            background-color    : rgba(255,255,255,0.0);
                            right               : 12.50%;
                            bottom              : 1.36%;
                            height              : 10.08%;
                            box-sizing          : border-box;
                            width               : 65.62%;
                            position            : absolute;
                            margin              : 0;
                            border-style        : solid;
                            border-width        : 2px;
                            border-color        : rgba(0, 0, 0, 1.0);
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberon .bp3-lightsaberon1 .bp3-rectangle21 {
                            background-color    : rgba(196, 196, 196, 1.0);
                            right               : 12.50%;
                            bottom              : 16.89%;
                            height              : 5.45%;
                            box-sizing          : border-box;
                            width               : 65.62%;
                            position            : absolute;
                            margin              : 0;
                            border-style        : solid;
                            border-width        : 2px;
                            border-color        : rgba(0, 0, 0, 1.0);
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberon .bp3-lightsaberon1 .bp3-rectangle22 {
                            background-color    : rgba(141, 141, 141, 1.0);
                            right               : 12.50%;
                            bottom              : 1.36%;
                            height              : 10.08%;
                            box-sizing          : border-box;
                            width               : 65.62%;
                            position            : absolute;
                            margin              : 0;
                            border-style        : solid;
                            border-width        : 2px;
                            border-color        : rgba(0, 0, 0, 1.0);
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberon .bp3-lightsaberon1 .bp3-rectangle23 {
                            background-color    : rgba(84, 82, 82, 1.0);
                            right               : 15.62%;
                            bottom              : 24.52%;
                            height              : 3.81%;
                            box-sizing          : border-box;
                            width               : 56.25%;
                            position            : absolute;
                            margin              : 0;
                            border-style        : solid;
                            border-width        : 2px;
                            border-color        : rgba(0, 0, 0, 1.0);
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberon .bp3-lightsaberon1 .bp3-rectangle24 {
                            background-color    : rgba(84, 82, 82, 1.0);
                            right               : 0px;
                            bottom              : 22.34%;
                            height              : 3.00%;
                            box-sizing          : border-box;
                            width               : 84.38%;
                            position            : absolute;
                            margin              : 0;
                            border-style        : solid;
                            border-width        : 2px;
                            border-color        : rgba(0, 0, 0, 1.0);
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberon .bp3-lightsaberon1 .bp3-path4 {
                            background-color    : rgba(255,255,255,0.0);
                            right               : 15.62%;
                            bottom              : 22.89%;
                            height              : 1.91%;
                            width               : 9.38%;
                            position            : absolute;
                            margin              : 0;
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberon .bp3-lightsaberon1 .bp3-path5 {
                            background-color    : rgba(255,255,255,0.0);
                            bottom              : 22.62%;
                            height              : 2.18%;
                            width               : 9.38%;
                            position            : absolute;
                            margin              : 0;
                            left                : 28.12%;
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberon .bp3-lightsaberon1 .bp3-rectangle25 {
                            background-color    : rgba(0, 0, 0, 1.0);
                            right               : 40.62%;
                            bottom              : 1.91%;
                            height              : 8.72%;
                            width               : 6.25%;
                            position            : absolute;
                            margin              : 0;
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberon .bp3-lightsaberon1 .bp3-rectangle26 {
                            background-color    : rgba(0, 0, 0, 1.0);
                            bottom              : 1.91%;
                            height              : 8.72%;
                            width               : 6.25%;
                            position            : absolute;
                            margin              : 0;
                            left                : 37.50%;
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberon .bp3-lightsaberon1 .bp3-rectangle27 {
                            background-color    : rgba(0, 0, 0, 1.0);
                            right               : 25.00%;
                            bottom              : 1.91%;
                            height              : 8.72%;
                            width               : 6.25%;
                            position            : absolute;
                            margin              : 0;
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberon .bp3-lightsaberon1 .bp3-rectangle28 {
                            background-color    : rgba(84, 82, 82, 1.0);
                            right               : 18.75%;
                            bottom              : 0px;
                            height              : 2.18%;
                            box-sizing          : border-box;
                            width               : 50.00%;
                            position            : absolute;
                            margin              : 0;
                            border-style        : solid;
                            border-width        : 2px;
                            border-color        : rgba(0, 0, 0, 1.0);
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberon .bp3-achievements2 {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 24.52%;
                            height              : 41.14%;
                            width               : 100%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0px;
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberon .bp3-achievements2 .bp3-rectangle29 {
                            background-color    : rgba(255, 255, 255, 1.0);
                            top                 : 0px;
                            height              : 100%;
                            box-sizing          : border-box;
                            width               : 100%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0px;
                            border-style        : solid;
                            border-width        : 0px;
                            border-color        : rgba(150, 150, 150, 1.0);
                            transform           : rotate(0deg);
                        }
                        .bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP .bp3-lightsaberon .bp3-achievements2 .bp3-achievements3 {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : calc(50.00% - 11px);
                            height              : 21px;
                            width               : 264.29%;
                            position            : absolute;
                            margin              : 0;
                            left                : -82.14%;
                            transform           : rotate(-90deg);
                            font-family         : "Gilroy-Bold", Helvetica, Arial, serif;
                            font-size           : 20.16px;
                            color               : rgba(0, 0, 0, 1.0);
                            text-align          : left;
                            letter-spacing      : 0.39px;
                            line-height         : 26.0px;
                        }
                    </style>
                    <div id="t1NPh1r">
                        <div class="bp3-lightsaber bp3-lightsaber-CNGP component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                            <div class="bp3-lightsaberoff">
                                <div class="bp3-lightsaberoff1">
                                    <div class="bp3-rectangle14">
                                    </div>
                                    <div class="bp3-rectangle1">
                                    </div>
                                    <div class="bp3-rectangle2">
                                    </div>
                                    <div class="bp3-rectangle3">
                                    </div>
                                    <div class="bp3-rectangle4">
                                    </div>
                                    <img alt="Image" class="bp3-shape" src="./img/web-1280-home-shape@2x.png"/>
                                    <div class="bp3-rectangle5">
                                    </div>
                                    <div class="bp3-rectangle6">
                                    </div>
                                    <div class="bp3-rectangle7">
                                    </div>
                                    <div class="bp3-rectangle8">
                                    </div>
                                    <div class="bp3-rectangle9">
                                    </div>
                                    <img alt="Image" class="bp3-path" src="./img/web-1280-home-path@2x.png"/>
                                    <img alt="Image" class="bp3-path1" src="./img/web-1280-home-path-5@2x.png"/>
                                    <div class="bp3-rectangle10">
                                    </div>
                                    <div class="bp3-rectangle11">
                                    </div>
                                    <div class="bp3-rectangle12">
                                    </div>
                                    <div class="bp3-rectangle13">
                                    </div>
                                </div>
                                <a href="playground.html">
                                    <div class="bp3-achievements">
                                        <div class="bp3-rectangle14">
                                        </div>
                                        <div class="bp3-achievements1">
                                            Playground
                                        </div>
                                    </div>
                                </a>
                            </div>
                            <div class="bp3-lightsaberon anima-hidden ">
                                <div class="bp3-lightsaberon1">
                                    <div class="bp3-group">
                                        <img alt="Image" class="bp3-path2" src="./img/web-1280-home-path-2@2x.png"/>
                                        <img alt="Image" class="bp3-path3" src="./img/web-1280-home-path-3@2x.png"/>
                                    </div>
                                    <div class="bp3-rectangle15">
                                    </div>
                                    <div class="bp3-rectangle16">
                                    </div>
                                    <div class="bp3-rectangle17">
                                    </div>
                                    <div class="bp3-rectangle18">
                                    </div>
                                    <div class="bp3-rectangle19">
                                    </div>
                                    <img alt="Image" class="bp3-shape1" src="./img/web-1280-home-shape-1@2x.png"/>
                                    <div class="bp3-rectangle20">
                                    </div>
                                    <div class="bp3-rectangle21">
                                    </div>
                                    <div class="bp3-rectangle22">
                                    </div>
                                    <div class="bp3-rectangle23">
                                    </div>
                                    <div class="bp3-rectangle24">
                                    </div>
                                    <img alt="Image" class="bp3-path4" src="./img/web-1280-home-path@2x.png"/>
                                    <img alt="Image" class="bp3-path5" src="./img/web-1280-home-path-5@2x.png"/>
                                    <div class="bp3-rectangle25">
                                    </div>
                                    <div class="bp3-rectangle26">
                                    </div>
                                    <div class="bp3-rectangle27">
                                    </div>
                                    <div class="bp3-rectangle28">
                                    </div>
                                </div>
                                <a href="playground.html">
                                    <div class="bp3-achievements2">
                                        <div class="bp3-rectangle29">
                                        </div>
                                        <div class="bp3-achievements3">
                                            Playground
                                        </div>
                                    </div>
                                </a>
                            </div>
                        </div>
                    </div>
                    <script>
      (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp3-web1280home .bp3-sectionhero .bp3-lightsaber-CNGP", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp3-lightsaberon": {
                "delay": 0, 
                "duration": 400, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ".bp3-lightsaberoff .bp3-achievements"
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp3-lightsaberon": {
                "delay": 0, 
                "duration": 400, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ".bp3-lightsaberon .bp3-achievements2"
          }
        ], 
        "overrides": {
          ".bp3-lightsaberon": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                    </script>
                    <div class="bp3-navbar">
                        <style>
                            .bp3-web1280home .bp3-sectionhero .bp3-navbar .bp3-logo-Ev0i * {
                                box-sizing          : border-box;
                            }
                            .bp3-web1280home .bp3-sectionhero .bp3-navbar .bp3-logo-Ev0i {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 30px;
                                width               : 171px;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionhero .bp3-navbar .bp3-logo-Ev0i .bp3-adamoutline {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 99.42%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.29%;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionhero .bp3-navbar .bp3-logo-Ev0i .bp3-adamoutline .bp3-shape {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 3.33%;
                                height              : 93.33%;
                                width               : 82.35%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionhero .bp3-navbar .bp3-logo-Ev0i .bp3-adamoutline .bp3-path {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 0.59%;
                                top                 : 18.33%;
                                height              : 63.33%;
                                width               : 11.18%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionhero .bp3-navbar .bp3-logo-Ev0i .bp3-adamfill {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 0px;
                                top                 : 3.33%;
                                height              : 93.33%;
                                width               : 98.83%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                            }
                            .bp3-web1280home .bp3-sectionhero .bp3-navbar .bp3-logo-Ev0i .bp3-adamfill .bp3-shape1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 81.66%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionhero .bp3-navbar .bp3-logo-Ev0i .bp3-adamfill .bp3-path1 {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 0.59%;
                                bottom              : 10.71%;
                                height              : 71.43%;
                                width               : 11.24%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                        </style>
                        <div id="WhWairz">
                            <div class="bp3-logo bp3-logo-Ev0i component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                <div class="bp3-adamoutline">
                                    <img alt="Image" class="bp3-shape" src="./img/web-1280-about-shape@2x.png"/>
                                    <img alt="Image" class="bp3-path" src="./img/web-1280-about-path@2x.png"/>
                                </div>
                                <div class="bp3-adamfill anima-hidden ">
                                    <img alt="Image" class="bp3-shape1" src="./img/web-1280-about-shape-1@2x.png"/>
                                    <img alt="Image" class="bp3-path1" src="./img/web-1280-home-path-7@2x.png"/>
                                </div>
                            </div>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp3-web1280home .bp3-sectionhero .bp3-navbar .bp3-logo-Ev0i", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp3-adamfill": {
                "delay": 0, 
                "duration": 400, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp3-adamfill": {
                "delay": 0, 
                "duration": 500, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp3-adamfill": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                        <div class="bp3-navbar1">
                            <style>
                                .bp3-web1280home .bp3-sectionhero .bp3-navbar .bp3-navbar1 .bp3-resume-56gy * {
                                    box-sizing          : border-box;
                                }
                                .bp3-web1280home .bp3-sectionhero .bp3-navbar .bp3-navbar1 .bp3-resume-56gy {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 26px;
                                    width               : 87px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 379px;
                                    transform           : rotate(0deg);
                                }
                                .bp3-web1280home .bp3-sectionhero .bp3-navbar .bp3-navbar1 .bp3-resume-56gy .bp3-resume1 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 13px);
                                    height              : 25px;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 18.9px;
                                    color               : rgba(126, 126, 126, 1.0);
                                    text-align          : center;
                                    letter-spacing      : 0.52px;
                                    line-height         : 23.0px;
                                }
                                .bp3-web1280home .bp3-sectionhero .bp3-navbar .bp3-navbar1 .bp3-resume-56gy .bp3-resumehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 13px);
                                    height              : 25px;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 18.9px;
                                    color               : rgba(31, 208, 118, 1.0);
                                    text-align          : center;
                                    letter-spacing      : 0.52px;
                                    line-height         : 23.0px;
                                }
                            </style>
                            <div id="ZIAPCCw">
                                <a href="https://drive.google.com/file/d/1KxPEStKpGkBtJaURrrckkRjVntkcITWU/view?usp=sharing" target="_blank">
                                    <div class="bp3-resume bp3-resume-56gy component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <div class="bp3-resume1 anima-valign-text-middle">
                                            Resume
                                        </div>
                                        <div class="bp3-resumehover anima-valign-text-middle anima-hidden ">
                                            Resume
                                        </div>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp3-web1280home .bp3-sectionhero .bp3-navbar .bp3-navbar1 .bp3-resume-56gy", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp3-resumehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp3-resumehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp3-resumehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <style>
                                .bp3-web1280home .bp3-sectionhero .bp3-navbar .bp3-navbar1 .bp3-about-Wqrl * {
                                    box-sizing          : border-box;
                                }
                                .bp3-web1280home .bp3-sectionhero .bp3-navbar .bp3-navbar1 .bp3-about-Wqrl {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 26px;
                                    width               : 87px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 253px;
                                    transform           : rotate(0deg);
                                }
                                .bp3-web1280home .bp3-sectionhero .bp3-navbar .bp3-navbar1 .bp3-about-Wqrl .bp3-about1 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 13px);
                                    height              : 25px;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 18.9px;
                                    color               : rgba(126, 126, 126, 1.0);
                                    text-align          : center;
                                    letter-spacing      : 0.52px;
                                    line-height         : 23.0px;
                                }
                                .bp3-web1280home .bp3-sectionhero .bp3-navbar .bp3-navbar1 .bp3-about-Wqrl .bp3-abouthover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 13px);
                                    height              : 25px;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 18.9px;
                                    color               : rgba(214, 214, 214, 1.0);
                                    text-align          : center;
                                    letter-spacing      : 0.52px;
                                    line-height         : 23.0px;
                                }
                            </style>
                            <div id="XFSfaWd">
                                <a href="about.html">
                                    <div class="bp3-about bp3-about-Wqrl component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <div class="bp3-about1 anima-valign-text-middle">
                                            About
                                        </div>
                                        <div class="bp3-abouthover anima-valign-text-middle anima-hidden ">
                                            About
                                        </div>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp3-web1280home .bp3-sectionhero .bp3-navbar .bp3-navbar1 .bp3-about-Wqrl", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp3-abouthover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp3-abouthover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp3-abouthover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <style>
                                .bp3-web1280home .bp3-sectionhero .bp3-navbar .bp3-navbar1 .bp3-work-4P1f * {
                                    box-sizing          : border-box;
                                }
                                .bp3-web1280home .bp3-sectionhero .bp3-navbar .bp3-navbar1 .bp3-work-4P1f {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 26px;
                                    width               : 87px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 126px;
                                    transform           : rotate(0deg);
                                }
                                .bp3-web1280home .bp3-sectionhero .bp3-navbar .bp3-navbar1 .bp3-work-4P1f .bp3-work1 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 13px);
                                    height              : 25px;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 18.9px;
                                    color               : rgba(126, 126, 126, 1.0);
                                    text-align          : center;
                                    letter-spacing      : 0.52px;
                                    line-height         : 23.0px;
                                }
                                .bp3-web1280home .bp3-sectionhero .bp3-navbar .bp3-navbar1 .bp3-work-4P1f .bp3-workhover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 13px);
                                    height              : 25px;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 18.9px;
                                    color               : rgba(215, 215, 215, 1.0);
                                    text-align          : center;
                                    letter-spacing      : 0.52px;
                                    line-height         : 23.0px;
                                }
                            </style>
                            <div id="F4KMPOr">
                                <a href="work.html">
                                </a>
                                <div class="bp3-work bp3-work-4P1f component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                    <a href="work.html">
                                    </a>
                                    <a href="work.html">
                                        <div class="bp3-work1 anima-valign-text-middle">
                                            Work
                                        </div>
                                    </a>
                                    <a href="work.html">
                                        <div class="bp3-workhover anima-valign-text-middle anima-hidden ">
                                            Work
                                        </div>
                                    </a>
                                </div>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp3-web1280home .bp3-sectionhero .bp3-navbar .bp3-navbar1 .bp3-work-4P1f", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp3-workhover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp3-workhover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ".bp3-work1"
          }
        ], 
        "overrides": {
          ".bp3-workhover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <style>
                                .bp3-web1280home .bp3-sectionhero .bp3-navbar .bp3-navbar1 .bp3-home-X39I * {
                                    box-sizing          : border-box;
                                }
                                .bp3-web1280home .bp3-sectionhero .bp3-navbar .bp3-navbar1 .bp3-home-X39I {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 26px;
                                    width               : 87px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .bp3-web1280home .bp3-sectionhero .bp3-navbar .bp3-navbar1 .bp3-home-X39I .bp3-home1 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 13px);
                                    height              : 25px;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 18.9px;
                                    color               : rgba(255, 255, 255, 1.0);
                                    text-align          : center;
                                    letter-spacing      : 0.52px;
                                    line-height         : 23.0px;
                                }
                                .bp3-web1280home .bp3-sectionhero .bp3-navbar .bp3-navbar1 .bp3-home-X39I .bp3-homehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 13px);
                                    height              : 25px;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 18.9px;
                                    color               : rgba(146, 146, 146, 1.0);
                                    text-align          : center;
                                    letter-spacing      : 0.52px;
                                    line-height         : 23.0px;
                                }
                            </style>
                            <div id="VuPiyEV">
                                <div class="bp3-home bp3-home-X39I component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                    <div class="bp3-home1 anima-valign-text-middle">
                                        Home
                                    </div>
                                    <div class="bp3-homehover anima-valign-text-middle anima-hidden ">
                                        Home
                                    </div>
                                </div>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp3-web1280home .bp3-sectionhero .bp3-navbar .bp3-navbar1 .bp3-home-X39I", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp3-homehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp3-homehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp3-homehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                        </div>
                    </div>
                </div>
                <div class="bp3-sectionwork">
                    <div class="bp3-workbg">
                    </div>
                    <div class="bp3-workcontent">
                        <style>
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card4-tz16 * {
                                box-sizing          : border-box;
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card4-tz16 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 678px;
                                height              : 393px;
                                width               : 555px;
                                position            : absolute;
                                margin              : 0;
                                left                : 577px;
                                transform           : rotate(0deg);
                                transition          : all 0.2s ease-in-out;
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card4-tz16 .bp3-card11 {
                                background-color    : rgba(248, 17, 34, 1.0);
                                top                 : 2.54%;
                                height              : 88.30%;
                                width               : 95.50%;
                                position            : absolute;
                                margin              : 0;
                                left                : 2.25%;
                                border-radius       : 6px;
                                overflow            : hidden;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card4-tz16 .bp3-card11 .bp3-mask {
                                background-color    : rgba(248, 17, 34, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 99.81%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 6px;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card4-tz16 .bp3-card11 .bp3-adobesystemslogoandwordmark {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 27.52%;
                                height              : 44.96%;
                                width               : 33.21%;
                                position            : absolute;
                                margin              : 0;
                                left                : 33.40%;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card4-tz16 .bp3-card11 .bp3-adobesystemslogoandwordmark .bp3-g4151 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : relative;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card4-tz16 .bp3-card11 .bp3-adobesystemslogoandwordmark .bp3-g4151 .bp3-polygon15 {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 0px;
                                top                 : 0.32%;
                                height              : 99.36%;
                                width               : 36.93%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card4-tz16 .bp3-card11 .bp3-adobesystemslogoandwordmark .bp3-g4151 .bp3-polygon17 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0.32%;
                                height              : 99.36%;
                                width               : 36.93%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card4-tz16 .bp3-card11 .bp3-adobesystemslogoandwordmark .bp3-g4151 .bp3-polygon19 {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 26.70%;
                                bottom              : 0.64%;
                                height              : 62.82%;
                                width               : 39.77%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card4-tz16 .bp3-card1hover {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : -0.76%;
                                height              : 100.25%;
                                width               : 98.02%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.99%;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card4-tz16 .bp3-card1hover .bp3-card1hover1 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                right               : 1.10%;
                                top                 : 2.03%;
                                height              : 88.07%;
                                width               : 97.43%;
                                position            : absolute;
                                margin              : 0;
                                border-radius       : 6px;
                                overflow            : hidden;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card4-tz16 .bp3-card1hover .bp3-card1hover1 .bp3-mask1 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 99.81%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 6px;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card4-tz16 .bp3-card1hover .bp3-card1hover1 .bp3-mask2 {
                                background-color    : rgba(248, 17, 34, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 99.81%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 6px;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card4-tz16 .bp3-card1hover .bp3-card1hover1 .bp3-adobesystemslogoandwordmark1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 27.52%;
                                height              : 44.96%;
                                width               : 33.21%;
                                position            : absolute;
                                margin              : 0;
                                left                : 33.40%;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card4-tz16 .bp3-card1hover .bp3-card1hover1 .bp3-adobesystemslogoandwordmark1 .bp3-g41511 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : relative;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card4-tz16 .bp3-card1hover .bp3-card1hover1 .bp3-adobesystemslogoandwordmark1 .bp3-g41511 .bp3-polygon151 {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 0px;
                                top                 : 0.32%;
                                height              : 99.36%;
                                width               : 36.93%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card4-tz16 .bp3-card1hover .bp3-card1hover1 .bp3-adobesystemslogoandwordmark1 .bp3-g41511 .bp3-polygon171 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0.32%;
                                height              : 99.36%;
                                width               : 36.93%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card4-tz16 .bp3-card1hover .bp3-card1hover1 .bp3-adobesystemslogoandwordmark1 .bp3-g41511 .bp3-polygon191 {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 26.70%;
                                bottom              : 0.64%;
                                height              : 62.82%;
                                width               : 39.77%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card4-tz16 .bp3-card1hover .bp3-card1hover1 .bp3-maskcopy {
                                background-color    : rgba(0, 0, 0, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 99.81%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 6px;
                                transform           : rotate(0deg);
                                opacity             : 0.77;
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card4-tz16 .bp3-card1hover .bp3-card1hover1 .bp3-group2 {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 33.14%;
                                height              : 32.56%;
                                width               : 54.34%;
                                position            : absolute;
                                margin              : 0;
                                left                : 22.64%;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card4-tz16 .bp3-card1hover .bp3-card1hover1 .bp3-group2 .bp3-sslrpfooddeals {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 76px;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Bold", Helvetica, Arial, serif;
                                font-size           : 37.8px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : center;
                                letter-spacing      : 0.73px;
                                line-height         : 47.0px;
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card4-tz16 .bp3-card1hover .bp3-card1hover1 .bp3-group2 .bp3-productdesign {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 0.88%;
                                height              : 21px;
                                width               : 54.86%;
                                position            : absolute;
                                margin              : 0;
                                left                : 22.57%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 20.16px;
                                color               : rgba(201, 201, 201, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.39px;
                                line-height         : 25.0px;
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card4-tz16 .bp3-card1hover .bp3-bluebox {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card4-tz16 .bp3-card1hover .bp3-bluebox .bp3-pixels {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 0.25%;
                                height              : 6.60%;
                                width               : 20.04%;
                                position            : absolute;
                                margin              : 0;
                                left                : 39.98%;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card4-tz16 .bp3-card1hover .bp3-bluebox .bp3-pixels .bp3-rectangle1 {
                                background-color    : rgba(59, 172, 247, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 1px;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card4-tz16 .bp3-card1hover .bp3-bluebox .bp3-pixels .bp3-a665x429 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 7px);
                                height              : 13px;
                                width               : 65.14%;
                                position            : absolute;
                                margin              : 0;
                                left                : 16.51%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 12.6px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : center;
                                letter-spacing      : 0.24px;
                                line-height         : 16.0px;
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card4-tz16 .bp3-card1hover .bp3-bluebox .bp3-outline {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 91.88%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card4-tz16 .bp3-card1hover .bp3-bluebox .bp3-outline .bp3-rectangle2 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 1.52%;
                                height              : 96.96%;
                                box-sizing          : border-box;
                                width               : 97.98%;
                                position            : absolute;
                                margin              : 0;
                                left                : 1.01%;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card4-tz16 .bp3-card1hover .bp3-bluebox .bp3-outline .bp3-rectangle3 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                top                 : 0.55%;
                                height              : 3.04%;
                                box-sizing          : border-box;
                                width               : 2.02%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.37%;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card4-tz16 .bp3-card1hover .bp3-bluebox .bp3-outline .bp3-rectanglecopy2 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                bottom              : 0px;
                                height              : 3.31%;
                                box-sizing          : border-box;
                                width               : 2.02%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card4-tz16 .bp3-card1hover .bp3-bluebox .bp3-outline .bp3-rectanglecopy3 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                right               : 0px;
                                bottom              : 0px;
                                height              : 3.31%;
                                box-sizing          : border-box;
                                width               : 2.21%;
                                position            : absolute;
                                margin              : 0;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card4-tz16 .bp3-card1hover .bp3-bluebox .bp3-outline .bp3-rectanglecopy4 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                right               : 0px;
                                top                 : 0px;
                                height              : 3.31%;
                                box-sizing          : border-box;
                                width               : 2.21%;
                                position            : absolute;
                                margin              : 0;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                        </style>
                        <div id="NIEDZrF">
                            <a href="adobe.html">
                                <div class="bp3-card4 bp3-card4-tz16 component anima-component-wrapper anima-not-ready anima-word-break anima-smart-layers-pointers state1" data-initial-state="state1">
                                    <div class="bp3-card11">
                                        <div class="bp3-mask">
                                        </div>
                                        <div class="bp3-adobesystemslogoandwordmark">
                                            <div class="bp3-g4151">
                                                <img alt="Image" class="bp3-polygon15" src="./img/web-1280-home-polygon15-1@2x.png"/>
                                                <img alt="Image" class="bp3-polygon17" src="./img/web-1280-home-polygon17@2x.png"/>
                                                <img alt="Image" class="bp3-polygon19" src="./img/web-1280-home-polygon19@2x.png"/>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="bp3-card1hover anima-hidden ">
                                        <div class="bp3-card1hover1">
                                            <div class="bp3-mask1">
                                            </div>
                                            <div class="bp3-mask2">
                                            </div>
                                            <div class="bp3-adobesystemslogoandwordmark1">
                                                <div class="bp3-g41511">
                                                    <img alt="Image" class="bp3-polygon151" src="./img/web-1280-home-polygon15-1@2x.png"/>
                                                    <img alt="Image" class="bp3-polygon171" src="./img/web-1280-home-polygon17@2x.png"/>
                                                    <img alt="Image" class="bp3-polygon191" src="./img/web-1280-home-polygon19@2x.png"/>
                                                </div>
                                            </div>
                                            <div class="bp3-maskcopy">
                                            </div>
                                            <div class="bp3-group2">
                                                <div class="bp3-sslrpfooddeals">
                                                    Adobe x The Ocean Agency
                                                </div>
                                                <div class="bp3-productdesign">
                                                    Product Design
                                                </div>
                                            </div>
                                        </div>
                                        <div class="bp3-bluebox">
                                            <div class="bp3-pixels">
                                                <div class="bp3-rectangle1">
                                                </div>
                                                <div class="bp3-a665x429">
                                                    APR x 2020
                                                </div>
                                            </div>
                                            <div class="bp3-outline">
                                                <div class="bp3-rectangle2">
                                                </div>
                                                <div class="bp3-rectangle3">
                                                </div>
                                                <div class="bp3-rectanglecopy2">
                                                </div>
                                                <div class="bp3-rectanglecopy3">
                                                </div>
                                                <div class="bp3-rectanglecopy4">
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </a>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card4-tz16", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp3-card1hover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp3-card1hover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp3-card1hover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                        <style>
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card3-onwA * {
                                box-sizing          : border-box;
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card3-onwA {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 678px;
                                height              : 393px;
                                width               : 556px;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                                transition          : all 0.2s ease-in-out;
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card3-onwA .bp3-card11 {
                                background-color    : rgba(97, 0, 238, 1.0);
                                top                 : 2.54%;
                                height              : 88.30%;
                                width               : 95.32%;
                                position            : absolute;
                                margin              : 0;
                                left                : 2.34%;
                                border-radius       : 6px;
                                overflow            : hidden;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card3-onwA .bp3-card11 .bp3-mask {
                                background-color    : rgba(97, 0, 238, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 99.81%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 6px;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card3-onwA .bp3-card11 .bp3-rectangle {
                                background-color    : rgba(98, 0, 238, 1.0);
                                top                 : -0.58%;
                                height              : 100.58%;
                                width               : 99.81%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card3-onwA .bp3-card11 .bp3-swift {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 24px;
                                height              : 304px;
                                width               : 474px;
                                position            : absolute;
                                margin              : 0;
                                left                : 28px;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card3-onwA .bp3-card1hover {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : -0.76%;
                                height              : 100.25%;
                                width               : 97.84%;
                                position            : absolute;
                                margin              : 0;
                                left                : 1.08%;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card3-onwA .bp3-card1hover .bp3-card1hover1 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 1.78%;
                                height              : 88.32%;
                                width               : 97.43%;
                                position            : absolute;
                                margin              : 0;
                                left                : 1.29%;
                                border-radius       : 6px;
                                overflow            : hidden;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card3-onwA .bp3-card1hover .bp3-card1hover1 .bp3-mask1 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 0px;
                                height              : 99.71%;
                                width               : 99.81%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 6px;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card3-onwA .bp3-card1hover .bp3-card1hover1 .bp3-rectangle {
                                background-color    : rgba(97, 0, 238, 1.0);
                                top                 : -0.57%;
                                height              : 100.57%;
                                box-sizing          : border-box;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-style        : solid;
                                border-width        : 0px;
                                border-color        : rgba(150, 150, 150, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card3-onwA .bp3-card1hover .bp3-card1hover1 .bp3-swift {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 13.77%;
                                bottom              : 14.08%;
                                height              : 70.11%;
                                width               : 71.89%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card3-onwA .bp3-card1hover .bp3-card1hover1 .bp3-swift .bp3-swift1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card3-onwA .bp3-card1hover .bp3-card1hover1 .bp3-mask {
                                background-color    : rgba(0, 0, 0, 1.0);
                                top                 : 0px;
                                height              : 99.71%;
                                width               : 99.81%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 6px;
                                transform           : rotate(0deg);
                                opacity             : 0.77;
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card3-onwA .bp3-card1hover .bp3-card1hover1 .bp3-group3 {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 27.55%;
                                bottom              : 39.94%;
                                height              : 19.25%;
                                width               : 44.53%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card3-onwA .bp3-card1hover .bp3-card1hover1 .bp3-group3 .bp3-sslrpfooddeals {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 38px;
                                width               : 99.58%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.21%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Bold", Helvetica, Arial, serif;
                                font-size           : 37.8px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.73px;
                                line-height         : 47.0px;
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card3-onwA .bp3-card1hover .bp3-card1hover1 .bp3-group3 .bp3-productdesign {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 0px;
                                height              : 21px;
                                width               : 65.68%;
                                position            : absolute;
                                margin              : 0;
                                left                : 17.16%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 20.16px;
                                color               : rgba(201, 201, 201, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.39px;
                                line-height         : 25.0px;
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card3-onwA .bp3-card1hover .bp3-bluebox {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card3-onwA .bp3-card1hover .bp3-bluebox .bp3-pixels {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 0.25%;
                                height              : 6.60%;
                                width               : 20.04%;
                                position            : absolute;
                                margin              : 0;
                                left                : 39.98%;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card3-onwA .bp3-card1hover .bp3-bluebox .bp3-pixels .bp3-rectangle1 {
                                background-color    : rgba(59, 172, 247, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 1px;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card3-onwA .bp3-card1hover .bp3-bluebox .bp3-pixels .bp3-a665x429 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 7px);
                                height              : 13px;
                                width               : 68.81%;
                                position            : absolute;
                                margin              : 0;
                                left                : 15.60%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 12.6px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : center;
                                letter-spacing      : 0.24px;
                                line-height         : 16.0px;
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card3-onwA .bp3-card1hover .bp3-bluebox .bp3-outline {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 91.88%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card3-onwA .bp3-card1hover .bp3-bluebox .bp3-outline .bp3-rectangle2 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 1.52%;
                                height              : 96.96%;
                                box-sizing          : border-box;
                                width               : 98.16%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.92%;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card3-onwA .bp3-card1hover .bp3-bluebox .bp3-outline .bp3-rectangle3 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                top                 : 0.55%;
                                height              : 3.04%;
                                box-sizing          : border-box;
                                width               : 2.21%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card3-onwA .bp3-card1hover .bp3-bluebox .bp3-outline .bp3-rectanglecopy2 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                bottom              : 0px;
                                height              : 3.31%;
                                box-sizing          : border-box;
                                width               : 2.02%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card3-onwA .bp3-card1hover .bp3-bluebox .bp3-outline .bp3-rectanglecopy3 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                right               : 0px;
                                bottom              : 0px;
                                height              : 3.31%;
                                box-sizing          : border-box;
                                width               : 2.21%;
                                position            : absolute;
                                margin              : 0;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card3-onwA .bp3-card1hover .bp3-bluebox .bp3-outline .bp3-rectanglecopy4 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                right               : 0px;
                                top                 : 0px;
                                height              : 3.31%;
                                box-sizing          : border-box;
                                width               : 2.21%;
                                position            : absolute;
                                margin              : 0;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                        </style>
                        <div id="fS8IGyA">
                            <a href="swiftrides.html">
                                <div class="bp3-card3 bp3-card3-onwA component anima-component-wrapper anima-not-ready anima-word-break anima-smart-layers-pointers state1" data-initial-state="state1">
                                    <div class="bp3-card11">
                                        <div class="bp3-mask">
                                        </div>
                                        <div class="bp3-rectangle">
                                        </div>
                                        <img alt="Image" class="bp3-swift" src="./img/web-1280-home-swift.png"/>
                                    </div>
                                    <div class="bp3-card1hover anima-hidden ">
                                        <div class="bp3-card1hover1">
                                            <div class="bp3-mask1">
                                            </div>
                                            <div class="bp3-rectangle">
                                            </div>
                                            <div class="bp3-swift">
                                                <img alt="Image" class="bp3-swift1" src="./img/web-1280-home-swift-1.png"/>
                                            </div>
                                            <div class="bp3-mask">
                                            </div>
                                            <div class="bp3-group3">
                                                <div class="bp3-sslrpfooddeals">
                                                    SWIFT Rides
                                                </div>
                                                <div class="bp3-productdesign">
                                                    Product Design
                                                </div>
                                            </div>
                                        </div>
                                        <div class="bp3-bluebox">
                                            <div class="bp3-pixels">
                                                <div class="bp3-rectangle1">
                                                </div>
                                                <div class="bp3-a665x429">
                                                    JUNE x 2017
                                                </div>
                                            </div>
                                            <div class="bp3-outline">
                                                <div class="bp3-rectangle2">
                                                </div>
                                                <div class="bp3-rectangle3">
                                                </div>
                                                <div class="bp3-rectanglecopy2">
                                                </div>
                                                <div class="bp3-rectanglecopy3">
                                                </div>
                                                <div class="bp3-rectanglecopy4">
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </a>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card3-onwA", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp3-card1hover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp3-card1hover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp3-card1hover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                        <style>
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card2-6AGh * {
                                box-sizing          : border-box;
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card2-6AGh {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 265px;
                                height              : 393px;
                                width               : 555px;
                                position            : absolute;
                                margin              : 0;
                                left                : 577px;
                                transform           : rotate(0deg);
                                transition          : all 0.2s ease-in-out;
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card2-6AGh .bp3-card11 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 2.54%;
                                height              : 88.30%;
                                width               : 95.50%;
                                position            : absolute;
                                margin              : 0;
                                left                : 2.25%;
                                border-radius       : 6px;
                                overflow            : hidden;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card2-6AGh .bp3-card11 .bp3-mask {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 99.81%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 6px;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card2-6AGh .bp3-card11 .bp3-screenshot20200423at83825pm {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : -40px;
                                height              : 399px;
                                width               : 748px;
                                position            : absolute;
                                margin              : 0;
                                left                : -110px;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card2-6AGh .bp3-card1hover {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : -0.51%;
                                height              : 100%;
                                width               : 98.02%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.99%;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card2-6AGh .bp3-card1hover .bp3-card1hover1 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                right               : 1.10%;
                                top                 : 2.04%;
                                height              : 88.30%;
                                width               : 97.43%;
                                position            : absolute;
                                margin              : 0;
                                border-radius       : 6px;
                                overflow            : hidden;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card2-6AGh .bp3-card1hover .bp3-card1hover1 .bp3-mask1 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 99.81%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 6px;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card2-6AGh .bp3-card1hover .bp3-card1hover1 .bp3-screenshot20200423at83825pm {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : -40px;
                                height              : 399px;
                                width               : 748px;
                                position            : absolute;
                                margin              : 0;
                                left                : -110px;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card2-6AGh .bp3-card1hover .bp3-card1hover1 .bp3-mask {
                                background-color    : rgba(0, 0, 0, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 99.81%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 6px;
                                transform           : rotate(0deg);
                                opacity             : 0.77;
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card2-6AGh .bp3-card1hover .bp3-card1hover1 .bp3-sslrpfooddeals {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 40.63%;
                                height              : 38px;
                                width               : 37.17%;
                                position            : absolute;
                                margin              : 0;
                                left                : 31.42%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Bold", Helvetica, Arial, serif;
                                font-size           : 37.8px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.73px;
                                line-height         : 47.0px;
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card2-6AGh .bp3-card1hover .bp3-card1hover1 .bp3-productdesign {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 40.35%;
                                height              : 21px;
                                width               : 29.81%;
                                position            : absolute;
                                margin              : 0;
                                left                : 34.91%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 20.16px;
                                color               : rgba(201, 201, 201, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.39px;
                                line-height         : 25.0px;
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card2-6AGh .bp3-card1hover .bp3-bluebox {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card2-6AGh .bp3-card1hover .bp3-bluebox .bp3-pixels {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 0px;
                                height              : 6.62%;
                                width               : 20.04%;
                                position            : absolute;
                                margin              : 0;
                                left                : 39.98%;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card2-6AGh .bp3-card1hover .bp3-bluebox .bp3-pixels .bp3-rectangle1 {
                                background-color    : rgba(59, 172, 247, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 1px;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card2-6AGh .bp3-card1hover .bp3-bluebox .bp3-pixels .bp3-a665x429 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 7px);
                                height              : 13px;
                                width               : 51.38%;
                                position            : absolute;
                                margin              : 0;
                                left                : 24.31%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 12.6px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : center;
                                letter-spacing      : 0.24px;
                                line-height         : 16.0px;
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card2-6AGh .bp3-card1hover .bp3-bluebox .bp3-outline {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 91.86%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card2-6AGh .bp3-card1hover .bp3-bluebox .bp3-outline .bp3-rectangle2 {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 1.11%;
                                height              : 97.23%;
                                box-sizing          : border-box;
                                width               : 97.98%;
                                position            : absolute;
                                margin              : 0;
                                left                : 1.01%;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card2-6AGh .bp3-card1hover .bp3-bluebox .bp3-outline .bp3-rectangle3 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                top                 : 0.28%;
                                height              : 3.32%;
                                box-sizing          : border-box;
                                width               : 2.02%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.37%;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card2-6AGh .bp3-card1hover .bp3-bluebox .bp3-outline .bp3-rectanglecopy2 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                bottom              : 0px;
                                height              : 3.05%;
                                box-sizing          : border-box;
                                width               : 2.02%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card2-6AGh .bp3-card1hover .bp3-bluebox .bp3-outline .bp3-rectanglecopy3 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                right               : 0px;
                                bottom              : 0px;
                                height              : 3.05%;
                                box-sizing          : border-box;
                                width               : 2.21%;
                                position            : absolute;
                                margin              : 0;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card2-6AGh .bp3-card1hover .bp3-bluebox .bp3-outline .bp3-rectanglecopy4 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                right               : 0px;
                                top                 : 0px;
                                height              : 3.05%;
                                box-sizing          : border-box;
                                width               : 2.21%;
                                position            : absolute;
                                margin              : 0;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                        </style>
                        <div id="8nBTqVB">
                            <a href="designco.html">
                                <div class="bp3-card2 bp3-card2-6AGh component anima-component-wrapper anima-not-ready anima-word-break anima-smart-layers-pointers state1" data-initial-state="state1">
                                    <div class="bp3-card11">
                                        <div class="bp3-mask">
                                        </div>
                                        <img alt="Image" class="bp3-screenshot20200423at83825pm" src="./img/web-1280-home-screen-shot-2020-04-23-at-83825-pm-1.png"/>
                                    </div>
                                    <div class="bp3-card1hover anima-hidden ">
                                        <div class="bp3-card1hover1">
                                            <div class="bp3-mask1">
                                            </div>
                                            <img alt="Image" class="bp3-screenshot20200423at83825pm" src="./img/web-1280-home-screen-shot-2020-04-23-at-83825-pm-1.png"/>
                                            <div class="bp3-mask">
                                            </div>
                                            <div class="bp3-sslrpfooddeals">
                                                Design Co
                                            </div>
                                            <div class="bp3-productdesign">
                                                Student Leader
                                            </div>
                                        </div>
                                        <div class="bp3-bluebox">
                                            <div class="bp3-pixels">
                                                <div class="bp3-rectangle1">
                                                </div>
                                                <div class="bp3-a665x429">
                                                    PRESENT
                                                </div>
                                            </div>
                                            <div class="bp3-outline">
                                                <div class="bp3-rectangle2">
                                                </div>
                                                <div class="bp3-rectangle3">
                                                </div>
                                                <div class="bp3-rectanglecopy2">
                                                </div>
                                                <div class="bp3-rectanglecopy3">
                                                </div>
                                                <div class="bp3-rectanglecopy4">
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </a>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card2-6AGh", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp3-card1hover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp3-card1hover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp3-card1hover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                        <style>
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card1-Qt1p * {
                                box-sizing          : border-box;
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card1-Qt1p {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 265px;
                                height              : 393px;
                                width               : 556px;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                                transition          : all 0.2s ease-in-out;
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card1-Qt1p .bp3-card11 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 2.54%;
                                height              : 88.30%;
                                width               : 95.32%;
                                position            : absolute;
                                margin              : 0;
                                left                : 2.34%;
                                border-radius       : 6px;
                                overflow            : hidden;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card1-Qt1p .bp3-card11 .bp3-mask {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 99.81%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 6px;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card1-Qt1p .bp3-card11 .bp3-rotatosnapshot {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 347px;
                                width               : 616px;
                                position            : absolute;
                                margin              : 0;
                                left                : -43px;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card1-Qt1p .bp3-card1hover {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : -0.51%;
                                height              : 100%;
                                width               : 97.84%;
                                position            : absolute;
                                margin              : 0;
                                left                : 1.08%;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card1-Qt1p .bp3-card1hover .bp3-card1hover1 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 2.04%;
                                height              : 88.30%;
                                width               : 97.43%;
                                position            : absolute;
                                margin              : 0;
                                left                : 1.29%;
                                border-radius       : 6px;
                                overflow            : hidden;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card1-Qt1p .bp3-card1hover .bp3-card1hover1 .bp3-mask1 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 99.81%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 6px;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card1-Qt1p .bp3-card1hover .bp3-card1hover1 .bp3-rotatosnapshot1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 347px;
                                width               : 616px;
                                position            : absolute;
                                margin              : 0;
                                left                : -43px;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card1-Qt1p .bp3-card1hover .bp3-card1hover1 .bp3-mask {
                                background-color    : rgba(0, 0, 0, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 99.81%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 6px;
                                transform           : rotate(0deg);
                                opacity             : 0.77;
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card1-Qt1p .bp3-card1hover .bp3-card1hover1 .bp3-sslrpfooddeals {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 40.63%;
                                height              : 38px;
                                width               : 44.72%;
                                position            : absolute;
                                margin              : 0;
                                left                : 27.64%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Bold", Helvetica, Arial, serif;
                                font-size           : 37.8px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.73px;
                                line-height         : 47.0px;
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card1-Qt1p .bp3-card1hover .bp3-card1hover1 .bp3-productdesign {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 40.35%;
                                height              : 21px;
                                width               : 29.81%;
                                position            : absolute;
                                margin              : 0;
                                left                : 35.09%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 20.16px;
                                color               : rgba(201, 201, 201, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.39px;
                                line-height         : 25.0px;
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card1-Qt1p .bp3-card1hover .bp3-bluebox {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card1-Qt1p .bp3-card1hover .bp3-bluebox .bp3-pixels {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 0px;
                                height              : 6.62%;
                                width               : 20.04%;
                                position            : absolute;
                                margin              : 0;
                                left                : 39.98%;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card1-Qt1p .bp3-card1hover .bp3-bluebox .bp3-pixels .bp3-rectangle1 {
                                background-color    : rgba(59, 172, 247, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 1px;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card1-Qt1p .bp3-card1hover .bp3-bluebox .bp3-pixels .bp3-a665x429 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 7px);
                                height              : 13px;
                                width               : 60.55%;
                                position            : absolute;
                                margin              : 0;
                                left                : 19.72%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 12.6px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : center;
                                letter-spacing      : 0.24px;
                                line-height         : 16.0px;
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card1-Qt1p .bp3-card1hover .bp3-bluebox .bp3-outline {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 91.86%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card1-Qt1p .bp3-card1hover .bp3-bluebox .bp3-outline .bp3-rectangle2 {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 1.11%;
                                height              : 97.23%;
                                box-sizing          : border-box;
                                width               : 98.16%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.92%;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card1-Qt1p .bp3-card1hover .bp3-bluebox .bp3-outline .bp3-rectangle3 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                top                 : 0.28%;
                                height              : 3.32%;
                                box-sizing          : border-box;
                                width               : 2.21%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card1-Qt1p .bp3-card1hover .bp3-bluebox .bp3-outline .bp3-rectanglecopy2 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                bottom              : 0px;
                                height              : 3.05%;
                                box-sizing          : border-box;
                                width               : 2.02%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card1-Qt1p .bp3-card1hover .bp3-bluebox .bp3-outline .bp3-rectanglecopy3 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                right               : 0px;
                                bottom              : 0px;
                                height              : 3.05%;
                                box-sizing          : border-box;
                                width               : 2.21%;
                                position            : absolute;
                                margin              : 0;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card1-Qt1p .bp3-card1hover .bp3-bluebox .bp3-outline .bp3-rectanglecopy4 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                right               : 0px;
                                top                 : 0px;
                                height              : 3.05%;
                                box-sizing          : border-box;
                                width               : 2.21%;
                                position            : absolute;
                                margin              : 0;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                        </style>
                        <div id="3MMuZ26">
                            <a href="sslrpdeals.html">
                                <div class="bp3-card1 bp3-card1-Qt1p component anima-component-wrapper anima-not-ready anima-word-break anima-smart-layers-pointers state1" data-initial-state="state1">
                                    <div class="bp3-card11">
                                        <div class="bp3-mask">
                                        </div>
                                        <img alt="Image" class="bp3-rotatosnapshot" src="./img/web-1280-home-rotato-snapshot-1.png"/>
                                    </div>
                                    <div class="bp3-card1hover anima-hidden ">
                                        <div class="bp3-card1hover1">
                                            <div class="bp3-mask1">
                                            </div>
                                            <img alt="Image" class="bp3-rotatosnapshot1" src="./img/web-1280-home-rotato-snapshot-1.png"/>
                                            <div class="bp3-mask">
                                            </div>
                                            <div class="bp3-sslrpfooddeals">
                                                SSLRP Deals
                                            </div>
                                            <div class="bp3-productdesign">
                                                Product Design
                                            </div>
                                        </div>
                                        <div class="bp3-bluebox">
                                            <div class="bp3-pixels">
                                                <div class="bp3-rectangle1">
                                                </div>
                                                <div class="bp3-a665x429">
                                                    FEB x 2019
                                                </div>
                                            </div>
                                            <div class="bp3-outline">
                                                <div class="bp3-rectangle2">
                                                </div>
                                                <div class="bp3-rectangle3">
                                                </div>
                                                <div class="bp3-rectanglecopy2">
                                                </div>
                                                <div class="bp3-rectanglecopy3">
                                                </div>
                                                <div class="bp3-rectanglecopy4">
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </a>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp3-web1280home .bp3-sectionwork .bp3-workcontent .bp3-card1-Qt1p", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp3-card1hover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp3-card1hover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp3-card1hover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                        <div class="bp3-text">
                            <div anima-show-on-scroll="" class="bp3-h2">
                                Crafted with intention. Bringing all attention.
                            </div>
                            <div anima-show-on-scroll="" class="bp3-h1">
                                Embarking on a Journey through Pixels.
                            </div>
                            <div anima-show-on-scroll="" class="bp3-h3">
                                WORK
                            </div>
                        </div>
                    </div>
                </div>
                <div class="bp3-sectionfooter">
                    <img alt="Image" anima-src="./img/web-1280-designco-bg.png" class="bp3-bg" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                    <div class="bp3-footer">
                        <div class="bp3-socialicons">
                            <style>
                                .bp3-web1280home .bp3-sectionfooter .bp3-footer .bp3-socialicons .bp3-dribbble-UvB7 * {
                                    box-sizing          : border-box;
                                }
                                .bp3-web1280home .bp3-sectionfooter .bp3-footer .bp3-socialicons .bp3-dribbble-UvB7 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 41px;
                                    width               : 41px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 80px;
                                    transform           : rotate(0deg);
                                }
                                .bp3-web1280home .bp3-sectionfooter .bp3-footer .bp3-socialicons .bp3-dribbble-UvB7 .bp3-shape {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 97.56%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 1.22%;
                                    transform           : rotate(0deg);
                                }
                                .bp3-web1280home .bp3-sectionfooter .bp3-footer .bp3-socialicons .bp3-dribbble-UvB7 .bp3-shapehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 97.56%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 1.22%;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                }
                            </style>
                            <div id="zBTYCd3">
                                <a href="https://dribbble.com/syedadam007" target="_blank">
                                    <div class="bp3-dribbble bp3-dribbble-UvB7 component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <img alt="Image" class="bp3-shape" src="./img/web-1280-playground-shape@2x.png"/>
                                        <img alt="Image" class="bp3-shapehover anima-hidden " src="./img/web-1280-sslrpdeals-shapehover@2x.png"/>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp3-web1280home .bp3-sectionfooter .bp3-footer .bp3-socialicons .bp3-dribbble-UvB7", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp3-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp3-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp3-shapehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <style>
                                .bp3-web1280home .bp3-sectionfooter .bp3-footer .bp3-socialicons .bp3-linkedin-XDET * {
                                    box-sizing          : border-box;
                                }
                                .bp3-web1280home .bp3-sectionfooter .bp3-footer .bp3-socialicons .bp3-linkedin-XDET {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 41px;
                                    width               : 41px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .bp3-web1280home .bp3-sectionfooter .bp3-footer .bp3-socialicons .bp3-linkedin-XDET .bp3-shape {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 97.56%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 1.22%;
                                    transform           : rotate(0deg);
                                }
                                .bp3-web1280home .bp3-sectionfooter .bp3-footer .bp3-socialicons .bp3-linkedin-XDET .bp3-shapehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 97.56%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 1.22%;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                }
                            </style>
                            <div id="IKDQuSl">
                                <a href="https://www.linkedin.com/in/syedadamemirputra/" target="_blank">
                                    <div class="bp3-linkedin bp3-linkedin-XDET component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <img alt="Image" class="bp3-shape" src="./img/web-1280-swiftrides-shape-3@2x.png"/>
                                        <img alt="Image" class="bp3-shapehover anima-hidden " src="./img/web-1280-playground-shapehover-1@2x.png"/>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp3-web1280home .bp3-sectionfooter .bp3-footer .bp3-socialicons .bp3-linkedin-XDET", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp3-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp3-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp3-shapehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <style>
                                .bp3-web1280home .bp3-sectionfooter .bp3-footer .bp3-socialicons .bp3-instagram-LP20 * {
                                    box-sizing          : border-box;
                                }
                                .bp3-web1280home .bp3-sectionfooter .bp3-footer .bp3-socialicons .bp3-instagram-LP20 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 1px;
                                    height              : 40px;
                                    width               : 41px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 160px;
                                    transform           : rotate(0deg);
                                }
                                .bp3-web1280home .bp3-sectionfooter .bp3-footer .bp3-socialicons .bp3-instagram-LP20 .bp3-shape {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 97.56%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 1.22%;
                                    transform           : rotate(0deg);
                                }
                                .bp3-web1280home .bp3-sectionfooter .bp3-footer .bp3-socialicons .bp3-instagram-LP20 .bp3-shapehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 97.56%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 1.22%;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                }
                            </style>
                            <div id="6olg00p">
                                <a href="https://www.instagram.com/syedadam007/" target="_blank">
                                    <div class="bp3-instagram bp3-instagram-LP20 component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <img alt="Image" class="bp3-shape" src="./img/web-1280-designco-shape-4@2x.png"/>
                                        <img alt="Image" class="bp3-shapehover anima-hidden " src="./img/web-1280-home-shapehover-2@2x.png"/>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp3-web1280home .bp3-sectionfooter .bp3-footer .bp3-socialicons .bp3-instagram-LP20", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp3-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp3-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp3-shapehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                        </div>
                        <div anima-show-on-scroll="" class="bp3-h3">
                            Â© 2020 Lil Adam X
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="bp4-ipadpro129home anima-word-break ">
            <div style="width: 1024px; height: 100%; position:relative; margin:auto;">
                <div class="bp4-sectionhero" id="None">
                    <div class="bp4-darkbg">
                    </div>
                    <div class="bp4-content">
                        <div anima-show-on-scroll="" class="bp4-mission">
                            Adam designs because the world ainâ€™t right. <br />Demystifying the ways the world should be.
                        </div>
                        <div class="bp4-present">
                            Present
                        </div>
                        <style>
                            .bp4-ipadpro129home .bp4-sectionhero .bp4-content .bp4-designco-erX4 * {
                                box-sizing          : border-box;
                            }
                            .bp4-ipadpro129home .bp4-sectionhero .bp4-content .bp4-designco-erX4 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 175px;
                                height              : 17px;
                                width               : 84px;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionhero .bp4-content .bp4-designco-erX4 .bp4-designco1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 8px);
                                height              : 16px;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 16.13px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.31px;
                                line-height         : 19.0px;
                            }
                            .bp4-ipadpro129home .bp4-sectionhero .bp4-content .bp4-designco-erX4 .bp4-designcohover {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 8px);
                                height              : 16px;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 16.13px;
                                color               : rgba(146, 146, 146, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.31px;
                                line-height         : 19.0px;
                            }
                        </style>
                        <div id="iFWBsZ0">
                            <div class="bp4-designco bp4-designco-erX4 component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                <a href="http://www.ucsddesign.co/" target="_blank">
                                    <div class="bp4-designco1">
                                        Design Co
                                    </div>
                                </a>
                                <a href="http://www.ucsddesign.co/" target="_blank">
                                    <div class="bp4-designcohover anima-hidden ">
                                        Design Co
                                    </div>
                                </a>
                            </div>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp4-ipadpro129home .bp4-sectionhero .bp4-content .bp4-designco-erX4", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp4-designcohover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp4-designcohover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp4-designcohover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                        <div class="bp4-education">
                            Education
                        </div>
                        <style>
                            .bp4-ipadpro129home .bp4-sectionhero .bp4-content .bp4-ucsd-R9Tq * {
                                box-sizing          : border-box;
                            }
                            .bp4-ipadpro129home .bp4-sectionhero .bp4-content .bp4-ucsd-R9Tq {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 261px;
                                height              : 17px;
                                width               : 115px;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionhero .bp4-content .bp4-ucsd-R9Tq .bp4-ucsd1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 8px);
                                height              : 16px;
                                width               : 99.13%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.43%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 16.13px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.31px;
                                line-height         : 19.0px;
                            }
                            .bp4-ipadpro129home .bp4-sectionhero .bp4-content .bp4-ucsd-R9Tq .bp4-ucsdhover {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 8px);
                                height              : 16px;
                                width               : 99.13%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.43%;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 16.13px;
                                color               : rgba(146, 146, 146, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.31px;
                                line-height         : 19.0px;
                            }
                        </style>
                        <div id="vUCjxLW">
                            <div class="bp4-ucsd bp4-ucsd-R9Tq component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                <a href="https://ucsd.edu/" target="_blank">
                                    <div class="bp4-ucsd1">
                                        UC San Diego
                                    </div>
                                </a>
                                <a href="https://ucsd.edu/" target="_blank">
                                    <div class="bp4-ucsdhover anima-hidden ">
                                        UC San Diego
                                    </div>
                                </a>
                            </div>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp4-ipadpro129home .bp4-sectionhero .bp4-content .bp4-ucsd-R9Tq", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp4-ucsdhover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp4-ucsdhover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp4-ucsdhover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                        <div class="bp4-previous">
                            Previous
                        </div>
                        <style>
                            .bp4-ipadpro129home .bp4-sectionhero .bp4-content .bp4-longstorystudios-lk6n * {
                                box-sizing          : border-box;
                            }
                            .bp4-ipadpro129home .bp4-sectionhero .bp4-content .bp4-longstorystudios-lk6n {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 175px;
                                height              : 17px;
                                width               : 153px;
                                position            : absolute;
                                margin              : 0;
                                left                : 297px;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionhero .bp4-content .bp4-longstorystudios-lk6n .bp4-ls {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 8px);
                                height              : 16px;
                                width               : 99.35%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.33%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 16.13px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.31px;
                                line-height         : 19.0px;
                            }
                            .bp4-ipadpro129home .bp4-sectionhero .bp4-content .bp4-longstorystudios-lk6n .bp4-lshover {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 8px);
                                height              : 16px;
                                width               : 99.35%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.33%;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 16.13px;
                                color               : rgba(146, 146, 146, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.31px;
                                line-height         : 19.0px;
                            }
                        </style>
                        <div id="kyspCNA">
                            <div class="bp4-longstorystudios bp4-longstorystudios-lk6n component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                <a href="https://www.longstorystudios.com/" target="_blank">
                                    <div class="bp4-ls">
                                        Long Story Studios
                                    </div>
                                </a>
                                <a href="https://www.longstorystudios.com/" target="_blank">
                                    <div class="bp4-lshover anima-hidden ">
                                        Long Story Studios
                                    </div>
                                </a>
                            </div>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp4-ipadpro129home .bp4-sectionhero .bp4-content .bp4-longstorystudios-lk6n", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp4-lshover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp4-lshover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp4-lshover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                    </div>
                    <div class="bp4-lightsaber">
                        <div class="bp4-lightsaberoff">
                            <div class="bp4-lightsaberoff1">
                                <div class="bp4-rectangle">
                                </div>
                                <div class="bp4-rectangle1">
                                </div>
                                <div class="bp4-rectangle2">
                                </div>
                                <div class="bp4-rectangle3">
                                </div>
                                <div class="bp4-rectangle4">
                                </div>
                                <img alt="Image" anima-src="./img/ipad-about-shape-1@2x.png" class="bp4-shape" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                                <div class="bp4-rectangle5">
                                </div>
                                <div class="bp4-rectangle6">
                                </div>
                                <div class="bp4-rectangle7">
                                </div>
                                <div class="bp4-rectangle8">
                                </div>
                                <div class="bp4-rectangle9">
                                </div>
                                <img alt="Image" anima-src="./img/ipad-pro-129-home-path@2x.png" class="bp4-path" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                                <img alt="Image" anima-src="./img/ipad-pro-129-home-path-1@2x.png" class="bp4-path1" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                                <div class="bp4-rectangle10">
                                </div>
                                <div class="bp4-rectangle11">
                                </div>
                                <div class="bp4-rectangle12">
                                </div>
                                <div class="bp4-rectangle13">
                                </div>
                            </div>
                            <a href="playground.html">
                                <div class="bp4-playground">
                                    <div class="bp4-rectangle">
                                    </div>
                                    <div class="bp4-playground1">
                                        Playground
                                    </div>
                                </div>
                            </a>
                        </div>
                        <div class="bp4-lightsaberon">
                            <div class="bp4-lightsaberon1">
                                <div class="bp4-group">
                                    <img alt="Image" anima-src="./img/ipad-pro-129-home-path-2@2x.png" class="bp4-path2" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                                    <img alt="Image" anima-src="./img/ipad-pro-129-home-path-3@2x.png" class="bp4-path11" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                                </div>
                                <div class="bp4-rectangle">
                                </div>
                                <div class="bp4-rectangle1">
                                </div>
                                <div class="bp4-rectangle2">
                                </div>
                                <div class="bp4-rectangle3">
                                </div>
                                <div class="bp4-rectangle4">
                                </div>
                                <img alt="Image" anima-src="./img/ipad-about-shape-1@2x.png" class="bp4-shape" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                                <div class="bp4-rectangle5">
                                </div>
                                <div class="bp4-rectangle6">
                                </div>
                                <div class="bp4-rectangle7">
                                </div>
                                <div class="bp4-rectangle8">
                                </div>
                                <div class="bp4-rectangle9">
                                </div>
                                <img alt="Image" anima-src="./img/ipad-pro-129-home-path@2x.png" class="bp4-path" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                                <img alt="Image" anima-src="./img/ipad-pro-129-home-path-1@2x.png" class="bp4-path1" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                                <div class="bp4-rectangle10">
                                </div>
                                <div class="bp4-rectangle11">
                                </div>
                                <div class="bp4-rectangle12">
                                </div>
                                <div class="bp4-rectangle13">
                                </div>
                            </div>
                            <a href="playground.html">
                                <div class="bp4-playground">
                                    <div class="bp4-rectangle">
                                    </div>
                                    <div class="bp4-playground1">
                                        Playground
                                    </div>
                                </div>
                            </a>
                        </div>
                    </div>
                    <div class="bp4-navbar">
                        <div class="bp4-rectangle">
                        </div>
                        <style>
                            .bp4-ipadpro129home .bp4-sectionhero .bp4-navbar .bp4-logo-9nj2 * {
                                box-sizing          : border-box;
                            }
                            .bp4-ipadpro129home .bp4-sectionhero .bp4-navbar .bp4-logo-9nj2 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 41px;
                                height              : 24px;
                                width               : 137px;
                                position            : absolute;
                                margin              : 0;
                                left                : 69px;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionhero .bp4-navbar .bp4-logo-9nj2 .bp4-adamoutline {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 99.27%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.36%;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionhero .bp4-navbar .bp4-logo-9nj2 .bp4-adamoutline .bp4-shape {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 2.08%;
                                height              : 95.83%;
                                width               : 82.35%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionhero .bp4-navbar .bp4-logo-9nj2 .bp4-adamoutline .bp4-path {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 0px;
                                top                 : 18.75%;
                                height              : 62.50%;
                                width               : 11.03%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionhero .bp4-navbar .bp4-logo-9nj2 .bp4-adamfill {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 2.08%;
                                height              : 95.83%;
                                width               : 98.54%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.73%;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                            }
                            .bp4-ipadpro129home .bp4-sectionhero .bp4-navbar .bp4-logo-9nj2 .bp4-adamfill .bp4-shape1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 2.17%;
                                height              : 95.65%;
                                width               : 81.48%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionhero .bp4-navbar .bp4-logo-9nj2 .bp4-adamfill .bp4-path1 {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 0px;
                                top                 : 15.22%;
                                height              : 69.57%;
                                width               : 11.11%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                        </style>
                        <div id="kyw2gh5">
                            <div class="bp4-logo bp4-logo-9nj2 component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                <div class="bp4-adamoutline">
                                    <img alt="Image" class="bp4-shape" src="./img/ipad-home-menu-hover-shape-4@2x.png"/>
                                    <img alt="Image" class="bp4-path" src="./img/ipad-home-menu-hover-path-6@2x.png"/>
                                </div>
                                <div class="bp4-adamfill anima-hidden ">
                                    <img alt="Image" class="bp4-shape1" src="./img/ipad-home-shape-3@2x.png"/>
                                    <img alt="Image" class="bp4-path1" src="./img/ipad-home-path-7@2x.png"/>
                                </div>
                            </div>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp4-ipadpro129home .bp4-sectionhero .bp4-navbar .bp4-logo-9nj2", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp4-adamfill": {
                "delay": 0, 
                "duration": 400, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp4-adamfill": {
                "delay": 0, 
                "duration": 500, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp4-adamfill": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                        <div class="bp4-navbar1">
                            <style>
                                .bp4-ipadpro129home .bp4-sectionhero .bp4-navbar .bp4-navbar1 .bp4-resume-BHVu * {
                                    box-sizing          : border-box;
                                }
                                .bp4-ipadpro129home .bp4-sectionhero .bp4-navbar .bp4-navbar1 .bp4-resume-BHVu {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 21px;
                                    width               : 70px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 303px;
                                    transform           : rotate(0deg);
                                }
                                .bp4-ipadpro129home .bp4-sectionhero .bp4-navbar .bp4-navbar1 .bp4-resume-BHVu .bp4-resume1 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 10px);
                                    height              : 20px;
                                    width               : 98.57%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0.71%;
                                    transform           : rotate(0deg);
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 15.12px;
                                    color               : rgba(126, 126, 126, 1.0);
                                    text-align          : center;
                                    letter-spacing      : 0.42px;
                                    line-height         : 18.0px;
                                }
                                .bp4-ipadpro129home .bp4-sectionhero .bp4-navbar .bp4-navbar1 .bp4-resume-BHVu .bp4-resumehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 10px);
                                    height              : 20px;
                                    width               : 98.57%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0.71%;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 15.12px;
                                    color               : rgba(31, 208, 118, 1.0);
                                    text-align          : center;
                                    letter-spacing      : 0.42px;
                                    line-height         : 18.0px;
                                }
                            </style>
                            <div id="kI6kU6c">
                                <a href="https://drive.google.com/file/d/1KxPEStKpGkBtJaURrrckkRjVntkcITWU/view?usp=sharing" target="_blank">
                                    <div class="bp4-resume bp4-resume-BHVu component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <div class="bp4-resume1 anima-valign-text-middle">
                                            Resume
                                        </div>
                                        <div class="bp4-resumehover anima-valign-text-middle anima-hidden ">
                                            Resume
                                        </div>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp4-ipadpro129home .bp4-sectionhero .bp4-navbar .bp4-navbar1 .bp4-resume-BHVu", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp4-resumehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp4-resumehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp4-resumehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <style>
                                .bp4-ipadpro129home .bp4-sectionhero .bp4-navbar .bp4-navbar1 .bp4-about-adUl * {
                                    box-sizing          : border-box;
                                }
                                .bp4-ipadpro129home .bp4-sectionhero .bp4-navbar .bp4-navbar1 .bp4-about-adUl {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 21px;
                                    width               : 70px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 202px;
                                    transform           : rotate(0deg);
                                }
                                .bp4-ipadpro129home .bp4-sectionhero .bp4-navbar .bp4-navbar1 .bp4-about-adUl .bp4-about1 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 10px);
                                    height              : 20px;
                                    width               : 98.57%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0.71%;
                                    transform           : rotate(0deg);
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 15.12px;
                                    color               : rgba(126, 126, 126, 1.0);
                                    text-align          : center;
                                    letter-spacing      : 0.42px;
                                    line-height         : 18.0px;
                                }
                                .bp4-ipadpro129home .bp4-sectionhero .bp4-navbar .bp4-navbar1 .bp4-about-adUl .bp4-abouthover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 10px);
                                    height              : 20px;
                                    width               : 98.57%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0.71%;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 15.12px;
                                    color               : rgba(214, 214, 214, 1.0);
                                    text-align          : center;
                                    letter-spacing      : 0.42px;
                                    line-height         : 18.0px;
                                }
                            </style>
                            <div id="J5H2Mav">
                                <a href="about.html">
                                    <div class="bp4-about bp4-about-adUl component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <div class="bp4-about1 anima-valign-text-middle">
                                            About
                                        </div>
                                        <div class="bp4-abouthover anima-valign-text-middle anima-hidden ">
                                            About
                                        </div>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp4-ipadpro129home .bp4-sectionhero .bp4-navbar .bp4-navbar1 .bp4-about-adUl", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp4-abouthover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp4-abouthover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp4-abouthover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <style>
                                .bp4-ipadpro129home .bp4-sectionhero .bp4-navbar .bp4-navbar1 .bp4-work-si1z * {
                                    box-sizing          : border-box;
                                }
                                .bp4-ipadpro129home .bp4-sectionhero .bp4-navbar .bp4-navbar1 .bp4-work-si1z {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 21px;
                                    width               : 70px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 101px;
                                    transform           : rotate(0deg);
                                }
                                .bp4-ipadpro129home .bp4-sectionhero .bp4-navbar .bp4-navbar1 .bp4-work-si1z .bp4-work1 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 10px);
                                    height              : 20px;
                                    width               : 98.57%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0.71%;
                                    transform           : rotate(0deg);
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 15.12px;
                                    color               : rgba(126, 126, 126, 1.0);
                                    text-align          : center;
                                    letter-spacing      : 0.42px;
                                    line-height         : 18.0px;
                                }
                                .bp4-ipadpro129home .bp4-sectionhero .bp4-navbar .bp4-navbar1 .bp4-work-si1z .bp4-workhover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 10px);
                                    height              : 20px;
                                    width               : 98.57%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0.71%;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 15.12px;
                                    color               : rgba(215, 215, 215, 1.0);
                                    text-align          : center;
                                    letter-spacing      : 0.42px;
                                    line-height         : 18.0px;
                                }
                            </style>
                            <div id="yZZp9CT">
                                <a href="work.html">
                                </a>
                                <div class="bp4-work bp4-work-si1z component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                    <a href="work.html">
                                    </a>
                                    <a href="work.html">
                                        <div class="bp4-work1 anima-valign-text-middle">
                                            Work
                                        </div>
                                    </a>
                                    <a href="work.html">
                                        <div class="bp4-workhover anima-valign-text-middle anima-hidden ">
                                            Work
                                        </div>
                                    </a>
                                </div>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp4-ipadpro129home .bp4-sectionhero .bp4-navbar .bp4-navbar1 .bp4-work-si1z", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp4-workhover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp4-workhover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ".bp4-work1"
          }
        ], 
        "overrides": {
          ".bp4-workhover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <style>
                                .bp4-ipadpro129home .bp4-sectionhero .bp4-navbar .bp4-navbar1 .bp4-home-sLkx * {
                                    box-sizing          : border-box;
                                }
                                .bp4-ipadpro129home .bp4-sectionhero .bp4-navbar .bp4-navbar1 .bp4-home-sLkx {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 21px;
                                    width               : 70px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .bp4-ipadpro129home .bp4-sectionhero .bp4-navbar .bp4-navbar1 .bp4-home-sLkx .bp4-home1 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 10px);
                                    height              : 20px;
                                    width               : 98.57%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0.71%;
                                    transform           : rotate(0deg);
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 15.12px;
                                    color               : rgba(255, 255, 255, 1.0);
                                    text-align          : center;
                                    letter-spacing      : 0.42px;
                                    line-height         : 18.0px;
                                }
                                .bp4-ipadpro129home .bp4-sectionhero .bp4-navbar .bp4-navbar1 .bp4-home-sLkx .bp4-homehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 10px);
                                    height              : 20px;
                                    width               : 98.57%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0.71%;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 15.12px;
                                    color               : rgba(146, 146, 146, 1.0);
                                    text-align          : center;
                                    letter-spacing      : 0.42px;
                                    line-height         : 18.0px;
                                }
                            </style>
                            <div id="MmO1TSz">
                                <div class="bp4-home bp4-home-sLkx component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                    <div class="bp4-home1 anima-valign-text-middle">
                                        Home
                                    </div>
                                    <div class="bp4-homehover anima-valign-text-middle anima-hidden ">
                                        Home
                                    </div>
                                </div>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp4-ipadpro129home .bp4-sectionhero .bp4-navbar .bp4-navbar1 .bp4-home-sLkx", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp4-homehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp4-homehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp4-homehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                        </div>
                    </div>
                </div>
                <div class="bp4-sectionwork">
                    <div class="bp4-workbg">
                    </div>
                    <div class="bp4-workcontent">
                        <style>
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card4-dhId * {
                                box-sizing          : border-box;
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card4-dhId {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 542px;
                                height              : 315px;
                                width               : 444px;
                                position            : absolute;
                                margin              : 0;
                                left                : 461px;
                                transform           : rotate(0deg);
                                transition          : all 0.2s ease-in-out;
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card4-dhId .bp4-card11 {
                                background-color    : rgba(248, 17, 34, 1.0);
                                top                 : 2.54%;
                                height              : 88.25%;
                                width               : 95.50%;
                                position            : absolute;
                                margin              : 0;
                                left                : 2.25%;
                                border-radius       : 5px;
                                overflow            : hidden;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card4-dhId .bp4-card11 .bp4-mask {
                                background-color    : rgba(248, 17, 34, 1.0);
                                top                 : 0px;
                                height              : 99.64%;
                                width               : 99.76%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 5px;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card4-dhId .bp4-card11 .bp4-adobesystemslogoandwordmark {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 27.52%;
                                height              : 44.96%;
                                width               : 33.25%;
                                position            : absolute;
                                margin              : 0;
                                left                : 33.37%;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card4-dhId .bp4-card11 .bp4-adobesystemslogoandwordmark .bp4-g4151 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : relative;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card4-dhId .bp4-card11 .bp4-adobesystemslogoandwordmark .bp4-g4151 .bp4-polygon15 {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 0.71%;
                                top                 : 0.40%;
                                height              : 99.20%;
                                width               : 36.88%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card4-dhId .bp4-card11 .bp4-adobesystemslogoandwordmark .bp4-g4151 .bp4-polygon17 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0.40%;
                                height              : 99.20%;
                                width               : 36.88%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card4-dhId .bp4-card11 .bp4-adobesystemslogoandwordmark .bp4-g4151 .bp4-polygon19 {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 26.95%;
                                bottom              : 0.80%;
                                height              : 62.40%;
                                width               : 39.72%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card4-dhId .bp4-card1hover {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : -0.63%;
                                height              : 100%;
                                width               : 97.97%;
                                position            : absolute;
                                margin              : 0;
                                left                : 1.01%;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card4-dhId .bp4-card1hover .bp4-card1hover1 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 1.90%;
                                height              : 88.25%;
                                width               : 97.47%;
                                position            : absolute;
                                margin              : 0;
                                left                : 1.26%;
                                border-radius       : 5px;
                                overflow            : hidden;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card4-dhId .bp4-card1hover .bp4-card1hover1 .bp4-mask1 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 0px;
                                height              : 99.64%;
                                width               : 99.76%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 5px;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card4-dhId .bp4-card1hover .bp4-card1hover1 .bp4-mask2 {
                                background-color    : rgba(248, 17, 34, 1.0);
                                top                 : 0px;
                                height              : 99.64%;
                                width               : 99.76%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 5px;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card4-dhId .bp4-card1hover .bp4-card1hover1 .bp4-adobesystemslogoandwordmark1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 27.52%;
                                height              : 44.96%;
                                width               : 33.25%;
                                position            : absolute;
                                margin              : 0;
                                left                : 33.37%;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card4-dhId .bp4-card1hover .bp4-card1hover1 .bp4-adobesystemslogoandwordmark1 .bp4-g41511 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : relative;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card4-dhId .bp4-card1hover .bp4-card1hover1 .bp4-adobesystemslogoandwordmark1 .bp4-g41511 .bp4-polygon151 {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 0.71%;
                                top                 : 0.40%;
                                height              : 99.20%;
                                width               : 36.88%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card4-dhId .bp4-card1hover .bp4-card1hover1 .bp4-adobesystemslogoandwordmark1 .bp4-g41511 .bp4-polygon171 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0.40%;
                                height              : 99.20%;
                                width               : 36.88%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card4-dhId .bp4-card1hover .bp4-card1hover1 .bp4-adobesystemslogoandwordmark1 .bp4-g41511 .bp4-polygon191 {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 26.95%;
                                bottom              : 0.80%;
                                height              : 62.40%;
                                width               : 39.72%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card4-dhId .bp4-card1hover .bp4-card1hover1 .bp4-maskcopy {
                                background-color    : rgba(0, 0, 0, 1.0);
                                top                 : 0px;
                                height              : 99.64%;
                                width               : 99.76%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 5px;
                                transform           : rotate(0deg);
                                opacity             : 0.77;
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card4-dhId .bp4-card1hover .bp4-card1hover1 .bp4-group2 {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 33.45%;
                                height              : 32.37%;
                                width               : 54.48%;
                                position            : absolute;
                                margin              : 0;
                                left                : 22.76%;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card4-dhId .bp4-card1hover .bp4-card1hover1 .bp4-group2 .bp4-sslrpfooddeals {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 60px;
                                width               : 99.57%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.22%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Bold", Helvetica, Arial, serif;
                                font-size           : 30.24px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : center;
                                letter-spacing      : 0.58px;
                                line-height         : 37.0px;
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card4-dhId .bp4-card1hover .bp4-card1hover1 .bp4-group2 .bp4-productdesign {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 1.11%;
                                height              : 16px;
                                width               : 54.55%;
                                position            : absolute;
                                margin              : 0;
                                left                : 22.73%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 16.13px;
                                color               : rgba(201, 201, 201, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.31px;
                                line-height         : 19.0px;
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card4-dhId .bp4-card1hover .bp4-bluebox {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card4-dhId .bp4-card1hover .bp4-bluebox .bp4-pixels {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 0px;
                                height              : 6.67%;
                                width               : 20.00%;
                                position            : absolute;
                                margin              : 0;
                                left                : 40.00%;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card4-dhId .bp4-card1hover .bp4-bluebox .bp4-pixels .bp4-rectangle1 {
                                background-color    : rgba(59, 172, 247, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 1px;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card4-dhId .bp4-card1hover .bp4-bluebox .bp4-pixels .bp4-a665x429 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 5px);
                                height              : 10px;
                                width               : 65.52%;
                                position            : absolute;
                                margin              : 0;
                                left                : 17.24%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 10.08px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : center;
                                letter-spacing      : 0.19px;
                                line-height         : 12.0px;
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card4-dhId .bp4-card1hover .bp4-bluebox .bp4-outline {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 92.06%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card4-dhId .bp4-card1hover .bp4-bluebox .bp4-outline .bp4-rectangle2 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 1.55%;
                                height              : 96.90%;
                                box-sizing          : border-box;
                                width               : 98.16%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.92%;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card4-dhId .bp4-card1hover .bp4-bluebox .bp4-outline .bp4-rectangle3 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                top                 : 0.34%;
                                height              : 3.45%;
                                box-sizing          : border-box;
                                width               : 2.07%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.23%;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card4-dhId .bp4-card1hover .bp4-bluebox .bp4-outline .bp4-rectanglecopy2 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                bottom              : 0px;
                                height              : 3.45%;
                                box-sizing          : border-box;
                                width               : 2.07%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card4-dhId .bp4-card1hover .bp4-bluebox .bp4-outline .bp4-rectanglecopy3 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                right               : 0px;
                                bottom              : 0px;
                                height              : 3.45%;
                                box-sizing          : border-box;
                                width               : 2.07%;
                                position            : absolute;
                                margin              : 0;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card4-dhId .bp4-card1hover .bp4-bluebox .bp4-outline .bp4-rectanglecopy4 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                right               : 0px;
                                top                 : 0px;
                                height              : 3.45%;
                                box-sizing          : border-box;
                                width               : 2.07%;
                                position            : absolute;
                                margin              : 0;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                        </style>
                        <div id="MToSkpx">
                            <a href="adobe.html">
                                <div class="bp4-card4 bp4-card4-dhId component anima-component-wrapper anima-not-ready anima-word-break anima-smart-layers-pointers state1" data-initial-state="state1">
                                    <div class="bp4-card11">
                                        <div class="bp4-mask">
                                        </div>
                                        <div class="bp4-adobesystemslogoandwordmark">
                                            <div class="bp4-g4151">
                                                <img alt="Image" class="bp4-polygon15" src="./img/ipad-pro-129-home-polygon15@2x.png"/>
                                                <img alt="Image" class="bp4-polygon17" src="./img/ipad-pro-129-home-polygon17@2x.png"/>
                                                <img alt="Image" class="bp4-polygon19" src="./img/ipad-pro-129-home-polygon19@2x.png"/>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="bp4-card1hover anima-hidden ">
                                        <div class="bp4-card1hover1">
                                            <div class="bp4-mask1">
                                            </div>
                                            <div class="bp4-mask2">
                                            </div>
                                            <div class="bp4-adobesystemslogoandwordmark1">
                                                <div class="bp4-g41511">
                                                    <img alt="Image" class="bp4-polygon151" src="./img/ipad-pro-129-home-polygon15@2x.png"/>
                                                    <img alt="Image" class="bp4-polygon171" src="./img/ipad-pro-129-home-polygon17@2x.png"/>
                                                    <img alt="Image" class="bp4-polygon191" src="./img/ipad-pro-129-home-polygon19@2x.png"/>
                                                </div>
                                            </div>
                                            <div class="bp4-maskcopy">
                                            </div>
                                            <div class="bp4-group2">
                                                <div class="bp4-sslrpfooddeals">
                                                    Adobe x The Ocean Agency
                                                </div>
                                                <div class="bp4-productdesign">
                                                    Product Design
                                                </div>
                                            </div>
                                        </div>
                                        <div class="bp4-bluebox">
                                            <div class="bp4-pixels">
                                                <div class="bp4-rectangle1">
                                                </div>
                                                <div class="bp4-a665x429">
                                                    APR x 2020
                                                </div>
                                            </div>
                                            <div class="bp4-outline">
                                                <div class="bp4-rectangle2">
                                                </div>
                                                <div class="bp4-rectangle3">
                                                </div>
                                                <div class="bp4-rectanglecopy2">
                                                </div>
                                                <div class="bp4-rectanglecopy3">
                                                </div>
                                                <div class="bp4-rectanglecopy4">
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </a>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card4-dhId", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp4-card1hover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp4-card1hover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp4-card1hover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                        <style>
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card3-czy5 * {
                                box-sizing          : border-box;
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card3-czy5 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 542px;
                                height              : 315px;
                                width               : 443px;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                                transition          : all 0.2s ease-in-out;
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card3-czy5 .bp4-card11 {
                                background-color    : rgba(97, 0, 238, 1.0);
                                top                 : 2.54%;
                                height              : 88.25%;
                                width               : 95.71%;
                                position            : absolute;
                                margin              : 0;
                                left                : 2.14%;
                                border-radius       : 5px;
                                overflow            : hidden;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card3-czy5 .bp4-card11 .bp4-mask {
                                background-color    : rgba(97, 0, 238, 1.0);
                                top                 : 0px;
                                height              : 99.64%;
                                width               : 99.76%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 5px;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card3-czy5 .bp4-card11 .bp4-rectangle {
                                background-color    : rgba(98, 0, 238, 1.0);
                                top                 : 0px;
                                height              : 100.36%;
                                width               : 99.76%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card3-czy5 .bp4-card11 .bp4-swift {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 20px;
                                height              : 243px;
                                width               : 380px;
                                position            : absolute;
                                margin              : 0;
                                left                : 22px;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card3-czy5 .bp4-card1hover {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : -0.63%;
                                height              : 100%;
                                width               : 98.19%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.90%;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card3-czy5 .bp4-card1hover .bp4-card1hover1 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 1.90%;
                                height              : 88.25%;
                                width               : 97.70%;
                                position            : absolute;
                                margin              : 0;
                                left                : 1.15%;
                                border-radius       : 5px;
                                overflow            : hidden;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card3-czy5 .bp4-card1hover .bp4-card1hover1 .bp4-mask1 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 0px;
                                height              : 99.64%;
                                width               : 99.53%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.24%;
                                border-radius       : 5px;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card3-czy5 .bp4-card1hover .bp4-card1hover1 .bp4-rectangle {
                                background-color    : rgba(97, 0, 238, 1.0);
                                top                 : -0.72%;
                                height              : 100.72%;
                                box-sizing          : border-box;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-style        : solid;
                                border-width        : 0px;
                                border-color        : rgba(150, 150, 150, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card3-czy5 .bp4-card1hover .bp4-card1hover1 .bp4-swift {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 13.88%;
                                bottom              : 13.67%;
                                height              : 70.50%;
                                width               : 71.76%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card3-czy5 .bp4-card1hover .bp4-card1hover1 .bp4-swift .bp4-swift1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card3-czy5 .bp4-card1hover .bp4-card1hover1 .bp4-mask {
                                background-color    : rgba(0, 0, 0, 1.0);
                                top                 : 0px;
                                height              : 99.64%;
                                width               : 99.53%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.24%;
                                border-radius       : 5px;
                                transform           : rotate(0deg);
                                opacity             : 0.77;
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card3-czy5 .bp4-card1hover .bp4-card1hover1 .bp4-group3 {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 27.53%;
                                top                 : 40.47%;
                                height              : 19.06%;
                                width               : 44.47%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card3-czy5 .bp4-card1hover .bp4-card1hover1 .bp4-group3 .bp4-sslrpfooddeals {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 30px;
                                width               : 99.47%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.26%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Bold", Helvetica, Arial, serif;
                                font-size           : 30.24px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.58px;
                                line-height         : 37.0px;
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card3-czy5 .bp4-card1hover .bp4-card1hover1 .bp4-group3 .bp4-productdesign {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 0px;
                                height              : 16px;
                                width               : 65.61%;
                                position            : absolute;
                                margin              : 0;
                                left                : 17.20%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 16.13px;
                                color               : rgba(201, 201, 201, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.31px;
                                line-height         : 19.0px;
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card3-czy5 .bp4-card1hover .bp4-bluebox {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card3-czy5 .bp4-card1hover .bp4-bluebox .bp4-pixels {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 0px;
                                height              : 6.67%;
                                width               : 20.00%;
                                position            : absolute;
                                margin              : 0;
                                left                : 40.00%;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card3-czy5 .bp4-card1hover .bp4-bluebox .bp4-pixels .bp4-rectangle1 {
                                background-color    : rgba(59, 172, 247, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 1px;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card3-czy5 .bp4-card1hover .bp4-bluebox .bp4-pixels .bp4-a665x429 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 5px);
                                height              : 10px;
                                width               : 68.97%;
                                position            : absolute;
                                margin              : 0;
                                left                : 15.52%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 10.08px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : center;
                                letter-spacing      : 0.19px;
                                line-height         : 12.0px;
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card3-czy5 .bp4-card1hover .bp4-bluebox .bp4-outline {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 92.06%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card3-czy5 .bp4-card1hover .bp4-bluebox .bp4-outline .bp4-rectangle2 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 1.55%;
                                height              : 96.90%;
                                box-sizing          : border-box;
                                width               : 98.16%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.92%;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card3-czy5 .bp4-card1hover .bp4-bluebox .bp4-outline .bp4-rectangle3 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                top                 : 0.34%;
                                height              : 3.45%;
                                box-sizing          : border-box;
                                width               : 2.07%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.23%;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card3-czy5 .bp4-card1hover .bp4-bluebox .bp4-outline .bp4-rectanglecopy2 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                bottom              : 0px;
                                height              : 3.45%;
                                box-sizing          : border-box;
                                width               : 2.07%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card3-czy5 .bp4-card1hover .bp4-bluebox .bp4-outline .bp4-rectanglecopy3 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                right               : 0px;
                                bottom              : 0px;
                                height              : 3.45%;
                                box-sizing          : border-box;
                                width               : 2.07%;
                                position            : absolute;
                                margin              : 0;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card3-czy5 .bp4-card1hover .bp4-bluebox .bp4-outline .bp4-rectanglecopy4 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                right               : 0px;
                                top                 : 0px;
                                height              : 3.45%;
                                box-sizing          : border-box;
                                width               : 2.07%;
                                position            : absolute;
                                margin              : 0;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                        </style>
                        <div id="04erSTT">
                            <a href="swiftrides.html">
                                <div class="bp4-card3 bp4-card3-czy5 component anima-component-wrapper anima-not-ready anima-word-break anima-smart-layers-pointers state1" data-initial-state="state1">
                                    <div class="bp4-card11">
                                        <div class="bp4-mask">
                                        </div>
                                        <div class="bp4-rectangle">
                                        </div>
                                        <img alt="Image" class="bp4-swift" src="./img/ipad-pro-129-home-swift.png"/>
                                    </div>
                                    <div class="bp4-card1hover anima-hidden ">
                                        <div class="bp4-card1hover1">
                                            <div class="bp4-mask1">
                                            </div>
                                            <div class="bp4-rectangle">
                                            </div>
                                            <div class="bp4-swift">
                                                <img alt="Image" class="bp4-swift1" src="./img/ipad-pro-129-home-swift-1.png"/>
                                            </div>
                                            <div class="bp4-mask">
                                            </div>
                                            <div class="bp4-group3">
                                                <div class="bp4-sslrpfooddeals">
                                                    SWIFT Rides
                                                </div>
                                                <div class="bp4-productdesign">
                                                    Product Design
                                                </div>
                                            </div>
                                        </div>
                                        <div class="bp4-bluebox">
                                            <div class="bp4-pixels">
                                                <div class="bp4-rectangle1">
                                                </div>
                                                <div class="bp4-a665x429">
                                                    JUNE x 2017
                                                </div>
                                            </div>
                                            <div class="bp4-outline">
                                                <div class="bp4-rectangle2">
                                                </div>
                                                <div class="bp4-rectangle3">
                                                </div>
                                                <div class="bp4-rectanglecopy2">
                                                </div>
                                                <div class="bp4-rectanglecopy3">
                                                </div>
                                                <div class="bp4-rectanglecopy4">
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </a>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card3-czy5", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp4-card1hover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp4-card1hover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp4-card1hover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                        <style>
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card2-bfVB * {
                                box-sizing          : border-box;
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card2-bfVB {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 212px;
                                height              : 315px;
                                width               : 444px;
                                position            : absolute;
                                margin              : 0;
                                left                : 461px;
                                transform           : rotate(0deg);
                                transition          : all 0.2s ease-in-out;
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card2-bfVB .bp4-card11 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 2.54%;
                                height              : 88.25%;
                                width               : 95.50%;
                                position            : absolute;
                                margin              : 0;
                                left                : 2.25%;
                                border-radius       : 5px;
                                overflow            : hidden;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card2-bfVB .bp4-card11 .bp4-mask {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 0px;
                                height              : 99.64%;
                                width               : 99.76%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 5px;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card2-bfVB .bp4-card11 .bp4-screenshot20200423at83825pm {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : -32px;
                                height              : 319px;
                                width               : 599px;
                                position            : absolute;
                                margin              : 0;
                                left                : -88px;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card2-bfVB .bp4-card1hover {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : -0.32%;
                                height              : 100%;
                                width               : 97.97%;
                                position            : absolute;
                                margin              : 0;
                                left                : 1.01%;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card2-bfVB .bp4-card1hover .bp4-card1hover1 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 2.22%;
                                height              : 88.25%;
                                width               : 97.47%;
                                position            : absolute;
                                margin              : 0;
                                left                : 1.26%;
                                border-radius       : 5px;
                                overflow            : hidden;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card2-bfVB .bp4-card1hover .bp4-card1hover1 .bp4-mask1 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 0px;
                                height              : 99.64%;
                                width               : 99.76%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 5px;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card2-bfVB .bp4-card1hover .bp4-card1hover1 .bp4-screenshot20200423at83825pm {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : -32px;
                                height              : 319px;
                                width               : 599px;
                                position            : absolute;
                                margin              : 0;
                                left                : -88px;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card2-bfVB .bp4-card1hover .bp4-card1hover1 .bp4-mask {
                                background-color    : rgba(0, 0, 0, 1.0);
                                top                 : 0px;
                                height              : 99.64%;
                                width               : 99.76%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 5px;
                                transform           : rotate(0deg);
                                opacity             : 0.77;
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card2-bfVB .bp4-card1hover .bp4-card1hover1 .bp4-sslrpfooddeals {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 40.65%;
                                height              : 30px;
                                width               : 37.26%;
                                position            : absolute;
                                margin              : 0;
                                left                : 31.37%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Bold", Helvetica, Arial, serif;
                                font-size           : 30.24px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.58px;
                                line-height         : 37.0px;
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card2-bfVB .bp4-card1hover .bp4-card1hover1 .bp4-productdesign {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 40.65%;
                                height              : 16px;
                                width               : 29.72%;
                                position            : absolute;
                                margin              : 0;
                                left                : 34.91%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 16.13px;
                                color               : rgba(201, 201, 201, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.31px;
                                line-height         : 19.0px;
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card2-bfVB .bp4-card1hover .bp4-bluebox {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card2-bfVB .bp4-card1hover .bp4-bluebox .bp4-pixels {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 0px;
                                height              : 6.67%;
                                width               : 20.00%;
                                position            : absolute;
                                margin              : 0;
                                left                : 40.00%;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card2-bfVB .bp4-card1hover .bp4-bluebox .bp4-pixels .bp4-rectangle1 {
                                background-color    : rgba(59, 172, 247, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 1px;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card2-bfVB .bp4-card1hover .bp4-bluebox .bp4-pixels .bp4-a665x429 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 5px);
                                height              : 10px;
                                width               : 51.72%;
                                position            : absolute;
                                margin              : 0;
                                left                : 24.14%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 10.08px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : center;
                                letter-spacing      : 0.19px;
                                line-height         : 12.0px;
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card2-bfVB .bp4-card1hover .bp4-bluebox .bp4-outline {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 92.06%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card2-bfVB .bp4-card1hover .bp4-bluebox .bp4-outline .bp4-rectangle2 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 1.55%;
                                height              : 96.90%;
                                box-sizing          : border-box;
                                width               : 98.16%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.92%;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card2-bfVB .bp4-card1hover .bp4-bluebox .bp4-outline .bp4-rectangle3 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                top                 : 0.69%;
                                height              : 3.10%;
                                box-sizing          : border-box;
                                width               : 2.07%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.23%;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card2-bfVB .bp4-card1hover .bp4-bluebox .bp4-outline .bp4-rectanglecopy2 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                bottom              : 0px;
                                height              : 3.45%;
                                box-sizing          : border-box;
                                width               : 2.07%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card2-bfVB .bp4-card1hover .bp4-bluebox .bp4-outline .bp4-rectanglecopy3 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                right               : 0px;
                                bottom              : 0px;
                                height              : 3.45%;
                                box-sizing          : border-box;
                                width               : 2.07%;
                                position            : absolute;
                                margin              : 0;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card2-bfVB .bp4-card1hover .bp4-bluebox .bp4-outline .bp4-rectanglecopy4 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                right               : 0px;
                                top                 : 0px;
                                height              : 3.45%;
                                box-sizing          : border-box;
                                width               : 2.07%;
                                position            : absolute;
                                margin              : 0;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                        </style>
                        <div id="tMmLrss">
                            <a href="designco.html">
                                <div class="bp4-card2 bp4-card2-bfVB component anima-component-wrapper anima-not-ready anima-word-break anima-smart-layers-pointers state1" data-initial-state="state1">
                                    <div class="bp4-card11">
                                        <div class="bp4-mask">
                                        </div>
                                        <img alt="Image" class="bp4-screenshot20200423at83825pm" src="./img/ipad-pro-129-home-screen-shot-2020-04-23-at-83825-pm-1.png"/>
                                    </div>
                                    <div class="bp4-card1hover anima-hidden ">
                                        <div class="bp4-card1hover1">
                                            <div class="bp4-mask1">
                                            </div>
                                            <img alt="Image" class="bp4-screenshot20200423at83825pm" src="./img/ipad-pro-129-home-screen-shot-2020-04-23-at-83825-pm-1.png"/>
                                            <div class="bp4-mask">
                                            </div>
                                            <div class="bp4-sslrpfooddeals">
                                                Design Co
                                            </div>
                                            <div class="bp4-productdesign">
                                                Student Leader
                                            </div>
                                        </div>
                                        <div class="bp4-bluebox">
                                            <div class="bp4-pixels">
                                                <div class="bp4-rectangle1">
                                                </div>
                                                <div class="bp4-a665x429">
                                                    PRESENT
                                                </div>
                                            </div>
                                            <div class="bp4-outline">
                                                <div class="bp4-rectangle2">
                                                </div>
                                                <div class="bp4-rectangle3">
                                                </div>
                                                <div class="bp4-rectanglecopy2">
                                                </div>
                                                <div class="bp4-rectanglecopy3">
                                                </div>
                                                <div class="bp4-rectanglecopy4">
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </a>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card2-bfVB", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp4-card1hover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp4-card1hover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp4-card1hover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                        <style>
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card1-rpzM * {
                                box-sizing          : border-box;
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card1-rpzM {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 212px;
                                height              : 315px;
                                width               : 443px;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                                transition          : all 0.2s ease-in-out;
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card1-rpzM .bp4-card11 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 2.54%;
                                height              : 88.25%;
                                width               : 95.71%;
                                position            : absolute;
                                margin              : 0;
                                left                : 2.14%;
                                border-radius       : 5px;
                                overflow            : hidden;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card1-rpzM .bp4-card11 .bp4-mask {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 0px;
                                height              : 99.64%;
                                width               : 99.76%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 5px;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card1-rpzM .bp4-card11 .bp4-rotatosnapshot {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 277px;
                                width               : 493px;
                                position            : absolute;
                                margin              : 0;
                                left                : -35px;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card1-rpzM .bp4-card1hover {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : -0.32%;
                                height              : 100%;
                                width               : 98.19%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.90%;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card1-rpzM .bp4-card1hover .bp4-card1hover1 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 2.22%;
                                height              : 88.25%;
                                width               : 97.47%;
                                position            : absolute;
                                margin              : 0;
                                left                : 1.26%;
                                border-radius       : 5px;
                                overflow            : hidden;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card1-rpzM .bp4-card1hover .bp4-card1hover1 .bp4-mask1 {
                                background-color    : rgba(215, 215, 215, 1.0);
                                top                 : 0px;
                                height              : 99.64%;
                                width               : 99.76%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 5px;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card1-rpzM .bp4-card1hover .bp4-card1hover1 .bp4-rotatosnapshot1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 277px;
                                width               : 493px;
                                position            : absolute;
                                margin              : 0;
                                left                : -35px;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card1-rpzM .bp4-card1hover .bp4-card1hover1 .bp4-mask {
                                background-color    : rgba(0, 0, 0, 1.0);
                                top                 : 0px;
                                height              : 99.64%;
                                width               : 99.76%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 5px;
                                transform           : rotate(0deg);
                                opacity             : 0.77;
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card1-rpzM .bp4-card1hover .bp4-card1hover1 .bp4-sslrpfooddeals {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 40.65%;
                                height              : 30px;
                                width               : 44.81%;
                                position            : absolute;
                                margin              : 0;
                                left                : 27.59%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Bold", Helvetica, Arial, serif;
                                font-size           : 30.24px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.58px;
                                line-height         : 37.0px;
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card1-rpzM .bp4-card1hover .bp4-card1hover1 .bp4-productdesign {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 40.65%;
                                height              : 16px;
                                width               : 29.72%;
                                position            : absolute;
                                margin              : 0;
                                left                : 34.91%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 16.13px;
                                color               : rgba(201, 201, 201, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.31px;
                                line-height         : 19.0px;
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card1-rpzM .bp4-card1hover .bp4-bluebox {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card1-rpzM .bp4-card1hover .bp4-bluebox .bp4-pixels {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 0px;
                                height              : 6.67%;
                                width               : 20.00%;
                                position            : absolute;
                                margin              : 0;
                                left                : 40.00%;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card1-rpzM .bp4-card1hover .bp4-bluebox .bp4-pixels .bp4-rectangle1 {
                                background-color    : rgba(59, 172, 247, 1.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-radius       : 1px;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card1-rpzM .bp4-card1hover .bp4-bluebox .bp4-pixels .bp4-a665x429 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 5px);
                                height              : 10px;
                                width               : 60.92%;
                                position            : absolute;
                                margin              : 0;
                                left                : 19.54%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 10.08px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : center;
                                letter-spacing      : 0.19px;
                                line-height         : 12.0px;
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card1-rpzM .bp4-card1hover .bp4-bluebox .bp4-outline {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 92.06%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card1-rpzM .bp4-card1hover .bp4-bluebox .bp4-outline .bp4-rectangle2 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 1.55%;
                                height              : 96.90%;
                                box-sizing          : border-box;
                                width               : 98.16%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.92%;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card1-rpzM .bp4-card1hover .bp4-bluebox .bp4-outline .bp4-rectangle3 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                top                 : 0.69%;
                                height              : 3.10%;
                                box-sizing          : border-box;
                                width               : 2.07%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.23%;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card1-rpzM .bp4-card1hover .bp4-bluebox .bp4-outline .bp4-rectanglecopy2 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                bottom              : 0px;
                                height              : 3.45%;
                                box-sizing          : border-box;
                                width               : 2.07%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card1-rpzM .bp4-card1hover .bp4-bluebox .bp4-outline .bp4-rectanglecopy3 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                right               : 0px;
                                bottom              : 0px;
                                height              : 3.45%;
                                box-sizing          : border-box;
                                width               : 2.07%;
                                position            : absolute;
                                margin              : 0;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                            .bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card1-rpzM .bp4-card1hover .bp4-bluebox .bp4-outline .bp4-rectanglecopy4 {
                                background-color    : rgba(255, 255, 255, 1.0);
                                right               : 0px;
                                top                 : 0px;
                                height              : 3.45%;
                                box-sizing          : border-box;
                                width               : 2.07%;
                                position            : absolute;
                                margin              : 0;
                                border-style        : solid;
                                border-width        : 1px;
                                border-color        : rgba(59, 172, 247, 1.0);
                                transform           : rotate(0deg);
                            }
                        </style>
                        <div id="9rtvm9M">
                            <a href="sslrpdeals.html">
                                <div class="bp4-card1 bp4-card1-rpzM component anima-component-wrapper anima-not-ready anima-word-break anima-smart-layers-pointers state1" data-initial-state="state1">
                                    <div class="bp4-card11">
                                        <div class="bp4-mask">
                                        </div>
                                        <img alt="Image" class="bp4-rotatosnapshot" src="./img/ipad-pro-129-home-rotato-snapshot-1.png"/>
                                    </div>
                                    <div class="bp4-card1hover anima-hidden ">
                                        <div class="bp4-card1hover1">
                                            <div class="bp4-mask1">
                                            </div>
                                            <img alt="Image" class="bp4-rotatosnapshot1" src="./img/ipad-pro-129-home-rotato-snapshot-1.png"/>
                                            <div class="bp4-mask">
                                            </div>
                                            <div class="bp4-sslrpfooddeals">
                                                SSLRP Deals
                                            </div>
                                            <div class="bp4-productdesign">
                                                Product Design
                                            </div>
                                        </div>
                                        <div class="bp4-bluebox">
                                            <div class="bp4-pixels">
                                                <div class="bp4-rectangle1">
                                                </div>
                                                <div class="bp4-a665x429">
                                                    FEB x 2019
                                                </div>
                                            </div>
                                            <div class="bp4-outline">
                                                <div class="bp4-rectangle2">
                                                </div>
                                                <div class="bp4-rectangle3">
                                                </div>
                                                <div class="bp4-rectanglecopy2">
                                                </div>
                                                <div class="bp4-rectanglecopy3">
                                                </div>
                                                <div class="bp4-rectanglecopy4">
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </a>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp4-ipadpro129home .bp4-sectionwork .bp4-workcontent .bp4-card1-rpzM", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp4-card1hover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp4-card1hover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp4-card1hover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                        <div class="bp4-text">
                            <div anima-show-on-scroll="" class="bp4-h2">
                                Crafted with intention. Bringing all attention.
                            </div>
                            <div anima-show-on-scroll="" class="bp4-h1">
                                Embarking on a Journey through Pixels.
                            </div>
                            <div anima-show-on-scroll="" class="bp4-h3">
                                WORK
                            </div>
                        </div>
                    </div>
                </div>
                <div class="bp4-sectionfooter">
                    <img alt="Image" anima-src="./img/ipad-pro-129-adobe-bg.png" class="bp4-bg" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                    <div class="bp4-footer">
                        <div class="bp4-socialicons">
                            <style>
                                .bp4-ipadpro129home .bp4-sectionfooter .bp4-footer .bp4-socialicons .bp4-dribbble-ukDJ * {
                                    box-sizing          : border-box;
                                }
                                .bp4-ipadpro129home .bp4-sectionfooter .bp4-footer .bp4-socialicons .bp4-dribbble-ukDJ {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 33px;
                                    width               : 33px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 64px;
                                    transform           : rotate(0deg);
                                }
                                .bp4-ipadpro129home .bp4-sectionfooter .bp4-footer .bp4-socialicons .bp4-dribbble-ukDJ .bp4-shape {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 1.52%;
                                    height              : 96.97%;
                                    width               : 96.97%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 1.52%;
                                    transform           : rotate(0deg);
                                }
                                .bp4-ipadpro129home .bp4-sectionfooter .bp4-footer .bp4-socialicons .bp4-dribbble-ukDJ .bp4-shapehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 1.52%;
                                    height              : 96.97%;
                                    width               : 96.97%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 1.52%;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                }
                            </style>
                            <div id="Nvn8wz6">
                                <a href="https://dribbble.com/syedadam007" target="_blank">
                                    <div class="bp4-dribbble bp4-dribbble-ukDJ component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <img alt="Image" class="bp4-shape" src="./img/ipad-pro-129-playground-shape-2@2x.png"/>
                                        <img alt="Image" class="bp4-shapehover anima-hidden " src="./img/ipad-pro-129-playground-shapehover@2x.png"/>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp4-ipadpro129home .bp4-sectionfooter .bp4-footer .bp4-socialicons .bp4-dribbble-ukDJ", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp4-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp4-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp4-shapehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <style>
                                .bp4-ipadpro129home .bp4-sectionfooter .bp4-footer .bp4-socialicons .bp4-linkedin-cpPk * {
                                    box-sizing          : border-box;
                                }
                                .bp4-ipadpro129home .bp4-sectionfooter .bp4-footer .bp4-socialicons .bp4-linkedin-cpPk {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 33px;
                                    width               : 33px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .bp4-ipadpro129home .bp4-sectionfooter .bp4-footer .bp4-socialicons .bp4-linkedin-cpPk .bp4-shape {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 1.52%;
                                    height              : 96.97%;
                                    width               : 96.97%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 1.52%;
                                    transform           : rotate(0deg);
                                }
                                .bp4-ipadpro129home .bp4-sectionfooter .bp4-footer .bp4-socialicons .bp4-linkedin-cpPk .bp4-shapehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 1.52%;
                                    height              : 96.97%;
                                    width               : 96.97%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 1.52%;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                }
                            </style>
                            <div id="GvrrfpO">
                                <a href="https://www.linkedin.com/in/syedadamemirputra/" target="_blank">
                                    <div class="bp4-linkedin bp4-linkedin-cpPk component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <img alt="Image" class="bp4-shape" src="./img/ipad-pro-129-home-shape-5@2x.png"/>
                                        <img alt="Image" class="bp4-shapehover anima-hidden " src="./img/ipad-pro-129-swiftrides-shapehover-1@2x.png"/>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp4-ipadpro129home .bp4-sectionfooter .bp4-footer .bp4-socialicons .bp4-linkedin-cpPk", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp4-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp4-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp4-shapehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <style>
                                .bp4-ipadpro129home .bp4-sectionfooter .bp4-footer .bp4-socialicons .bp4-instagram-gY8D * {
                                    box-sizing          : border-box;
                                }
                                .bp4-ipadpro129home .bp4-sectionfooter .bp4-footer .bp4-socialicons .bp4-instagram-gY8D {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 1px;
                                    height              : 32px;
                                    width               : 33px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 128px;
                                    transform           : rotate(0deg);
                                }
                                .bp4-ipadpro129home .bp4-sectionfooter .bp4-footer .bp4-socialicons .bp4-instagram-gY8D .bp4-shape {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 96.97%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 1.52%;
                                    transform           : rotate(0deg);
                                }
                                .bp4-ipadpro129home .bp4-sectionfooter .bp4-footer .bp4-socialicons .bp4-instagram-gY8D .bp4-shapehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 96.97%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 1.52%;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                }
                            </style>
                            <div id="x0XmUFz">
                                <a href="https://www.instagram.com/syedadam007/" target="_blank">
                                    <div class="bp4-instagram bp4-instagram-gY8D component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <img alt="Image" class="bp4-shape" src="./img/ipad-pro-129-designco-shape-4@2x.png"/>
                                        <img alt="Image" class="bp4-shapehover anima-hidden " src="./img/ipad-pro-129-sslrpdeals-shapehover-2@2x.png"/>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp4-ipadpro129home .bp4-sectionfooter .bp4-footer .bp4-socialicons .bp4-instagram-gY8D", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp4-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp4-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp4-shapehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                        </div>
                        <div anima-show-on-scroll="" class="bp4-h3">
                            Â© 2020 Lil Adam X
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="anima-overlay" id="overlay-iphonexhomemenuhover" style="min-height:3132px; position:fixed;">
            <div class="iphonexhomemenuhover anima-word-break ">
                <div style="width: 375px; height: 100%; position:relative; margin:auto;">
                    <div class="sectionhero" id="None">
                        <div class="darkbg">
                        </div>
                        <div class="content">
                            <div anima-show-on-scroll="" class="mission">
                                Adam designs because the world ainâ€™t right. Demystifying the ways the world should be.
                            </div>
                            <div class="present">
                                Present
                            </div>
                            <style>
                                .iphonexhomemenuhover .sectionhero .content .designco-kFCP * {
                                    box-sizing          : border-box;
                                }
                                .iphonexhomemenuhover .sectionhero .content .designco-kFCP {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 211px;
                                    height              : 14px;
                                    width               : 67px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 1px;
                                    transform           : rotate(0deg);
                                }
                                .iphonexhomemenuhover .sectionhero .content .designco-kFCP .designco1 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 7px);
                                    height              : 13px;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 12.9px;
                                    color               : rgba(255, 255, 255, 1.0);
                                    text-align          : left;
                                    letter-spacing      : 0.25px;
                                    line-height         : 16.0px;
                                }
                                .iphonexhomemenuhover .sectionhero .content .designco-kFCP .designcohover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 7px);
                                    height              : 13px;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 12.9px;
                                    color               : rgba(146, 146, 146, 1.0);
                                    text-align          : left;
                                    letter-spacing      : 0.25px;
                                    line-height         : 16.0px;
                                }
                            </style>
                            <div id="Xw6ZL4h">
                                <div class="designco designco-kFCP component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                    <a href="http://www.ucsddesign.co/" target="_blank">
                                        <div class="designco1">
                                            Design Co
                                        </div>
                                    </a>
                                    <a href="http://www.ucsddesign.co/" target="_blank">
                                        <div class="designcohover anima-hidden ">
                                            Design Co
                                        </div>
                                    </a>
                                </div>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".iphonexhomemenuhover .sectionhero .content .designco-kFCP", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".designcohover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".designcohover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".designcohover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <div class="education">
                                Education
                            </div>
                            <style>
                                .iphonexhomemenuhover .sectionhero .content .ucsd-Mvze * {
                                    box-sizing          : border-box;
                                }
                                .iphonexhomemenuhover .sectionhero .content .ucsd-Mvze {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 285px;
                                    height              : 14px;
                                    width               : 92px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 1px;
                                    transform           : rotate(0deg);
                                }
                                .iphonexhomemenuhover .sectionhero .content .ucsd-Mvze .ucsd1 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 7px);
                                    height              : 13px;
                                    width               : 98.91%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0.54%;
                                    transform           : rotate(0deg);
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 12.9px;
                                    color               : rgba(255, 255, 255, 1.0);
                                    text-align          : left;
                                    letter-spacing      : 0.25px;
                                    line-height         : 16.0px;
                                }
                                .iphonexhomemenuhover .sectionhero .content .ucsd-Mvze .ucsdhover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 7px);
                                    height              : 13px;
                                    width               : 98.91%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0.54%;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 12.9px;
                                    color               : rgba(146, 146, 146, 1.0);
                                    text-align          : left;
                                    letter-spacing      : 0.25px;
                                    line-height         : 16.0px;
                                }
                            </style>
                            <div id="1PCBIoK">
                                <div class="ucsd ucsd-Mvze component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                    <a href="https://ucsd.edu/" target="_blank">
                                        <div class="ucsd1">
                                            UC San Diego
                                        </div>
                                    </a>
                                    <a href="https://ucsd.edu/" target="_blank">
                                        <div class="ucsdhover anima-hidden ">
                                            UC San Diego
                                        </div>
                                    </a>
                                </div>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".iphonexhomemenuhover .sectionhero .content .ucsd-Mvze", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".ucsdhover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".ucsdhover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".ucsdhover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <div class="previous">
                                Previous
                            </div>
                            <style>
                                .iphonexhomemenuhover .sectionhero .content .longstorystudios-kgqy * {
                                    box-sizing          : border-box;
                                }
                                .iphonexhomemenuhover .sectionhero .content .longstorystudios-kgqy {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 206px;
                                    height              : 35px;
                                    width               : 108px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 178px;
                                    transform           : rotate(0deg);
                                }
                                .iphonexhomemenuhover .sectionhero .content .longstorystudios-kgqy .ls {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 17px);
                                    height              : 34px;
                                    width               : 65.74%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 12.9px;
                                    color               : rgba(255, 255, 255, 1.0);
                                    text-align          : left;
                                    letter-spacing      : 0.25px;
                                    line-height         : 17.0px;
                                }
                                .iphonexhomemenuhover .sectionhero .content .longstorystudios-kgqy .lshover {
                                    background-color    : rgba(255,255,255,0.0);
                                    right               : 0.93%;
                                    top                 : calc(50.00% - 13px);
                                    height              : 26px;
                                    width               : 65.74%;
                                    position            : absolute;
                                    margin              : 0;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 12.9px;
                                    color               : rgba(146, 146, 146, 1.0);
                                    text-align          : left;
                                    letter-spacing      : 0.25px;
                                    line-height         : 16.0px;
                                }
                            </style>
                            <div id="fLurn0m">
                                <div class="longstorystudios longstorystudios-kgqy component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                    <a href="https://www.longstorystudios.com/" target="_blank">
                                        <div class="ls">
                                            Long Story Studios
                                        </div>
                                    </a>
                                    <a href="https://www.longstorystudios.com/" target="_blank">
                                        <div class="lshover anima-hidden ">
                                            Long Story Studios
                                        </div>
                                    </a>
                                </div>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".iphonexhomemenuhover .sectionhero .content .longstorystudios-kgqy", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".lshover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".lshover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".lshover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                        </div>
                        <div class="navbar">
                            <div class="rectangle">
                            </div>
                            <style>
                                .iphonexhomemenuhover .sectionhero .navbar .logo-kpby * {
                                    box-sizing          : border-box;
                                }
                                .iphonexhomemenuhover .sectionhero .navbar .logo-kpby {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 33px;
                                    height              : 19px;
                                    width               : 110px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 38px;
                                    transform           : rotate(0deg);
                                }
                                .iphonexhomemenuhover .sectionhero .navbar .logo-kpby .adamoutline {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 99.09%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0.45%;
                                    transform           : rotate(0deg);
                                }
                                .iphonexhomemenuhover .sectionhero .navbar .logo-kpby .adamoutline .shape1 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 2.63%;
                                    height              : 94.74%;
                                    width               : 82.57%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0.92%;
                                    transform           : rotate(0deg);
                                }
                                .iphonexhomemenuhover .sectionhero .navbar .logo-kpby .adamoutline .path {
                                    background-color    : rgba(255,255,255,0.0);
                                    right               : 0px;
                                    top                 : 18.42%;
                                    height              : 63.16%;
                                    width               : 11.01%;
                                    position            : absolute;
                                    margin              : 0;
                                    transform           : rotate(0deg);
                                }
                                .iphonexhomemenuhover .sectionhero .navbar .logo-kpby .adamfill {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 2.63%;
                                    height              : 94.74%;
                                    width               : 98.18%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0.91%;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                }
                                .iphonexhomemenuhover .sectionhero .navbar .logo-kpby .adamfill .shape1 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 81.48%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .iphonexhomemenuhover .sectionhero .navbar .logo-kpby .adamfill .path1 {
                                    background-color    : rgba(255,255,255,0.0);
                                    right               : 0px;
                                    top                 : 13.89%;
                                    height              : 72.22%;
                                    width               : 11.11%;
                                    position            : absolute;
                                    margin              : 0;
                                    transform           : rotate(0deg);
                                }
                            </style>
                            <div id="4bmllGy">
                                <div class="logo logo-kpby component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                    <div class="adamoutline">
                                        <img alt="Image" class="shape1" src="./img/iphone-x-work-shape@2x.png"/>
                                        <img alt="Image" class="path" src="./img/iphone-x-home-path@2x.png"/>
                                    </div>
                                    <div class="adamfill anima-hidden ">
                                        <img alt="Image" class="shape1" src="./img/iphone-x-home-menu-hover-shape-4@2x.png"/>
                                        <img alt="Image" class="path1" src="./img/iphone-x-menu-light-hover-path-1@2x.png"/>
                                    </div>
                                </div>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".iphonexhomemenuhover .sectionhero .navbar .logo-kpby", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".adamfill": {
                "delay": 0, 
                "duration": 400, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".adamfill": {
                "delay": 0, 
                "duration": 500, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".adamfill": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <a href="javascript:animaShowOverlay('ipadhomemenuhover', 'anima-animate-appear'); anima_loadAsyncSrc(); ">
                                <img alt="Image" anima-src="./img/iphone-x-home-menu-hover-shape-2@2x.png" class="shape" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                            </a>
                        </div>
                    </div>
                    <div class="group3">
                        <div class="rectangle">
                        </div>
                        <style>
                            .iphonexhomemenuhover .group3 .work-3A8r * {
                                box-sizing          : border-box;
                            }
                            .iphonexhomemenuhover .group3 .work-3A8r {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 205px;
                                height              : 41px;
                                width               : 134px;
                                position            : absolute;
                                margin              : 0;
                                left                : 37px;
                                transform           : rotate(0deg);
                            }
                            .iphonexhomemenuhover .group3 .work-3A8r .work1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 20px);
                                height              : 40px;
                                width               : 99.25%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.37%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 20.9px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.58px;
                                line-height         : 25.0px;
                            }
                        </style>
                        <div id="Dl8fwjA">
                            <a href="work.html">
                                <div anima-show-on-scroll="" class="work anima-animate-enter work-3A8r component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                    <div class="work1 anima-valign-text-middle">
                                        Work
                                    </div>
                                </div>
                            </a>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".iphonexhomemenuhover .group3 .work-3A8r", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {}, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {}, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ".work1"
          }
        ], 
        "overrides": {}
      }
    }
  }
];
})();
                        </script>
                        <style>
                            .iphonexhomemenuhover .group3 .workcopy-Opf6 * {
                                box-sizing          : border-box;
                            }
                            .iphonexhomemenuhover .group3 .workcopy-Opf6 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 150px;
                                height              : 41px;
                                width               : 134px;
                                position            : absolute;
                                margin              : 0;
                                left                : 37px;
                                transform           : rotate(0deg);
                            }
                            .iphonexhomemenuhover .group3 .workcopy-Opf6 .work1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 20px);
                                height              : 40px;
                                width               : 99.25%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.37%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 20.9px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.58px;
                                line-height         : 25.0px;
                            }
                        </style>
                        <div id="wDoso9X">
                            <a href="home.html">
                                <div anima-show-on-scroll="" class="workcopy anima-animate-enter1 workcopy-Opf6 component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                    <div class="work1 anima-valign-text-middle">
                                        Home
                                    </div>
                                </div>
                            </a>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".iphonexhomemenuhover .group3 .workcopy-Opf6", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {}, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {}, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ".work1"
          }
        ], 
        "overrides": {}
      }
    }
  }
];
})();
                        </script>
                        <style>
                            .iphonexhomemenuhover .group3 .workcopy2-dmIm * {
                                box-sizing          : border-box;
                            }
                            .iphonexhomemenuhover .group3 .workcopy2-dmIm {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 260px;
                                height              : 41px;
                                width               : 134px;
                                position            : absolute;
                                margin              : 0;
                                left                : 37px;
                                transform           : rotate(0deg);
                            }
                            .iphonexhomemenuhover .group3 .workcopy2-dmIm .work1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 20px);
                                height              : 40px;
                                width               : 99.25%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.37%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 20.9px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.58px;
                                line-height         : 25.0px;
                            }
                        </style>
                        <div id="TrBYpwr">
                            <a href="about.html">
                                <div anima-show-on-scroll="" class="workcopy2 anima-animate-enter2 workcopy2-dmIm component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                    <div class="work1 anima-valign-text-middle">
                                        About
                                    </div>
                                </div>
                            </a>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".iphonexhomemenuhover .group3 .workcopy2-dmIm", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {}, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {}, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ".work1"
          }
        ], 
        "overrides": {}
      }
    }
  }
];
})();
                        </script>
                        <style>
                            .iphonexhomemenuhover .group3 .workcopy3-fTbL * {
                                box-sizing          : border-box;
                            }
                            .iphonexhomemenuhover .group3 .workcopy3-fTbL {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 315px;
                                height              : 41px;
                                width               : 134px;
                                position            : absolute;
                                margin              : 0;
                                left                : 37px;
                                transform           : rotate(0deg);
                            }
                            .iphonexhomemenuhover .group3 .workcopy3-fTbL .work1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 20px);
                                height              : 40px;
                                width               : 99.25%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.37%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 20.9px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.58px;
                                line-height         : 25.0px;
                            }
                        </style>
                        <div id="2Yfz7bB">
                            <a href="https://drive.google.com/file/d/1KxPEStKpGkBtJaURrrckkRjVntkcITWU/view?usp=sharing" target="_blank">
                                <div class="workcopy3 workcopy3-fTbL component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                    <div class="work1 anima-valign-text-middle">
                                        Resume
                                    </div>
                                </div>
                            </a>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".iphonexhomemenuhover .group3 .workcopy3-fTbL", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {}, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {}, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ".work1"
          }
        ], 
        "overrides": {}
      }
    }
  }
];
})();
                        </script>
                        <a href="javascript:animaHideOverlay('iphonexhomemenuhover', 'anima-animate-disappear');">
                            <div class="group2">
                                <img alt="Image" anima-src="./img/iphone-x-home-menu-hover-path-2@2x.png" class="path" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                                <img alt="Image" anima-src="./img/iphone-x-home-menu-hover-path-2@2x.png" class="path1" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                            </div>
                        </a>
                        <style>
                            .iphonexhomemenuhover .group3 .logo-jCoZ * {
                                box-sizing          : border-box;
                            }
                            .iphonexhomemenuhover .group3 .logo-jCoZ {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 33px;
                                height              : 19px;
                                width               : 110px;
                                position            : absolute;
                                margin              : 0;
                                left                : 38px;
                                transform           : rotate(0deg);
                            }
                            .iphonexhomemenuhover .group3 .logo-jCoZ .adamoutline {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 99.09%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.45%;
                                transform           : rotate(0deg);
                            }
                            .iphonexhomemenuhover .group3 .logo-jCoZ .adamoutline .shape {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 2.63%;
                                height              : 94.74%;
                                width               : 82.57%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.92%;
                                transform           : rotate(0deg);
                            }
                            .iphonexhomemenuhover .group3 .logo-jCoZ .adamoutline .path {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 0px;
                                top                 : 18.42%;
                                height              : 63.16%;
                                width               : 11.01%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                            .iphonexhomemenuhover .group3 .logo-jCoZ .adamfill {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 2.63%;
                                height              : 94.74%;
                                width               : 97.27%;
                                position            : absolute;
                                margin              : 0;
                                left                : 1.36%;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                            }
                            .iphonexhomemenuhover .group3 .logo-jCoZ .adamfill .shape1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 82.24%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.93%;
                                transform           : rotate(0deg);
                            }
                            .iphonexhomemenuhover .group3 .logo-jCoZ .adamfill .path1 {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 0px;
                                top                 : 13.89%;
                                height              : 72.22%;
                                width               : 11.21%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                        </style>
                        <div id="9EAstPA">
                            <a href="home.html">
                                <div class="logo logo-jCoZ component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                    <div class="adamoutline">
                                        <img alt="Image" class="shape" src="./img/iphone-x-work-shape@2x.png"/>
                                        <img alt="Image" class="path" src="./img/iphone-x-home-path@2x.png"/>
                                    </div>
                                    <div class="adamfill anima-hidden ">
                                        <img alt="Image" class="shape1" src="./img/iphone-x-home-menu-hover-shape-4@2x.png"/>
                                        <img alt="Image" class="path1" src="./img/iphone-x-menu-light-hover-path-1@2x.png"/>
                                    </div>
                                </div>
                            </a>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".iphonexhomemenuhover .group3 .logo-jCoZ", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".adamfill": {
                "delay": 0, 
                "duration": 400, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".adamfill": {
                "delay": 0, 
                "duration": 500, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".adamfill": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                    </div>
                    <div anima-show-on-scroll="" class="h3">
                        Â© 2020 Lil Adam X
                    </div>
                </div>
            </div>
        </div>
        <script>
   var overlay_id = "overlay-iphonexhomemenuhover";
  document.getElementById(overlay_id).addEventListener("click", function( event ) {
    var e = event || window.event;
    var clickedDiv = e.toElement || e.target;
    if (clickedDiv.parentElement.id == overlay_id) {
        animaHideOverlay('iphonexhomemenuhover', 'anima-animate-disappear');
    }
  }, false);
        </script>
        <div class="anima-overlay" id="overlay-ipadhomemenuhover" style="min-height:3132px; position:fixed;">
            <div class="ipadhomemenuhover anima-word-break ">
                <div style="width: 768px; height: 100%; position:relative; margin:auto;">
                    <div class="sectionhero" id="None">
                        <div class="darkbg">
                        </div>
                        <div class="content">
                            <div anima-show-on-scroll="" class="mission">
                                Adam designs because the world ainâ€™t right. <br />Demystifying the ways the world should be.
                            </div>
                            <div class="present">
                                Present
                            </div>
                            <style>
                                .ipadhomemenuhover .sectionhero .content .designco-naEd * {
                                    box-sizing          : border-box;
                                }
                                .ipadhomemenuhover .sectionhero .content .designco-naEd {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 175px;
                                    height              : 17px;
                                    width               : 84px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .ipadhomemenuhover .sectionhero .content .designco-naEd .designco1 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 8px);
                                    height              : 16px;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 16.13px;
                                    color               : rgba(255, 255, 255, 1.0);
                                    text-align          : left;
                                    letter-spacing      : 0.31px;
                                    line-height         : 19.0px;
                                }
                                .ipadhomemenuhover .sectionhero .content .designco-naEd .designcohover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 8px);
                                    height              : 16px;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 16.13px;
                                    color               : rgba(146, 146, 146, 1.0);
                                    text-align          : left;
                                    letter-spacing      : 0.31px;
                                    line-height         : 19.0px;
                                }
                            </style>
                            <div id="2zGGRJn">
                                <div class="designco designco-naEd component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                    <a href="http://www.ucsddesign.co/" target="_blank">
                                        <div class="designco1">
                                            Design Co
                                        </div>
                                    </a>
                                    <a href="http://www.ucsddesign.co/" target="_blank">
                                        <div class="designcohover anima-hidden ">
                                            Design Co
                                        </div>
                                    </a>
                                </div>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".ipadhomemenuhover .sectionhero .content .designco-naEd", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".designcohover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".designcohover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".designcohover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <div class="education">
                                Education
                            </div>
                            <style>
                                .ipadhomemenuhover .sectionhero .content .ucsd-xOMP * {
                                    box-sizing          : border-box;
                                }
                                .ipadhomemenuhover .sectionhero .content .ucsd-xOMP {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 261px;
                                    height              : 17px;
                                    width               : 115px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .ipadhomemenuhover .sectionhero .content .ucsd-xOMP .ucsd1 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 8px);
                                    height              : 16px;
                                    width               : 99.13%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0.43%;
                                    transform           : rotate(0deg);
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 16.13px;
                                    color               : rgba(255, 255, 255, 1.0);
                                    text-align          : left;
                                    letter-spacing      : 0.31px;
                                    line-height         : 19.0px;
                                }
                                .ipadhomemenuhover .sectionhero .content .ucsd-xOMP .ucsdhover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 8px);
                                    height              : 16px;
                                    width               : 99.13%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0.43%;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 16.13px;
                                    color               : rgba(146, 146, 146, 1.0);
                                    text-align          : left;
                                    letter-spacing      : 0.31px;
                                    line-height         : 19.0px;
                                }
                            </style>
                            <div id="8tVlU8x">
                                <div class="ucsd ucsd-xOMP component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                    <a href="https://ucsd.edu/" target="_blank">
                                        <div class="ucsd1">
                                            UC San Diego
                                        </div>
                                    </a>
                                    <a href="https://ucsd.edu/" target="_blank">
                                        <div class="ucsdhover anima-hidden ">
                                            UC San Diego
                                        </div>
                                    </a>
                                </div>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".ipadhomemenuhover .sectionhero .content .ucsd-xOMP", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".ucsdhover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".ucsdhover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".ucsdhover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <div class="previous">
                                Previous
                            </div>
                            <style>
                                .ipadhomemenuhover .sectionhero .content .longstorystudios-GRUY * {
                                    box-sizing          : border-box;
                                }
                                .ipadhomemenuhover .sectionhero .content .longstorystudios-GRUY {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 175px;
                                    height              : 17px;
                                    width               : 153px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 297px;
                                    transform           : rotate(0deg);
                                }
                                .ipadhomemenuhover .sectionhero .content .longstorystudios-GRUY .ls {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 8px);
                                    height              : 16px;
                                    width               : 99.35%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0.33%;
                                    transform           : rotate(0deg);
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 16.13px;
                                    color               : rgba(255, 255, 255, 1.0);
                                    text-align          : left;
                                    letter-spacing      : 0.31px;
                                    line-height         : 19.0px;
                                }
                                .ipadhomemenuhover .sectionhero .content .longstorystudios-GRUY .lshover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 8px);
                                    height              : 16px;
                                    width               : 99.35%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0.33%;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 16.13px;
                                    color               : rgba(146, 146, 146, 1.0);
                                    text-align          : left;
                                    letter-spacing      : 0.31px;
                                    line-height         : 19.0px;
                                }
                            </style>
                            <div id="PmoHzJt">
                                <div class="longstorystudios longstorystudios-GRUY component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                    <a href="https://www.longstorystudios.com/" target="_blank">
                                        <div class="ls">
                                            Long Story Studios
                                        </div>
                                    </a>
                                    <a href="https://www.longstorystudios.com/" target="_blank">
                                        <div class="lshover anima-hidden ">
                                            Long Story Studios
                                        </div>
                                    </a>
                                </div>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".ipadhomemenuhover .sectionhero .content .longstorystudios-GRUY", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".lshover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".lshover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".lshover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                        </div>
                        <div class="lightsaber">
                            <div class="lightsaberoff">
                                <div class="lightsaberoff1">
                                    <div class="rectangle">
                                    </div>
                                    <div class="rectangle1">
                                    </div>
                                    <div class="rectangle2">
                                    </div>
                                    <div class="rectangle3">
                                    </div>
                                    <div class="rectangle4">
                                    </div>
                                    <img alt="Image" anima-src="./img/ipad-about-shape-1@2x.png" class="shape" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                                    <div class="rectangle5">
                                    </div>
                                    <div class="rectangle6">
                                    </div>
                                    <div class="rectangle7">
                                    </div>
                                    <div class="rectangle8">
                                    </div>
                                    <div class="rectangle9">
                                    </div>
                                    <img alt="Image" anima-src="./img/ipad-light-menu-hover-path-4@2x.png" class="path" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                                    <img alt="Image" anima-src="./img/ipad-home-path-5@2x.png" class="path1" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                                    <div class="rectangle10">
                                    </div>
                                    <div class="rectangle11">
                                    </div>
                                    <div class="rectangle12">
                                    </div>
                                    <div class="rectangle13">
                                    </div>
                                </div>
                                <a href="playground.html">
                                    <div class="playground">
                                        <div class="rectangle">
                                        </div>
                                        <div class="playground1">
                                            Playground
                                        </div>
                                    </div>
                                </a>
                            </div>
                            <div class="lightsaberon">
                                <div class="lightsaberon1">
                                    <div class="group">
                                        <img alt="Image" anima-src="./img/ipad-pro-129-home-path-2@2x.png" class="path2" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                                        <img alt="Image" anima-src="./img/ipad-about-path-3@2x.png" class="path11" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                                    </div>
                                    <div class="rectangle">
                                    </div>
                                    <div class="rectangle1">
                                    </div>
                                    <div class="rectangle2">
                                    </div>
                                    <div class="rectangle3">
                                    </div>
                                    <div class="rectangle4">
                                    </div>
                                    <img alt="Image" anima-src="./img/ipad-about-shape-1@2x.png" class="shape" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                                    <div class="rectangle5">
                                    </div>
                                    <div class="rectangle6">
                                    </div>
                                    <div class="rectangle7">
                                    </div>
                                    <div class="rectangle8">
                                    </div>
                                    <div class="rectangle9">
                                    </div>
                                    <img alt="Image" anima-src="./img/ipad-light-menu-hover-path-4@2x.png" class="path" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                                    <img alt="Image" anima-src="./img/ipad-home-path-5@2x.png" class="path1" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                                    <div class="rectangle10">
                                    </div>
                                    <div class="rectangle11">
                                    </div>
                                    <div class="rectangle12">
                                    </div>
                                    <div class="rectangle13">
                                    </div>
                                </div>
                                <a href="playground.html">
                                    <div class="playground">
                                        <div class="rectangle">
                                        </div>
                                        <div class="playground1">
                                            Playground
                                        </div>
                                    </div>
                                </a>
                            </div>
                        </div>
                        <div class="navbar">
                            <div class="rectangle">
                            </div>
                            <style>
                                .ipadhomemenuhover .sectionhero .navbar .logo1-XFzm * {
                                    box-sizing          : border-box;
                                }
                                .ipadhomemenuhover .sectionhero .navbar .logo1-XFzm {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 41px;
                                    height              : 24px;
                                    width               : 137px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 69px;
                                    transform           : rotate(0deg);
                                }
                                .ipadhomemenuhover .sectionhero .navbar .logo1-XFzm .adamoutline {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 99.27%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0.36%;
                                    transform           : rotate(0deg);
                                }
                                .ipadhomemenuhover .sectionhero .navbar .logo1-XFzm .adamoutline .shape {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 2.08%;
                                    height              : 95.83%;
                                    width               : 82.35%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .ipadhomemenuhover .sectionhero .navbar .logo1-XFzm .adamoutline .path {
                                    background-color    : rgba(255,255,255,0.0);
                                    right               : 0px;
                                    top                 : 18.75%;
                                    height              : 62.50%;
                                    width               : 11.03%;
                                    position            : absolute;
                                    margin              : 0;
                                    transform           : rotate(0deg);
                                }
                                .ipadhomemenuhover .sectionhero .navbar .logo1-XFzm .adamfill {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 2.08%;
                                    height              : 95.83%;
                                    width               : 98.54%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0.73%;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                }
                                .ipadhomemenuhover .sectionhero .navbar .logo1-XFzm .adamfill .shape1 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 2.17%;
                                    height              : 95.65%;
                                    width               : 81.48%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .ipadhomemenuhover .sectionhero .navbar .logo1-XFzm .adamfill .path1 {
                                    background-color    : rgba(255,255,255,0.0);
                                    right               : 0px;
                                    top                 : 15.22%;
                                    height              : 69.57%;
                                    width               : 11.11%;
                                    position            : absolute;
                                    margin              : 0;
                                    transform           : rotate(0deg);
                                }
                            </style>
                            <div id="7Qv3JMX">
                                <div class="logo1 logo1-XFzm component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                    <div class="adamoutline">
                                        <img alt="Image" class="shape" src="./img/ipad-home-menu-hover-shape-4@2x.png"/>
                                        <img alt="Image" class="path" src="./img/ipad-home-menu-hover-path-6@2x.png"/>
                                    </div>
                                    <div class="adamfill anima-hidden ">
                                        <img alt="Image" class="shape1" src="./img/ipad-home-shape-3@2x.png"/>
                                        <img alt="Image" class="path1" src="./img/ipad-home-path-7@2x.png"/>
                                    </div>
                                </div>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".ipadhomemenuhover .sectionhero .navbar .logo1-XFzm", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".adamfill": {
                "delay": 0, 
                "duration": 400, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".adamfill": {
                "delay": 0, 
                "duration": 500, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".adamfill": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                        </div>
                    </div>
                    <div class="group3">
                        <div class="rectangle">
                        </div>
                        <style>
                            .ipadhomemenuhover .group3 .workcopy-e23A * {
                                box-sizing          : border-box;
                            }
                            .ipadhomemenuhover .group3 .workcopy-e23A {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 149px;
                                height              : 332px;
                                width               : 134px;
                                position            : absolute;
                                margin              : 0;
                                left                : 51px;
                                transform           : rotate(0deg);
                            }
                            .ipadhomemenuhover .group3 .workcopy-e23A .work-I6vf {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 29.22%;
                                height              : 12.35%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .ipadhomemenuhover .group3 .workcopy-e23A .work-I6vf .work1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 20px);
                                height              : 40px;
                                width               : 99.25%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.37%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 28.0px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.78px;
                                line-height         : 34.0px;
                            }
                            .ipadhomemenuhover .group3 .workcopy-e23A .workcopy1-bnkx {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 12.35%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .ipadhomemenuhover .group3 .workcopy-e23A .workcopy1-bnkx .work1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 20px);
                                height              : 40px;
                                width               : 99.25%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.37%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 28.0px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.78px;
                                line-height         : 34.0px;
                            }
                            .ipadhomemenuhover .group3 .workcopy-e23A .workcopy2-awFo {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 29.22%;
                                height              : 12.35%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .ipadhomemenuhover .group3 .workcopy-e23A .workcopy2-awFo .work1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 20px);
                                height              : 40px;
                                width               : 99.25%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.37%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 28.0px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.78px;
                                line-height         : 34.0px;
                            }
                            .ipadhomemenuhover .group3 .workcopy-e23A .workcopy3-HPDA {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 0px;
                                height              : 12.35%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .ipadhomemenuhover .group3 .workcopy-e23A .workcopy3-HPDA .work1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 20px);
                                height              : 40px;
                                width               : 99.25%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.37%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 28.0px;
                                color               : rgba(255, 255, 255, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.78px;
                                line-height         : 34.0px;
                            }
                        </style>
                        <div id="tXKqBJ0">
                            <div anima-show-on-scroll="" class="workcopy anima-animate-enter13 workcopy-e23A component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                <a href="work.html">
                                    <div anima-show-on-scroll="" class="work anima-animate-enter10 work-I6vf component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <div class="work1 anima-valign-text-middle">
                                            Work
                                        </div>
                                    </div>
                                </a>
                                <a href="home.html">
                                    <div anima-show-on-scroll="" class="workcopy1 anima-animate-enter11 workcopy1-bnkx component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <div class="work1 anima-valign-text-middle">
                                            Home
                                        </div>
                                    </div>
                                </a>
                                <a href="about.html">
                                    <div anima-show-on-scroll="" class="workcopy2 anima-animate-enter12 workcopy2-awFo component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <div class="work1 anima-valign-text-middle">
                                            About
                                        </div>
                                    </div>
                                </a>
                                <a href="https://drive.google.com/file/d/1KxPEStKpGkBtJaURrrckkRjVntkcITWU/view?usp=sharing" target="_blank">
                                    <div class="workcopy3 workcopy3-HPDA component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <div class="work1 anima-valign-text-middle">
                                            Resume
                                        </div>
                                    </div>
                                </a>
                            </div>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".ipadhomemenuhover .group3 .workcopy-e23A", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {}, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {}, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ".work-I6vf"
          }
        ], 
        "overrides": {}
      }
    }
  }, 
  {
    "initial_state_name": "state1", 
    "root_element": ".ipadhomemenuhover .group3 .workcopy-e23A .work-I6vf", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {}, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {}, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ".work1"
          }
        ], 
        "overrides": {}
      }
    }
  }, 
  {
    "initial_state_name": "state1", 
    "root_element": ".ipadhomemenuhover .group3 .workcopy-e23A .workcopy1-bnkx", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {}, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {}, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ".work1"
          }
        ], 
        "overrides": {}
      }
    }
  }, 
  {
    "initial_state_name": "state1", 
    "root_element": ".ipadhomemenuhover .group3 .workcopy-e23A .workcopy2-awFo", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {}, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {}, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ".work1"
          }
        ], 
        "overrides": {}
      }
    }
  }, 
  {
    "initial_state_name": "state1", 
    "root_element": ".ipadhomemenuhover .group3 .workcopy-e23A .workcopy3-HPDA", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {}, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {}, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ".work1"
          }
        ], 
        "overrides": {}
      }
    }
  }
];
})();
                        </script>
                        <a href="javascript:animaHideOverlay('ipadhomemenuhover', 'anima-animate-disappear');">
                            <div class="group2">
                                <img alt="Image" anima-src="./img/ipad-home-menu-hover-path-8@2x.png" class="path" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                                <img alt="Image" anima-src="./img/ipad-home-menu-hover-path-8@2x.png" class="path1" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                            </div>
                        </a>
                    </div>
                    <div anima-show-on-scroll="" class="h3">
                        Â© 2020 Lil Adam X
                    </div>
                    <style>
                        .ipadhomemenuhover .logo-csvI * {
                            box-sizing          : border-box;
                        }
                        .ipadhomemenuhover .logo-csvI {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 41px;
                            height              : 24px;
                            width               : 137px;
                            position            : absolute;
                            margin              : 0;
                            left                : 50px;
                            transform           : rotate(0deg);
                        }
                        .ipadhomemenuhover .logo-csvI .adamoutline {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 0px;
                            height              : 100%;
                            width               : 99.27%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0.36%;
                            transform           : rotate(0deg);
                        }
                        .ipadhomemenuhover .logo-csvI .adamoutline .shape {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 2.08%;
                            height              : 95.83%;
                            width               : 82.35%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0px;
                            transform           : rotate(0deg);
                        }
                        .ipadhomemenuhover .logo-csvI .adamoutline .path {
                            background-color    : rgba(255,255,255,0.0);
                            right               : 0px;
                            top                 : 18.75%;
                            height              : 62.50%;
                            width               : 11.03%;
                            position            : absolute;
                            margin              : 0;
                            transform           : rotate(0deg);
                        }
                        .ipadhomemenuhover .logo-csvI .adamfill {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 2.08%;
                            height              : 95.83%;
                            width               : 98.54%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0.73%;
                            transform           : rotate(0deg);
                            opacity             : 0.0;
                        }
                        .ipadhomemenuhover .logo-csvI .adamfill .shape1 {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 2.17%;
                            height              : 95.65%;
                            width               : 81.48%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0px;
                            transform           : rotate(0deg);
                        }
                        .ipadhomemenuhover .logo-csvI .adamfill .path1 {
                            background-color    : rgba(255,255,255,0.0);
                            right               : 0px;
                            top                 : 15.22%;
                            height              : 69.57%;
                            width               : 11.11%;
                            position            : absolute;
                            margin              : 0;
                            transform           : rotate(0deg);
                        }
                    </style>
                    <div id="7eTYg9D">
                        <a href="home.html">
                            <div class="logo logo-csvI component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                <div class="adamoutline">
                                    <img alt="Image" class="shape" src="./img/ipad-home-menu-hover-shape-4@2x.png"/>
                                    <img alt="Image" class="path" src="./img/ipad-home-menu-hover-path-6@2x.png"/>
                                </div>
                                <div class="adamfill anima-hidden ">
                                    <img alt="Image" class="shape1" src="./img/ipad-home-shape-3@2x.png"/>
                                    <img alt="Image" class="path1" src="./img/ipad-home-path-7@2x.png"/>
                                </div>
                            </div>
                        </a>
                    </div>
                    <script>
      (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".ipadhomemenuhover .logo-csvI", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".adamfill": {
                "delay": 0, 
                "duration": 400, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".adamfill": {
                "delay": 0, 
                "duration": 500, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".adamfill": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                    </script>
                </div>
            </div>
        </div>
        <script>
   var overlay_id = "overlay-ipadhomemenuhover";
  document.getElementById(overlay_id).addEventListener("click", function( event ) {
    var e = event || window.event;
    var clickedDiv = e.toElement || e.target;
    if (clickedDiv.parentElement.id == overlay_id) {
        animaHideOverlay('ipadhomemenuhover', 'anima-animate-disappear');
    }
  }, false);
        </script>
        <!-- Scripts -->
        <script>
   anima_isHidden=function(e){if(!(e instanceof HTMLElement))return!1;if(getComputedStyle(e).display=="none")return!0;else if(e.parentNode&&anima_isHidden(e.parentNode))return!0;return!1};anima_loadAsyncSrcForTag=function(tag){var elements=document.getElementsByTagName(tag);var toLoad=[];for(var i=0;i<elements.length;i++){var e=elements[i];var src=e.getAttribute("src");var loaded=(src!=undefined&&src.length>0&&src!='data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==');if(loaded)continue;var asyncSrc=e.getAttribute("anima-src");if(asyncSrc==undefined||asyncSrc.length==0)continue;if(anima_isHidden(e))continue;toLoad.push(e)}
toLoad.sort(function(a,b){return anima_getTop(a)-anima_getTop(b)});for(var i=0;i<toLoad.length;i++){var e=toLoad[i];var asyncSrc=e.getAttribute("anima-src");e.setAttribute("src",asyncSrc)}};anima_pauseHiddenVideos=function(tag){var elements=document.getElementsByTagName("video");for(var i=0;i<elements.length;i++){var e=elements[i];var isPlaying=!!(e.currentTime>0&&!e.paused&&!e.ended&&e.readyState>2);var isHidden=anima_isHidden(e);if(!isPlaying&&!isHidden&&e.getAttribute("autoplay")=="autoplay"){e.play()}
else if(isPlaying&&isHidden){e.pause()}}};anima_loadAsyncSrc=function(tag){anima_loadAsyncSrcForTag("img");anima_loadAsyncSrcForTag("iframe");anima_loadAsyncSrcForTag("video");anima_pauseHiddenVideos()};var anima_getTop=function(e){var top=0;do{top+=e.offsetTop||0;e=e.offsetParent}while(e);return top};anima_loadAsyncSrc();anima_old_onResize=window.onresize;anima_new_onResize=undefined;anima_updateOnResize=function(){if(anima_new_onResize==undefined||window.onresize!=anima_new_onResize){anima_new_onResize=function(x){if(anima_old_onResize!=undefined)anima_old_onResize(x);anima_loadAsyncSrc()}
window.onresize=anima_new_onResize;setTimeout(function(){anima_updateOnResize()},3000)}};anima_updateOnResize();setTimeout(function(){anima_loadAsyncSrc()},200)
        </script>
        <script>
   animaShowOverlay = function(overlayName, animationName) {
        overlayName = 'overlay-' + overlayName;
        var cssClasses = document.getElementById(overlayName).className.split(' ');
        var last = cssClasses.slice(-1)[0];
        if (last.lastIndexOf('anima-animate') == -1) {
            document.getElementById(overlayName).className = document.getElementById(overlayName).className + " " + animationName;
        }
        if (window.anima_loadAsyncSrc != undefined) {
            anima_loadAsyncSrc();
        }
    };
    animaHideOverlay = function(overlayName, animationName) {
        overlayName = 'overlay-' + overlayName;
        var cssClasses = document.getElementById(overlayName).className.split(' ');
        var last = cssClasses.slice(-1)[0];
        if (last.lastIndexOf('anima-animate') != -1) {
            cssClasses.splice(-1)
            cssClasses.push(animationName)
            document.getElementById(overlayName).className = cssClasses.join(' ');
            cssClasses.splice(-1)
            setTimeout(function() {
                document.getElementById(overlayName).className = cssClasses.join(' ');
            }, 1100);
        }
        var vids = document.getElementsByTagName('video');
        if (vids) {
            for( var i = 0; i < vids.length; i++ ) {
                var video = vids.item(i);
                video.pause();
            }
        }
    };
        </script>
        <!-- End of Scripts -->
    </body>
</html>
