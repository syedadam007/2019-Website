<!DOCTYPE html>
<html>
    <head>
        <link href="./img/favicon.png" rel="shortcut icon"/>
        <meta charset="utf-8"/>
        <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0" name="viewport"/>
        <title>
            Adam's Website
        </title>
        <!-- Facebook -->
        <meta content="Adam's Website" property="og:site_name"/>
        <meta content="Adam's Website" property="og:title"/>
        <meta content="" property="og:url"/>
        <meta content="website" property="og:type"/>
        <link href="./css/ipadLightMenuHover.css" rel="stylesheet" type="text/css"/>
        <link href="./css/iphoneXMenuLightHover.css" rel="stylesheet" type="text/css"/>
        <link href="./css/playground.css" rel="stylesheet" type="text/css"/>
        <meta content="AnimaApp.com - Design to code, Automated." name="author"/>
    </head>
    <body style="margin: 0;
 background: rgba(16, 16, 16, 1.0);">
        <input id="anPageName" name="page" type="hidden" value="playground"/>
        <div class="bp1-playground anima-word-break ">
            <div style="width: 1920px; height: 100%; position:relative; margin:auto;">
                <div class="bp1-group">
                    <div class="bp1-whitebg">
                    </div>
                    <div class="bp1-projectbrief">
                        <div class="bp1-projecttitle">
                            <div anima-show-on-scroll="" class="bp1-h1">
                                Playground
                            </div>
                            <div anima-show-on-scroll="" class="bp1-missioncopy">
                                Welcome to Adamâ€™s playground where creative freedom has no limit. Here you are guided by imagination, not instruction.
                            </div>
                            <div anima-show-on-scroll="" class="bp1-missioncopy2">
                                CREATIVE SPACE
                            </div>
                        </div>
                    </div>
                    <a href="https://www.instagram.com/p/B-xvzyRJafV/" target="_blank">
                        <div class="bp1-spotify">
                            <div class="bp1-mask1">
                            </div>
                            <img alt="Image" anima-src="./img/playground-spotify.png" class="bp1-spotify1" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                        </div>
                    </a>
                    <a href="https://www.instagram.com/p/B-Bzi3cJtA_/" target="_blank">
                        <div class="bp1-mask">
                            <video anima-src="https://anima-uploads.s3.amazonaws.com/projects/5ea00c44c3550fe87c79bb5a/files/saucy.mp4" autoplay="autoplay" loop="" muted="" playsinline="" src="">
                            </video>
                        </div>
                    </a>
                    <a href="https://vimeo.com/400892225" target="_blank">
                        <div class="bp1-rectanglecopy">
                            <video anima-src="https://anima-uploads.s3.amazonaws.com/projects/5ea00c44c3550fe87c79bb5a/files/delorean.mp4" autoplay="autoplay" loop="" muted="" playsinline="" src="">
                            </video>
                        </div>
                    </a>
                    <a href="https://vimeo.com/400892288" target="_blank">
                        <div class="bp1-rectanglecopy2">
                            <video anima-src="https://anima-uploads.s3.amazonaws.com/projects/5ea00c44c3550fe87c79bb5a/files/synthwave.mp4" autoplay="autoplay" loop="" muted="" playsinline="" src="">
                            </video>
                        </div>
                    </a>
                    <a href="https://huecollective.co/" target="_blank">
                        <div class="bp1-rectanglecopy4">
                            <video anima-src="https://anima-uploads.s3.amazonaws.com/projects/5ea00c44c3550fe87c79bb5a/files/hue-spectrum.mp4" autoplay="autoplay" loop="" muted="" playsinline="" src="">
                            </video>
                        </div>
                    </a>
                    <a href="https://huecollective.co/" target="_blank">
                        <div class="bp1-rectanglecopy3">
                            <video anima-src="https://anima-uploads.s3.amazonaws.com/projects/5ea00c44c3550fe87c79bb5a/files/hue-collective.mp4
" autoplay="autoplay" loop="" muted="" playsinline="" src="">
                            </video>
                        </div>
                    </a>
                    <a href="https://lsstudios.itch.io/unit-108" target="_blank">
                        <div class="bp1-rectanglecopy5">
                            <img anima-src="https://anima-uploads.s3.amazonaws.com/projects/5ea00c44c3550fe87c79bb5a/files/weaponselect.gif" height="100%" src="" width="100%"/>
                        </div>
                    </a>
                    <a href="https://lsstudios.itch.io/unit-108" target="_blank">
                        <div class="bp1-rectanglecopy6">
                            <img anima-src="https://anima-uploads.s3.amazonaws.com/projects/5ea00c44c3550fe87c79bb5a/files/mainmenu.gif" height="100%" src="" width="100%"/>
                        </div>
                    </a>
                </div>
                <style>
                    .bp1-playground .bp1-seemore-Mklu * {
                        box-sizing          : border-box;
                    }
                    .bp1-playground .bp1-seemore-Mklu {
                        background-color    : rgba(255,255,255,0.0);
                        top                 : 4230px;
                        height              : 30px;
                        width               : 317px;
                        position            : absolute;
                        margin              : 0;
                        left                : 130px;
                        transform           : rotate(0deg);
                    }
                    .bp1-playground .bp1-seemore-Mklu .bp1-seemore1 {
                        background-color    : rgba(255,255,255,0.0);
                        top                 : 0px;
                        height              : 100%;
                        width               : 100%;
                        position            : absolute;
                        margin              : 0;
                        left                : 0px;
                        transform           : rotate(0deg);
                    }
                    .bp1-playground .bp1-seemore-Mklu .bp1-seemore1 .bp1-back {
                        background-color    : rgba(255,255,255,0.0);
                        top                 : calc(50.00% - 15px);
                        height              : 30px;
                        width               : 83.60%;
                        position            : absolute;
                        margin              : 0;
                        left                : 0px;
                        transform           : rotate(0deg);
                        font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                        font-size           : 30.0px;
                        color               : rgba(0, 0, 0, 1.0);
                        text-align          : left;
                        letter-spacing      : 0.58px;
                        line-height         : 36.0px;
                    }
                    .bp1-playground .bp1-seemore-Mklu .bp1-seemore1 .bp1-a109617 {
                        background-color    : rgba(255,255,255,0.0);
                        right               : 0px;
                        top                 : 11.67%;
                        height              : 76.67%;
                        width               : 10.09%;
                        position            : absolute;
                        margin              : 0;
                        transform           : rotate(0deg);
                    }
                    .bp1-playground .bp1-seemore-Mklu .bp1-seemore1 .bp1-a109617 .bp1-path {
                        background-color    : rgba(255,255,255,0.0);
                        top                 : 2.17%;
                        height              : 95.65%;
                        width               : 96.88%;
                        position            : absolute;
                        margin              : 0;
                        left                : 1.56%;
                        transform           : rotate(0deg);
                    }
                    .bp1-playground .bp1-seemore-Mklu .bp1-seemorehover {
                        background-color    : rgba(255,255,255,0.0);
                        top                 : 0px;
                        height              : 100%;
                        width               : 100%;
                        position            : absolute;
                        margin              : 0;
                        left                : 0px;
                        transform           : rotate(0deg);
                        opacity             : 0.0;
                    }
                    .bp1-playground .bp1-seemore-Mklu .bp1-seemorehover .bp1-back1 {
                        background-color    : rgba(255,255,255,0.0);
                        top                 : calc(50.00% - 15px);
                        height              : 30px;
                        width               : 83.60%;
                        position            : absolute;
                        margin              : 0;
                        left                : 0px;
                        transform           : rotate(0deg);
                        font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                        font-size           : 30.0px;
                        color               : rgba(126, 126, 126, 1.0);
                        text-align          : left;
                        letter-spacing      : 0.58px;
                        line-height         : 36.0px;
                    }
                    .bp1-playground .bp1-seemore-Mklu .bp1-seemorehover .bp1-a1096171 {
                        background-color    : rgba(255,255,255,0.0);
                        right               : 0px;
                        top                 : 11.67%;
                        height              : 76.67%;
                        width               : 10.09%;
                        position            : absolute;
                        margin              : 0;
                        transform           : rotate(0deg);
                    }
                    .bp1-playground .bp1-seemore-Mklu .bp1-seemorehover .bp1-a1096171 .bp1-path1 {
                        background-color    : rgba(255,255,255,0.0);
                        top                 : 2.17%;
                        height              : 95.65%;
                        width               : 96.88%;
                        position            : absolute;
                        margin              : 0;
                        left                : 1.56%;
                        transform           : rotate(0deg);
                    }
                </style>
                <div id="1bxKcs6">
                    <a href="work.html">
                        <div class="bp1-seemore bp1-seemore-Mklu component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                            <div class="bp1-seemore1">
                                <div anima-show-on-scroll="" class="bp1-back">
                                    I want to see more
                                </div>
                                <div class="bp1-a109617">
                                    <img alt="Image" class="bp1-path" src="./img/designco-path@2x.png"/>
                                </div>
                            </div>
                            <div class="bp1-seemorehover anima-hidden ">
                                <div anima-show-on-scroll="" class="bp1-back1">
                                    I want to see more
                                </div>
                                <div class="bp1-a1096171">
                                    <img alt="Image" class="bp1-path1" src="./img/sslrpdeals-path-1@2x.png"/>
                                </div>
                            </div>
                        </div>
                    </a>
                </div>
                <script>
     (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp1-playground .bp1-seemore-Mklu", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp1-seemorehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp1-seemorehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp1-seemorehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                </script>
                <div class="bp1-sectionfooter">
                    <img alt="Image" anima-src="./img/swiftrides-bg.png" class="bp1-bg" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                    <div class="bp1-footer">
                        <div class="bp1-socialicons">
                            <style>
                                .bp1-playground .bp1-sectionfooter .bp1-footer .bp1-socialicons .bp1-dribbble-KhJl * {
                                    box-sizing          : border-box;
                                }
                                .bp1-playground .bp1-sectionfooter .bp1-footer .bp1-socialicons .bp1-dribbble-KhJl {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 60px;
                                    width               : 60px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 120px;
                                    transform           : rotate(0deg);
                                }
                                .bp1-playground .bp1-sectionfooter .bp1-footer .bp1-socialicons .bp1-dribbble-KhJl .bp1-shape {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .bp1-playground .bp1-sectionfooter .bp1-footer .bp1-socialicons .bp1-dribbble-KhJl .bp1-shapehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                }
                            </style>
                            <div id="WO46WCS">
                                <a href="https://dribbble.com/syedadam007" target="_blank">
                                    <div class="bp1-dribbble bp1-dribbble-KhJl component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <img alt="Image" class="bp1-shape" src="./img/swiftrides-shape@2x.png"/>
                                        <img alt="Image" class="bp1-shapehover anima-hidden " src="./img/adobe-shapehover@2x.png"/>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp1-playground .bp1-sectionfooter .bp1-footer .bp1-socialicons .bp1-dribbble-KhJl", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp1-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp1-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp1-shapehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <style>
                                .bp1-playground .bp1-sectionfooter .bp1-footer .bp1-socialicons .bp1-linkedin-NeSN * {
                                    box-sizing          : border-box;
                                }
                                .bp1-playground .bp1-sectionfooter .bp1-footer .bp1-socialicons .bp1-linkedin-NeSN {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 60px;
                                    width               : 60px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .bp1-playground .bp1-sectionfooter .bp1-footer .bp1-socialicons .bp1-linkedin-NeSN .bp1-shape {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .bp1-playground .bp1-sectionfooter .bp1-footer .bp1-socialicons .bp1-linkedin-NeSN .bp1-shapehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                }
                            </style>
                            <div id="YKiE6od">
                                <a href="https://www.linkedin.com/in/syedadamemirputra/" target="_blank">
                                    <div class="bp1-linkedin bp1-linkedin-NeSN component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <img alt="Image" class="bp1-shape" src="./img/sslrpdeals-shape-3@2x.png"/>
                                        <img alt="Image" class="bp1-shapehover anima-hidden " src="./img/about-shapehover-1@2x.png"/>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp1-playground .bp1-sectionfooter .bp1-footer .bp1-socialicons .bp1-linkedin-NeSN", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp1-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp1-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp1-shapehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <style>
                                .bp1-playground .bp1-sectionfooter .bp1-footer .bp1-socialicons .bp1-instagram-GtgL * {
                                    box-sizing          : border-box;
                                }
                                .bp1-playground .bp1-sectionfooter .bp1-footer .bp1-socialicons .bp1-instagram-GtgL {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 1px;
                                    height              : 59px;
                                    width               : 60px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 240px;
                                    transform           : rotate(0deg);
                                }
                                .bp1-playground .bp1-sectionfooter .bp1-footer .bp1-socialicons .bp1-instagram-GtgL .bp1-shape {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .bp1-playground .bp1-sectionfooter .bp1-footer .bp1-socialicons .bp1-instagram-GtgL .bp1-shapehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                }
                            </style>
                            <div id="XbzIcJ4">
                                <a href="https://www.instagram.com/syedadam007/" target="_blank">
                                    <div class="bp1-instagram bp1-instagram-GtgL component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <img alt="Image" class="bp1-shape" src="./img/adobe-shape-2@2x.png"/>
                                        <img alt="Image" class="bp1-shapehover anima-hidden " src="./img/sslrpdeals-shapehover-2@2x.png"/>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp1-playground .bp1-sectionfooter .bp1-footer .bp1-socialicons .bp1-instagram-GtgL", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp1-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp1-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp1-shapehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                        </div>
                        <div anima-show-on-scroll="" class="bp1-h3">
                            Â© 2020 Lil Adam X
                        </div>
                    </div>
                </div>
                <div class="bp1-navbarwork">
                    <style>
                        .bp1-playground .bp1-navbarwork .bp1-back-QhPl * {
                            box-sizing          : border-box;
                        }
                        .bp1-playground .bp1-navbarwork .bp1-back-QhPl {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 7px;
                            height              : 30px;
                            width               : 72px;
                            position            : absolute;
                            margin              : 0;
                            left                : 0px;
                            transform           : rotate(0deg);
                        }
                        .bp1-playground .bp1-navbarwork .bp1-back-QhPl .bp1-back1 {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : calc(50.00% - 15px);
                            height              : 30px;
                            width               : 100%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0px;
                            transform           : rotate(0deg);
                            font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                            font-size           : 30.0px;
                            color               : rgba(16, 16, 16, 1.0);
                            text-align          : left;
                            letter-spacing      : 0.58px;
                            line-height         : 36.0px;
                        }
                        .bp1-playground .bp1-navbarwork .bp1-back-QhPl .bp1-backhover {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : calc(50.00% - 15px);
                            height              : 30px;
                            width               : 100%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0px;
                            transform           : rotate(0deg);
                            opacity             : 0.0;
                            font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                            font-size           : 30.0px;
                            color               : rgba(126, 126, 126, 1.0);
                            text-align          : left;
                            letter-spacing      : 0.58px;
                            line-height         : 36.0px;
                        }
                    </style>
                    <div id="BGRq7xS">
                        <a href="javascript:history.back()">
                            <div class="bp1-back bp1-back-QhPl component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                <div anima-show-on-scroll="" class="bp1-back1">
                                    Back
                                </div>
                                <div anima-show-on-scroll="" class="bp1-backhover anima-hidden ">
                                    Back
                                </div>
                            </div>
                        </a>
                    </div>
                    <script>
      (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp1-playground .bp1-navbarwork .bp1-back-QhPl", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp1-backhover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp1-backhover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp1-backhover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                    </script>
                    <style>
                        .bp1-playground .bp1-navbarwork .bp1-logo-Zmoy * {
                            box-sizing          : border-box;
                        }
                        .bp1-playground .bp1-navbarwork .bp1-logo-Zmoy {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 0px;
                            height              : 44px;
                            width               : 256px;
                            position            : absolute;
                            margin              : 0;
                            left                : 1405px;
                            transform           : rotate(0deg);
                        }
                        .bp1-playground .bp1-navbarwork .bp1-logo-Zmoy .bp1-adamoutline {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 0px;
                            height              : 100%;
                            width               : 99.61%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0px;
                            transform           : rotate(0deg);
                        }
                        .bp1-playground .bp1-navbarwork .bp1-logo-Zmoy .bp1-adamoutline .bp1-shape {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 1.14%;
                            height              : 97.73%;
                            width               : 82.35%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0px;
                            transform           : rotate(0deg);
                        }
                        .bp1-playground .bp1-navbarwork .bp1-logo-Zmoy .bp1-adamoutline .bp1-path {
                            background-color    : rgba(255,255,255,0.0);
                            right               : 0.39%;
                            bottom              : 13.64%;
                            height              : 65.91%;
                            width               : 10.98%;
                            position            : absolute;
                            margin              : 0;
                            transform           : rotate(0deg);
                        }
                        .bp1-playground .bp1-navbarwork .bp1-logo-Zmoy .bp1-adamfill {
                            background-color    : rgba(255,255,255,0.0);
                            right               : 0px;
                            top                 : 2.27%;
                            height              : 95.45%;
                            width               : 99.22%;
                            position            : absolute;
                            margin              : 0;
                            transform           : rotate(0deg);
                            opacity             : 0.0;
                        }
                        .bp1-playground .bp1-navbarwork .bp1-logo-Zmoy .bp1-adamfill .bp1-shape1 {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 0px;
                            height              : 100%;
                            width               : 81.50%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0px;
                            transform           : rotate(0deg);
                        }
                        .bp1-playground .bp1-navbarwork .bp1-logo-Zmoy .bp1-adamfill .bp1-path1 {
                            background-color    : rgba(255,255,255,0.0);
                            right               : 0.39%;
                            bottom              : 11.90%;
                            height              : 71.43%;
                            width               : 11.42%;
                            position            : absolute;
                            margin              : 0;
                            transform           : rotate(0deg);
                        }
                    </style>
                    <div id="00PlRhQ">
                        <a href="home.html">
                            <div class="bp1-logo bp1-logo-Zmoy component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                <div class="bp1-adamoutline">
                                    <img alt="Image" class="bp1-shape" src="./img/playground-shape-3@2x.png"/>
                                    <img alt="Image" class="bp1-path" src="./img/designco-path-2@2x.png"/>
                                </div>
                                <div class="bp1-adamfill anima-hidden ">
                                    <img alt="Image" class="bp1-shape1" src="./img/swiftrides-shape-4@2x.png"/>
                                    <img alt="Image" class="bp1-path1" src="./img/swiftrides-path-3@2x.png"/>
                                </div>
                            </div>
                        </a>
                    </div>
                    <script>
      (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp1-playground .bp1-navbarwork .bp1-logo-Zmoy", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp1-adamfill": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp1-adamfill": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp1-adamfill": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                    </script>
                </div>
            </div>
        </div>
        <div class="bp5-ipadplayground anima-word-break ">
            <div style="width: 768px; height: 100%; position:relative; margin:auto;">
                <div class="bp5-sectionhero" id="None">
                    <div class="bp5-navbar">
                        <div class="bp5-rectangle">
                        </div>
                        <style>
                            .bp5-ipadplayground .bp5-sectionhero .bp5-navbar .bp5-logo-GbvR * {
                                box-sizing          : border-box;
                            }
                            .bp5-ipadplayground .bp5-sectionhero .bp5-navbar .bp5-logo-GbvR {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 41px;
                                height              : 23px;
                                width               : 135px;
                                position            : absolute;
                                margin              : 0;
                                left                : 50px;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadplayground .bp5-sectionhero .bp5-navbar .bp5-logo-GbvR .bp5-adamoutline {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadplayground .bp5-sectionhero .bp5-navbar .bp5-logo-GbvR .bp5-adamoutline .bp5-shape1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 82.22%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadplayground .bp5-sectionhero .bp5-navbar .bp5-logo-GbvR .bp5-adamoutline .bp5-path {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 0.74%;
                                bottom              : 13.04%;
                                height              : 65.22%;
                                width               : 11.11%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadplayground .bp5-sectionhero .bp5-navbar .bp5-logo-GbvR .bp5-adamfill {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 2.17%;
                                height              : 95.65%;
                                width               : 99.26%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.37%;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                            }
                            .bp5-ipadplayground .bp5-sectionhero .bp5-navbar .bp5-logo-GbvR .bp5-adamfill .bp5-shape1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 81.34%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp5-ipadplayground .bp5-sectionhero .bp5-navbar .bp5-logo-GbvR .bp5-adamfill .bp5-path1 {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 0.75%;
                                bottom              : 9.09%;
                                height              : 72.73%;
                                width               : 11.19%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                        </style>
                        <div id="lBbtPiO">
                            <a href="home.html">
                                <div class="bp5-logo bp5-logo-GbvR component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                    <div class="bp5-adamoutline">
                                        <img alt="Image" class="bp5-shape1" src="./img/ipad-sslrpdeals-shape@2x.png"/>
                                        <img alt="Image" class="bp5-path" src="./img/ipad-sslrpdeals-path-2@2x.png"/>
                                    </div>
                                    <div class="bp5-adamfill anima-hidden ">
                                        <img alt="Image" class="bp5-shape1" src="./img/ipad-playground-shape-1@2x.png"/>
                                        <img alt="Image" class="bp5-path1" src="./img/ipad-adobe-path-1@2x.png"/>
                                    </div>
                                </div>
                            </a>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp5-ipadplayground .bp5-sectionhero .bp5-navbar .bp5-logo-GbvR", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp5-adamfill": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp5-adamfill": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp5-adamfill": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                        <a href="javascript:animaShowOverlay('ipadlightmenuhover', 'anima-animate-appear'); anima_loadAsyncSrc(); ">
                            <img alt="Image" anima-src="./img/ipad-swiftrides-shape-2@2x.png" class="bp5-shape" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                        </a>
                    </div>
                </div>
                <div class="bp5-sectionfooter">
                    <img alt="Image" anima-src="./img/ipad-swiftrides-bg.png" class="bp5-bg" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                    <div class="bp5-footer">
                        <div class="bp5-socialicons">
                            <style>
                                .bp5-ipadplayground .bp5-sectionfooter .bp5-footer .bp5-socialicons .bp5-dribbble-lmez * {
                                    box-sizing          : border-box;
                                }
                                .bp5-ipadplayground .bp5-sectionfooter .bp5-footer .bp5-socialicons .bp5-dribbble-lmez {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 24px;
                                    width               : 24px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 48px;
                                    transform           : rotate(0deg);
                                }
                                .bp5-ipadplayground .bp5-sectionfooter .bp5-footer .bp5-socialicons .bp5-dribbble-lmez .bp5-shape {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .bp5-ipadplayground .bp5-sectionfooter .bp5-footer .bp5-socialicons .bp5-dribbble-lmez .bp5-shapehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                }
                            </style>
                            <div id="MiyTCu3">
                                <a href="https://dribbble.com/syedadam007" target="_blank">
                                    <div class="bp5-dribbble bp5-dribbble-lmez component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <img alt="Image" class="bp5-shape" src="./img/ipad-adobe-shape-3@2x.png"/>
                                        <img alt="Image" class="bp5-shapehover anima-hidden " src="./img/ipad-sslrpdeals-shapehover@2x.png"/>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp5-ipadplayground .bp5-sectionfooter .bp5-footer .bp5-socialicons .bp5-dribbble-lmez", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp5-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp5-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp5-shapehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <style>
                                .bp5-ipadplayground .bp5-sectionfooter .bp5-footer .bp5-socialicons .bp5-linkedin-mn83 * {
                                    box-sizing          : border-box;
                                }
                                .bp5-ipadplayground .bp5-sectionfooter .bp5-footer .bp5-socialicons .bp5-linkedin-mn83 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 24px;
                                    width               : 24px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .bp5-ipadplayground .bp5-sectionfooter .bp5-footer .bp5-socialicons .bp5-linkedin-mn83 .bp5-shape {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .bp5-ipadplayground .bp5-sectionfooter .bp5-footer .bp5-socialicons .bp5-linkedin-mn83 .bp5-shapehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                }
                            </style>
                            <div id="Yn3d1Iu">
                                <a href="https://www.linkedin.com/in/syedadamemirputra/" target="_blank">
                                    <div class="bp5-linkedin bp5-linkedin-mn83 component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <img alt="Image" class="bp5-shape" src="./img/ipad-swiftrides-shape-4@2x.png"/>
                                        <img alt="Image" class="bp5-shapehover anima-hidden " src="./img/ipad-about-shapehover-1@2x.png"/>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp5-ipadplayground .bp5-sectionfooter .bp5-footer .bp5-socialicons .bp5-linkedin-mn83", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp5-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp5-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp5-shapehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <style>
                                .bp5-ipadplayground .bp5-sectionfooter .bp5-footer .bp5-socialicons .bp5-instagram-yV8H * {
                                    box-sizing          : border-box;
                                }
                                .bp5-ipadplayground .bp5-sectionfooter .bp5-footer .bp5-socialicons .bp5-instagram-yV8H {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 24px;
                                    width               : 24px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 95px;
                                    transform           : rotate(0deg);
                                }
                                .bp5-ipadplayground .bp5-sectionfooter .bp5-footer .bp5-socialicons .bp5-instagram-yV8H .bp5-shape {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 2.08%;
                                    height              : 95.83%;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .bp5-ipadplayground .bp5-sectionfooter .bp5-footer .bp5-socialicons .bp5-instagram-yV8H .bp5-shapehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 2.08%;
                                    height              : 95.83%;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                }
                            </style>
                            <div id="QpPIrZi">
                                <a href="https://www.instagram.com/syedadam007/" target="_blank">
                                    <div class="bp5-instagram bp5-instagram-yV8H component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <img alt="Image" class="bp5-shape" src="./img/ipad-adobe-shape-5@2x.png"/>
                                        <img alt="Image" class="bp5-shapehover anima-hidden " src="./img/ipad-adobe-shapehover-2@2x.png"/>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp5-ipadplayground .bp5-sectionfooter .bp5-footer .bp5-socialicons .bp5-instagram-yV8H", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp5-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp5-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp5-shapehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                        </div>
                        <div anima-show-on-scroll="" class="bp5-h3">
                            Â© 2020 Lil Adam X
                        </div>
                    </div>
                </div>
                <style>
                    .bp5-ipadplayground .bp5-seemore-pwQ6 * {
                        box-sizing          : border-box;
                    }
                    .bp5-ipadplayground .bp5-seemore-pwQ6 {
                        background-color    : rgba(255,255,255,0.0);
                        top                 : 1803px;
                        height              : 15px;
                        width               : 160px;
                        position            : absolute;
                        margin              : 0;
                        left                : 53px;
                        transform           : rotate(0deg);
                    }
                    .bp5-ipadplayground .bp5-seemore-pwQ6 .bp5-seemore1 {
                        background-color    : rgba(255,255,255,0.0);
                        top                 : 0px;
                        height              : 100%;
                        width               : 100%;
                        position            : absolute;
                        margin              : 0;
                        left                : 0px;
                        transform           : rotate(0deg);
                    }
                    .bp5-ipadplayground .bp5-seemore-pwQ6 .bp5-seemore1 .bp5-back {
                        background-color    : rgba(255,255,255,0.0);
                        top                 : calc(50.00% - 8px);
                        height              : 15px;
                        width               : 90.62%;
                        position            : absolute;
                        margin              : 0;
                        left                : 0px;
                        transform           : rotate(0deg);
                        font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                        font-size           : 15.12px;
                        color               : rgba(0, 0, 0, 1.0);
                        text-align          : left;
                        letter-spacing      : 0.29px;
                        line-height         : 18.0px;
                    }
                    .bp5-ipadplayground .bp5-seemore-pwQ6 .bp5-seemore1 .bp5-a109617 {
                        background-color    : rgba(255,255,255,0.0);
                        right               : 0px;
                        top                 : 10.00%;
                        height              : 80.00%;
                        width               : 10.00%;
                        position            : absolute;
                        margin              : 0;
                        transform           : rotate(0deg);
                    }
                    .bp5-ipadplayground .bp5-seemore-pwQ6 .bp5-seemore1 .bp5-a109617 .bp5-path {
                        background-color    : rgba(255,255,255,0.0);
                        top                 : 4.17%;
                        height              : 91.67%;
                        width               : 100%;
                        position            : absolute;
                        margin              : 0;
                        left                : 0px;
                        transform           : rotate(0deg);
                    }
                    .bp5-ipadplayground .bp5-seemore-pwQ6 .bp5-seemorehover {
                        background-color    : rgba(255,255,255,0.0);
                        top                 : 0px;
                        height              : 100%;
                        width               : 100%;
                        position            : absolute;
                        margin              : 0;
                        left                : 0px;
                        transform           : rotate(0deg);
                        opacity             : 0.0;
                    }
                    .bp5-ipadplayground .bp5-seemore-pwQ6 .bp5-seemorehover .bp5-back1 {
                        background-color    : rgba(255,255,255,0.0);
                        top                 : calc(50.00% - 8px);
                        height              : 15px;
                        width               : 90.62%;
                        position            : absolute;
                        margin              : 0;
                        left                : 0px;
                        transform           : rotate(0deg);
                        font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                        font-size           : 15.12px;
                        color               : rgba(126, 126, 126, 1.0);
                        text-align          : left;
                        letter-spacing      : 0.29px;
                        line-height         : 18.0px;
                    }
                    .bp5-ipadplayground .bp5-seemore-pwQ6 .bp5-seemorehover .bp5-a1096171 {
                        background-color    : rgba(255,255,255,0.0);
                        right               : 0px;
                        top                 : 10.00%;
                        height              : 80.00%;
                        width               : 10.00%;
                        position            : absolute;
                        margin              : 0;
                        transform           : rotate(0deg);
                    }
                    .bp5-ipadplayground .bp5-seemore-pwQ6 .bp5-seemorehover .bp5-a1096171 .bp5-path1 {
                        background-color    : rgba(255,255,255,0.0);
                        top                 : 4.17%;
                        height              : 91.67%;
                        width               : 100%;
                        position            : absolute;
                        margin              : 0;
                        left                : 0px;
                        transform           : rotate(0deg);
                    }
                </style>
                <div id="gallw3G">
                    <a href="work.html">
                        <div class="bp5-seemore bp5-seemore-pwQ6 component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                            <div class="bp5-seemore1">
                                <div anima-show-on-scroll="" class="bp5-back">
                                    I want to see more
                                </div>
                                <div class="bp5-a109617">
                                    <img alt="Image" class="bp5-path" src="./img/ipad-pro-129-sslrpdeals-path@2x.png"/>
                                </div>
                            </div>
                            <div class="bp5-seemorehover anima-hidden ">
                                <div anima-show-on-scroll="" class="bp5-back1">
                                    I want to see more
                                </div>
                                <div class="bp5-a1096171">
                                    <img alt="Image" class="bp5-path1" src="./img/ipad-designco-path-3@2x.png"/>
                                </div>
                            </div>
                        </div>
                    </a>
                </div>
                <script>
     (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp5-ipadplayground .bp5-seemore-pwQ6", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp5-seemorehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp5-seemorehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp5-seemorehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                </script>
                <div class="bp5-projectbrief">
                    <div class="bp5-projecttitle">
                        <div anima-show-on-scroll="" class="bp5-h1">
                            Playground
                        </div>
                        <div anima-show-on-scroll="" class="bp5-missioncopy">
                            Welcome to Adamâ€™s playground where creative freedom has no limit. Here you are guided by imagination, not instruction.
                        </div>
                        <div anima-show-on-scroll="" class="bp5-missioncopy2">
                            CREATIVE SPACE
                        </div>
                    </div>
                </div>
                <div class="bp5-group">
                    <a href="https://www.instagram.com/p/B-xvzyRJafV/" target="_blank">
                        <div class="bp5-spotify">
                            <div class="bp5-mask1">
                            </div>
                            <img alt="Image" anima-src="./img/ipad-playground-spotify.png" class="bp5-spotify1" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                        </div>
                    </a>
                    <a href="https://www.instagram.com/p/B-Bzi3cJtA_/" target="_blank">
                        <div class="bp5-mask">
                            <video anima-src="https://anima-uploads.s3.amazonaws.com/projects/5ea00c44c3550fe87c79bb5a/files/saucy.mp4" autoplay="autoplay" loop="" muted="" playsinline="" src="">
                            </video>
                        </div>
                    </a>
                    <a href="https://vimeo.com/400892225" target="_blank">
                        <div class="bp5-rectanglecopy">
                            <video anima-src="https://anima-uploads.s3.amazonaws.com/projects/5ea00c44c3550fe87c79bb5a/files/delorean.mp4" autoplay="autoplay" loop="" muted="" playsinline="" src="">
                            </video>
                        </div>
                    </a>
                    <a href="https://vimeo.com/400892288" target="_blank">
                        <div class="bp5-rectanglecopy2">
                            <video anima-src="https://anima-uploads.s3.amazonaws.com/projects/5ea00c44c3550fe87c79bb5a/files/synthwave.mp4" autoplay="autoplay" loop="" muted="" playsinline="" src="">
                            </video>
                        </div>
                    </a>
                    <a href="https://huecollective.co/" target="_blank">
                        <div class="bp5-rectanglecopy4">
                            <video anima-src="https://anima-uploads.s3.amazonaws.com/projects/5ea00c44c3550fe87c79bb5a/files/hue-spectrum.mp4" autoplay="autoplay" loop="" muted="" playsinline="" src="">
                            </video>
                        </div>
                    </a>
                    <a href="https://huecollective.co/" target="_blank">
                        <div class="bp5-rectanglecopy3">
                            <video anima-src="https://anima-uploads.s3.amazonaws.com/projects/5ea00c44c3550fe87c79bb5a/files/hue-collective.mp4
" autoplay="autoplay" loop="" muted="" playsinline="" src="">
                            </video>
                        </div>
                    </a>
                    <a href="https://lsstudios.itch.io/unit-108" target="_blank">
                        <div class="bp5-rectanglecopy5">
                            <img anima-src="https://anima-uploads.s3.amazonaws.com/projects/5ea00c44c3550fe87c79bb5a/files/weaponselect.gif" height="100%" src="" width="100%"/>
                        </div>
                    </a>
                    <a href="https://lsstudios.itch.io/unit-108" target="_blank">
                        <div class="bp5-rectanglecopy6">
                            <img anima-src="https://anima-uploads.s3.amazonaws.com/projects/5ea00c44c3550fe87c79bb5a/files/mainmenu.gif" height="100%" src="" width="100%"/>
                        </div>
                    </a>
                </div>
            </div>
        </div>
        <div class="bp3-web1280playground anima-word-break ">
            <div style="width: 1280px; height: 100%; position:relative; margin:auto;">
                <div class="bp3-group3">
                    <div class="bp3-rectangle">
                    </div>
                </div>
                <div class="bp3-sectionfooter">
                    <img alt="Image" anima-src="./img/web-1280-designco-bg.png" class="bp3-bg" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                    <div class="bp3-footer">
                        <div class="bp3-socialicons">
                            <style>
                                .bp3-web1280playground .bp3-sectionfooter .bp3-footer .bp3-socialicons .bp3-dribbble-8jCG * {
                                    box-sizing          : border-box;
                                }
                                .bp3-web1280playground .bp3-sectionfooter .bp3-footer .bp3-socialicons .bp3-dribbble-8jCG {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 41px;
                                    width               : 41px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 80px;
                                    transform           : rotate(0deg);
                                }
                                .bp3-web1280playground .bp3-sectionfooter .bp3-footer .bp3-socialicons .bp3-dribbble-8jCG .bp3-shape {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 97.56%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 1.22%;
                                    transform           : rotate(0deg);
                                }
                                .bp3-web1280playground .bp3-sectionfooter .bp3-footer .bp3-socialicons .bp3-dribbble-8jCG .bp3-shapehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 97.56%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 1.22%;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                }
                            </style>
                            <div id="R7DE11M">
                                <a href="https://dribbble.com/syedadam007" target="_blank">
                                    <div class="bp3-dribbble bp3-dribbble-8jCG component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <img alt="Image" class="bp3-shape" src="./img/web-1280-playground-shape@2x.png"/>
                                        <img alt="Image" class="bp3-shapehover anima-hidden " src="./img/web-1280-sslrpdeals-shapehover@2x.png"/>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp3-web1280playground .bp3-sectionfooter .bp3-footer .bp3-socialicons .bp3-dribbble-8jCG", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp3-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp3-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp3-shapehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <style>
                                .bp3-web1280playground .bp3-sectionfooter .bp3-footer .bp3-socialicons .bp3-linkedin-DjY8 * {
                                    box-sizing          : border-box;
                                }
                                .bp3-web1280playground .bp3-sectionfooter .bp3-footer .bp3-socialicons .bp3-linkedin-DjY8 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 41px;
                                    width               : 41px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .bp3-web1280playground .bp3-sectionfooter .bp3-footer .bp3-socialicons .bp3-linkedin-DjY8 .bp3-shape {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 97.56%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 1.22%;
                                    transform           : rotate(0deg);
                                }
                                .bp3-web1280playground .bp3-sectionfooter .bp3-footer .bp3-socialicons .bp3-linkedin-DjY8 .bp3-shapehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 97.56%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 1.22%;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                }
                            </style>
                            <div id="6c0RMCz">
                                <a href="https://www.linkedin.com/in/syedadamemirputra/" target="_blank">
                                    <div class="bp3-linkedin bp3-linkedin-DjY8 component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <img alt="Image" class="bp3-shape" src="./img/web-1280-swiftrides-shape-3@2x.png"/>
                                        <img alt="Image" class="bp3-shapehover anima-hidden " src="./img/web-1280-playground-shapehover-1@2x.png"/>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp3-web1280playground .bp3-sectionfooter .bp3-footer .bp3-socialicons .bp3-linkedin-DjY8", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp3-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp3-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp3-shapehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <style>
                                .bp3-web1280playground .bp3-sectionfooter .bp3-footer .bp3-socialicons .bp3-instagram-0cfg * {
                                    box-sizing          : border-box;
                                }
                                .bp3-web1280playground .bp3-sectionfooter .bp3-footer .bp3-socialicons .bp3-instagram-0cfg {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 1px;
                                    height              : 40px;
                                    width               : 41px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 160px;
                                    transform           : rotate(0deg);
                                }
                                .bp3-web1280playground .bp3-sectionfooter .bp3-footer .bp3-socialicons .bp3-instagram-0cfg .bp3-shape {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 97.56%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 1.22%;
                                    transform           : rotate(0deg);
                                }
                                .bp3-web1280playground .bp3-sectionfooter .bp3-footer .bp3-socialicons .bp3-instagram-0cfg .bp3-shapehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 97.56%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 1.22%;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                }
                            </style>
                            <div id="5qKzGq7">
                                <a href="https://www.instagram.com/syedadam007/" target="_blank">
                                    <div class="bp3-instagram bp3-instagram-0cfg component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <img alt="Image" class="bp3-shape" src="./img/web-1280-designco-shape-4@2x.png"/>
                                        <img alt="Image" class="bp3-shapehover anima-hidden " src="./img/web-1280-home-shapehover-2@2x.png"/>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp3-web1280playground .bp3-sectionfooter .bp3-footer .bp3-socialicons .bp3-instagram-0cfg", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp3-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp3-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp3-shapehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                        </div>
                        <div anima-show-on-scroll="" class="bp3-h3">
                            Â© 2020 Lil Adam X
                        </div>
                    </div>
                </div>
                <style>
                    .bp3-web1280playground .bp3-seemore-KU5R * {
                        box-sizing          : border-box;
                    }
                    .bp3-web1280playground .bp3-seemore-KU5R {
                        background-color    : rgba(255,255,255,0.0);
                        top                 : 2719px;
                        height              : 19px;
                        width               : 200px;
                        position            : absolute;
                        margin              : 0;
                        left                : 108px;
                        transform           : rotate(0deg);
                    }
                    .bp3-web1280playground .bp3-seemore-KU5R .bp3-seemore1 {
                        background-color    : rgba(255,255,255,0.0);
                        top                 : 0px;
                        height              : 100%;
                        width               : 100%;
                        position            : absolute;
                        margin              : 0;
                        left                : 0px;
                        transform           : rotate(0deg);
                    }
                    .bp3-web1280playground .bp3-seemore-KU5R .bp3-seemore1 .bp3-back {
                        background-color    : rgba(255,255,255,0.0);
                        top                 : calc(50.00% - 10px);
                        height              : 19px;
                        width               : 90.50%;
                        position            : absolute;
                        margin              : 0;
                        left                : 0px;
                        transform           : rotate(0deg);
                        font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                        font-size           : 18.9px;
                        color               : rgba(0, 0, 0, 1.0);
                        text-align          : left;
                        letter-spacing      : 0.36px;
                        line-height         : 23.0px;
                    }
                    .bp3-web1280playground .bp3-seemore-KU5R .bp3-seemore1 .bp3-a109617 {
                        background-color    : rgba(255,255,255,0.0);
                        right               : 0px;
                        top                 : 13.16%;
                        height              : 73.68%;
                        width               : 10.00%;
                        position            : absolute;
                        margin              : 0;
                        transform           : rotate(0deg);
                    }
                    .bp3-web1280playground .bp3-seemore-KU5R .bp3-seemore1 .bp3-a109617 .bp3-path {
                        background-color    : rgba(255,255,255,0.0);
                        top                 : 0px;
                        height              : 100%;
                        width               : 100%;
                        position            : absolute;
                        margin              : 0;
                        left                : 0px;
                        transform           : rotate(0deg);
                    }
                    .bp3-web1280playground .bp3-seemore-KU5R .bp3-seemorehover {
                        background-color    : rgba(255,255,255,0.0);
                        top                 : 0px;
                        height              : 100%;
                        width               : 100%;
                        position            : absolute;
                        margin              : 0;
                        left                : 0px;
                        transform           : rotate(0deg);
                        opacity             : 0.0;
                    }
                    .bp3-web1280playground .bp3-seemore-KU5R .bp3-seemorehover .bp3-back1 {
                        background-color    : rgba(255,255,255,0.0);
                        top                 : calc(50.00% - 10px);
                        height              : 19px;
                        width               : 90.50%;
                        position            : absolute;
                        margin              : 0;
                        left                : 0px;
                        transform           : rotate(0deg);
                        font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                        font-size           : 18.9px;
                        color               : rgba(126, 126, 126, 1.0);
                        text-align          : left;
                        letter-spacing      : 0.36px;
                        line-height         : 23.0px;
                    }
                    .bp3-web1280playground .bp3-seemore-KU5R .bp3-seemorehover .bp3-a1096171 {
                        background-color    : rgba(255,255,255,0.0);
                        right               : 0px;
                        top                 : 13.16%;
                        height              : 73.68%;
                        width               : 10.00%;
                        position            : absolute;
                        margin              : 0;
                        transform           : rotate(0deg);
                    }
                    .bp3-web1280playground .bp3-seemore-KU5R .bp3-seemorehover .bp3-a1096171 .bp3-path1 {
                        background-color    : rgba(255,255,255,0.0);
                        top                 : 0px;
                        height              : 100%;
                        width               : 100%;
                        position            : absolute;
                        margin              : 0;
                        left                : 0px;
                        transform           : rotate(0deg);
                    }
                </style>
                <div id="CGE9rve">
                    <a href="work.html">
                        <div class="bp3-seemore bp3-seemore-KU5R component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                            <div class="bp3-seemore1">
                                <div anima-show-on-scroll="" class="bp3-back">
                                    I want to see more
                                </div>
                                <div class="bp3-a109617">
                                    <img alt="Image" class="bp3-path" src="./img/web-1280-designco-path-2@2x.png"/>
                                </div>
                            </div>
                            <div class="bp3-seemorehover anima-hidden ">
                                <div anima-show-on-scroll="" class="bp3-back1">
                                    I want to see more
                                </div>
                                <div class="bp3-a1096171">
                                    <img alt="Image" class="bp3-path1" src="./img/web-1280-swiftrides-path-3@2x.png"/>
                                </div>
                            </div>
                        </div>
                    </a>
                </div>
                <script>
     (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp3-web1280playground .bp3-seemore-KU5R", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp3-seemorehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp3-seemorehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp3-seemorehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                </script>
                <div class="bp3-group">
                    <div class="bp3-projectbrief">
                        <div class="bp3-projecttitle">
                            <div anima-show-on-scroll="" class="bp3-h1">
                                Playground
                            </div>
                            <div anima-show-on-scroll="" class="bp3-missioncopy">
                                Welcome to Adamâ€™s playground where creative freedom has no limit. Here you are guided by imagination, not instruction.
                            </div>
                            <div anima-show-on-scroll="" class="bp3-missioncopy2">
                                CREATIVE SPACE
                            </div>
                        </div>
                    </div>
                    <a href="https://www.instagram.com/p/B-xvzyRJafV/" target="_blank">
                        <div class="bp3-spotify">
                            <div class="bp3-mask1">
                            </div>
                            <img alt="Image" anima-src="./img/web-1280-playground-spotify.png" class="bp3-spotify1" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                        </div>
                    </a>
                    <a href="https://www.instagram.com/p/B-Bzi3cJtA_/" target="_blank">
                        <div class="bp3-mask">
                            <video anima-src="https://anima-uploads.s3.amazonaws.com/projects/5ea00c44c3550fe87c79bb5a/files/saucy.mp4" autoplay="autoplay" loop="" muted="" playsinline="" src="">
                            </video>
                        </div>
                    </a>
                    <a href="https://vimeo.com/400892225" target="_blank">
                        <div class="bp3-rectanglecopy">
                            <video anima-src="https://anima-uploads.s3.amazonaws.com/projects/5ea00c44c3550fe87c79bb5a/files/delorean.mp4" autoplay="autoplay" loop="" muted="" playsinline="" src="">
                            </video>
                        </div>
                    </a>
                    <a href="https://vimeo.com/400892288" target="_blank">
                        <div class="bp3-rectanglecopy2">
                            <video anima-src="https://anima-uploads.s3.amazonaws.com/projects/5ea00c44c3550fe87c79bb5a/files/synthwave.mp4" autoplay="autoplay" loop="" muted="" playsinline="" src="">
                            </video>
                        </div>
                    </a>
                    <a href="https://huecollective.co/" target="_blank">
                        <div class="bp3-rectanglecopy4">
                            <video anima-src="https://anima-uploads.s3.amazonaws.com/projects/5ea00c44c3550fe87c79bb5a/files/hue-spectrum.mp4" autoplay="autoplay" loop="" muted="" playsinline="" src="">
                            </video>
                        </div>
                    </a>
                    <a href="https://huecollective.co/" target="_blank">
                        <div class="bp3-rectanglecopy3">
                            <video anima-src="https://anima-uploads.s3.amazonaws.com/projects/5ea00c44c3550fe87c79bb5a/files/hue-collective.mp4
" autoplay="autoplay" loop="" muted="" playsinline="" src="">
                            </video>
                        </div>
                    </a>
                    <a href="https://lsstudios.itch.io/unit-108" target="_blank">
                        <div class="bp3-rectanglecopy5">
                            <img anima-src="https://anima-uploads.s3.amazonaws.com/projects/5ea00c44c3550fe87c79bb5a/files/weaponselect.gif" height="100%" src="" width="100%"/>
                        </div>
                    </a>
                    <a href="https://lsstudios.itch.io/unit-108" target="_blank">
                        <div class="bp3-rectanglecopy6">
                            <img anima-src="https://anima-uploads.s3.amazonaws.com/projects/5ea00c44c3550fe87c79bb5a/files/mainmenu.gif" height="100%" src="" width="100%"/>
                        </div>
                    </a>
                </div>
                <div class="bp3-navbarwork">
                    <div class="bp3-rectangle">
                    </div>
                    <div class="bp3-group4">
                        <style>
                            .bp3-web1280playground .bp3-navbarwork .bp3-group4 .bp3-back-4EDh * {
                                box-sizing          : border-box;
                            }
                            .bp3-web1280playground .bp3-navbarwork .bp3-group4 .bp3-back-4EDh {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 4px;
                                height              : 19px;
                                width               : 68px;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280playground .bp3-navbarwork .bp3-group4 .bp3-back-4EDh .bp3-back1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 10px);
                                height              : 19px;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 18.9px;
                                color               : rgba(16, 16, 16, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.36px;
                                line-height         : 23.0px;
                            }
                            .bp3-web1280playground .bp3-navbarwork .bp3-group4 .bp3-back-4EDh .bp3-backhover {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 10px);
                                height              : 19px;
                                width               : 94.12%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 18.9px;
                                color               : rgba(126, 126, 126, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.36px;
                                line-height         : 23.0px;
                            }
                        </style>
                        <div id="QdqTruO">
                            <a href="javascript:history.back()">
                                <div class="bp3-back bp3-back-4EDh component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                    <div anima-show-on-scroll="" class="bp3-back1">
                                        Back
                                    </div>
                                    <div anima-show-on-scroll="" class="bp3-backhover anima-hidden ">
                                        Back
                                    </div>
                                </div>
                            </a>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp3-web1280playground .bp3-navbarwork .bp3-group4 .bp3-back-4EDh", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp3-backhover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp3-backhover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp3-backhover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                        <style>
                            .bp3-web1280playground .bp3-navbarwork .bp3-group4 .bp3-logo-wYh4 * {
                                box-sizing          : border-box;
                            }
                            .bp3-web1280playground .bp3-navbarwork .bp3-group4 .bp3-logo-wYh4 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 28px;
                                width               : 162px;
                                position            : absolute;
                                margin              : 0;
                                left                : 885px;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280playground .bp3-navbarwork .bp3-group4 .bp3-logo-wYh4 .bp3-adamoutline {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 99.38%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.31%;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280playground .bp3-navbarwork .bp3-group4 .bp3-logo-wYh4 .bp3-adamoutline .bp3-shape {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 1.79%;
                                height              : 96.43%;
                                width               : 81.99%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280playground .bp3-navbarwork .bp3-group4 .bp3-logo-wYh4 .bp3-adamoutline .bp3-path {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 0px;
                                bottom              : 14.29%;
                                height              : 64.29%;
                                width               : 11.18%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280playground .bp3-navbarwork .bp3-group4 .bp3-logo-wYh4 .bp3-adamfill {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 1.79%;
                                height              : 96.43%;
                                width               : 98.77%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.62%;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                            }
                            .bp3-web1280playground .bp3-navbarwork .bp3-group4 .bp3-logo-wYh4 .bp3-adamfill .bp3-shape1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 1.85%;
                                height              : 96.30%;
                                width               : 81.25%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp3-web1280playground .bp3-navbarwork .bp3-group4 .bp3-logo-wYh4 .bp3-adamfill .bp3-path1 {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 0px;
                                top                 : 14.81%;
                                height              : 70.37%;
                                width               : 11.25%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                        </style>
                        <div id="9KIS5OK">
                            <a href="home.html">
                                <div class="bp3-logo bp3-logo-wYh4 component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                    <div class="bp3-adamoutline">
                                        <img alt="Image" class="bp3-shape" src="./img/web-1280-designco-shape@2x.png"/>
                                        <img alt="Image" class="bp3-path" src="./img/web-1280-playground-path-2@2x.png"/>
                                    </div>
                                    <div class="bp3-adamfill anima-hidden ">
                                        <img alt="Image" class="bp3-shape1" src="./img/web-1280-playground-shape-4@2x.png"/>
                                        <img alt="Image" class="bp3-path1" src="./img/web-1280-sslrpdeals-path-3@2x.png"/>
                                    </div>
                                </div>
                            </a>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp3-web1280playground .bp3-navbarwork .bp3-group4 .bp3-logo-wYh4", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp3-adamfill": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp3-adamfill": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp3-adamfill": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                    </div>
                </div>
            </div>
        </div>
        <div class="bp2-web1366playground anima-word-break ">
            <div style="width: 1366px; height: 100%; position:relative; margin:auto;">
                <div class="bp2-navbarwork">
                    <style>
                        .bp2-web1366playground .bp2-navbarwork .bp2-back-Q83c * {
                            box-sizing          : border-box;
                        }
                        .bp2-web1366playground .bp2-navbarwork .bp2-back-Q83c {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 5px;
                            height              : 21px;
                            width               : 50px;
                            position            : absolute;
                            margin              : 0;
                            left                : 0px;
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366playground .bp2-navbarwork .bp2-back-Q83c .bp2-back1 {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : calc(50.00% - 11px);
                            height              : 21px;
                            width               : 100%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0px;
                            transform           : rotate(0deg);
                            font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                            font-size           : 21.0px;
                            color               : rgba(16, 16, 16, 1.0);
                            text-align          : left;
                            letter-spacing      : 0.4px;
                            line-height         : 25.0px;
                        }
                        .bp2-web1366playground .bp2-navbarwork .bp2-back-Q83c .bp2-backhover {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : calc(50.00% - 11px);
                            height              : 21px;
                            width               : 100%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0px;
                            transform           : rotate(0deg);
                            opacity             : 0.0;
                            font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                            font-size           : 21.0px;
                            color               : rgba(126, 126, 126, 1.0);
                            text-align          : left;
                            letter-spacing      : 0.4px;
                            line-height         : 25.0px;
                        }
                    </style>
                    <div id="rlYHYcD">
                        <a href="javascript:history.back()">
                            <div class="bp2-back bp2-back-Q83c component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                <div anima-show-on-scroll="" class="bp2-back1">
                                    Back
                                </div>
                                <div anima-show-on-scroll="" class="bp2-backhover anima-hidden ">
                                    Back
                                </div>
                            </div>
                        </a>
                    </div>
                    <script>
      (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp2-web1366playground .bp2-navbarwork .bp2-back-Q83c", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp2-backhover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp2-backhover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp2-backhover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                    </script>
                    <style>
                        .bp2-web1366playground .bp2-navbarwork .bp2-logo-KMdW * {
                            box-sizing          : border-box;
                        }
                        .bp2-web1366playground .bp2-navbarwork .bp2-logo-KMdW {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 0px;
                            height              : 31px;
                            width               : 180px;
                            position            : absolute;
                            margin              : 0;
                            left                : 984px;
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366playground .bp2-navbarwork .bp2-logo-KMdW .bp2-adamoutline {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 0px;
                            height              : 100%;
                            width               : 99.44%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0.28%;
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366playground .bp2-navbarwork .bp2-logo-KMdW .bp2-adamoutline .bp2-shape {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 1.61%;
                            height              : 96.77%;
                            width               : 82.12%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0px;
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366playground .bp2-navbarwork .bp2-logo-KMdW .bp2-adamoutline .bp2-path {
                            background-color    : rgba(255,255,255,0.0);
                            right               : 0.56%;
                            top                 : 17.74%;
                            height              : 64.52%;
                            width               : 11.17%;
                            position            : absolute;
                            margin              : 0;
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366playground .bp2-navbarwork .bp2-logo-KMdW .bp2-adamfill {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 1.61%;
                            height              : 96.77%;
                            width               : 98.89%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0.56%;
                            transform           : rotate(0deg);
                            opacity             : 0.0;
                        }
                        .bp2-web1366playground .bp2-navbarwork .bp2-logo-KMdW .bp2-adamfill .bp2-shape1 {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 1.67%;
                            height              : 96.67%;
                            width               : 81.46%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0px;
                            transform           : rotate(0deg);
                        }
                        .bp2-web1366playground .bp2-navbarwork .bp2-logo-KMdW .bp2-adamfill .bp2-path1 {
                            background-color    : rgba(255,255,255,0.0);
                            right               : 0.56%;
                            top                 : 15.00%;
                            height              : 70.00%;
                            width               : 11.24%;
                            position            : absolute;
                            margin              : 0;
                            transform           : rotate(0deg);
                        }
                    </style>
                    <div id="rbWxsmk">
                        <a href="home.html">
                            <div class="bp2-logo bp2-logo-KMdW component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                <div class="bp2-adamoutline">
                                    <img alt="Image" class="bp2-shape" src="./img/web-1366-designco-shape-3@2x.png"/>
                                    <img alt="Image" class="bp2-path" src="./img/web-1366-swiftrides-path@2x.png"/>
                                </div>
                                <div class="bp2-adamfill anima-hidden ">
                                    <img alt="Image" class="bp2-shape1" src="./img/web-1366-adobe-shape-4@2x.png"/>
                                    <img alt="Image" class="bp2-path1" src="./img/web-1366-adobe-path-1@2x.png"/>
                                </div>
                            </div>
                        </a>
                    </div>
                    <script>
      (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp2-web1366playground .bp2-navbarwork .bp2-logo-KMdW", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp2-adamfill": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp2-adamfill": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp2-adamfill": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                    </script>
                </div>
                <div class="bp2-group">
                    <div class="bp2-projectbrief">
                        <div class="bp2-projecttitle">
                            <div anima-show-on-scroll="" class="bp2-h1">
                                Playground
                            </div>
                            <div anima-show-on-scroll="" class="bp2-missioncopy">
                                Welcome to Adamâ€™s playground where creative freedom has no limit. Here you are guided by imagination, not instruction.
                            </div>
                            <div anima-show-on-scroll="" class="bp2-missioncopy2">
                                CREATIVE SPACE
                            </div>
                        </div>
                    </div>
                    <a href="https://www.instagram.com/p/B-xvzyRJafV/" target="_blank">
                        <div class="bp2-spotify">
                            <div class="bp2-mask1">
                            </div>
                            <img alt="Image" anima-src="./img/web-1366-playground-spotify.png" class="bp2-spotify1" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                        </div>
                    </a>
                    <a href="https://www.instagram.com/p/B-Bzi3cJtA_/" target="_blank">
                        <div class="bp2-mask">
                            <video anima-src="https://anima-uploads.s3.amazonaws.com/projects/5ea00c44c3550fe87c79bb5a/files/saucy.mp4" autoplay="autoplay" loop="" muted="" playsinline="" src="">
                            </video>
                        </div>
                    </a>
                    <a href="https://vimeo.com/400892225" target="_blank">
                        <div class="bp2-rectanglecopy">
                            <video anima-src="https://anima-uploads.s3.amazonaws.com/projects/5ea00c44c3550fe87c79bb5a/files/delorean.mp4" autoplay="autoplay" loop="" muted="" playsinline="" src="">
                            </video>
                        </div>
                    </a>
                    <a href="https://vimeo.com/400892288" target="_blank">
                        <div class="bp2-rectanglecopy2">
                            <video anima-src="https://anima-uploads.s3.amazonaws.com/projects/5ea00c44c3550fe87c79bb5a/files/synthwave.mp4" autoplay="autoplay" loop="" muted="" playsinline="" src="">
                            </video>
                        </div>
                    </a>
                    <a href="https://huecollective.co/" target="_blank">
                        <div class="bp2-rectanglecopy4">
                            <video anima-src="https://anima-uploads.s3.amazonaws.com/projects/5ea00c44c3550fe87c79bb5a/files/hue-spectrum.mp4" autoplay="autoplay" loop="" muted="" playsinline="" src="">
                            </video>
                        </div>
                    </a>
                    <a href="https://huecollective.co/" target="_blank">
                        <div class="bp2-rectanglecopy3">
                            <video anima-src="https://anima-uploads.s3.amazonaws.com/projects/5ea00c44c3550fe87c79bb5a/files/hue-collective.mp4
" autoplay="autoplay" loop="" muted="" playsinline="" src="">
                            </video>
                        </div>
                    </a>
                    <a href="https://lsstudios.itch.io/unit-108" target="_blank">
                        <div class="bp2-rectanglecopy5">
                            <img anima-src="https://anima-uploads.s3.amazonaws.com/projects/5ea00c44c3550fe87c79bb5a/files/weaponselect.gif" height="100%" src="" width="100%"/>
                        </div>
                    </a>
                    <a href="https://lsstudios.itch.io/unit-108" target="_blank">
                        <div class="bp2-rectanglecopy6">
                            <img anima-src="https://anima-uploads.s3.amazonaws.com/projects/5ea00c44c3550fe87c79bb5a/files/mainmenu.gif" height="100%" src="" width="100%"/>
                        </div>
                    </a>
                </div>
                <style>
                    .bp2-web1366playground .bp2-seemore-kCEM * {
                        box-sizing          : border-box;
                    }
                    .bp2-web1366playground .bp2-seemore-kCEM {
                        background-color    : rgba(255,255,255,0.0);
                        top                 : 2993px;
                        height              : 21px;
                        width               : 223px;
                        position            : absolute;
                        margin              : 0;
                        left                : 101px;
                        transform           : rotate(0deg);
                    }
                    .bp2-web1366playground .bp2-seemore-kCEM .bp2-seemore1 {
                        background-color    : rgba(255,255,255,0.0);
                        top                 : 0px;
                        height              : 100%;
                        width               : 100%;
                        position            : absolute;
                        margin              : 0;
                        left                : 0px;
                        transform           : rotate(0deg);
                    }
                    .bp2-web1366playground .bp2-seemore-kCEM .bp2-seemore1 .bp2-back {
                        background-color    : rgba(255,255,255,0.0);
                        top                 : calc(50.00% - 11px);
                        height              : 21px;
                        width               : 83.41%;
                        position            : absolute;
                        margin              : 0;
                        left                : 0px;
                        transform           : rotate(0deg);
                        font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                        font-size           : 21.0px;
                        color               : rgba(0, 0, 0, 1.0);
                        text-align          : left;
                        letter-spacing      : 0.4px;
                        line-height         : 25.0px;
                    }
                    .bp2-web1366playground .bp2-seemore-kCEM .bp2-seemore1 .bp2-a109617 {
                        background-color    : rgba(255,255,255,0.0);
                        right               : 0px;
                        top                 : 11.90%;
                        height              : 76.19%;
                        width               : 10.31%;
                        position            : absolute;
                        margin              : 0;
                        transform           : rotate(0deg);
                    }
                    .bp2-web1366playground .bp2-seemore-kCEM .bp2-seemore1 .bp2-a109617 .bp2-path {
                        background-color    : rgba(255,255,255,0.0);
                        top                 : 3.12%;
                        height              : 93.75%;
                        width               : 95.65%;
                        position            : absolute;
                        margin              : 0;
                        left                : 2.17%;
                        transform           : rotate(0deg);
                    }
                    .bp2-web1366playground .bp2-seemore-kCEM .bp2-seemorehover {
                        background-color    : rgba(255,255,255,0.0);
                        top                 : 0px;
                        height              : 100%;
                        width               : 100%;
                        position            : absolute;
                        margin              : 0;
                        left                : 0px;
                        transform           : rotate(0deg);
                        opacity             : 0.0;
                    }
                    .bp2-web1366playground .bp2-seemore-kCEM .bp2-seemorehover .bp2-back1 {
                        background-color    : rgba(255,255,255,0.0);
                        top                 : calc(50.00% - 11px);
                        height              : 21px;
                        width               : 83.41%;
                        position            : absolute;
                        margin              : 0;
                        left                : 0px;
                        transform           : rotate(0deg);
                        font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                        font-size           : 21.0px;
                        color               : rgba(126, 126, 126, 1.0);
                        text-align          : left;
                        letter-spacing      : 0.4px;
                        line-height         : 25.0px;
                    }
                    .bp2-web1366playground .bp2-seemore-kCEM .bp2-seemorehover .bp2-a1096171 {
                        background-color    : rgba(255,255,255,0.0);
                        right               : 0px;
                        top                 : 11.90%;
                        height              : 76.19%;
                        width               : 10.31%;
                        position            : absolute;
                        margin              : 0;
                        transform           : rotate(0deg);
                    }
                    .bp2-web1366playground .bp2-seemore-kCEM .bp2-seemorehover .bp2-a1096171 .bp2-path1 {
                        background-color    : rgba(255,255,255,0.0);
                        top                 : 3.12%;
                        height              : 93.75%;
                        width               : 95.65%;
                        position            : absolute;
                        margin              : 0;
                        left                : 2.17%;
                        transform           : rotate(0deg);
                    }
                </style>
                <div id="JcfgjZM">
                    <a href="work.html">
                        <div class="bp2-seemore bp2-seemore-kCEM component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                            <div class="bp2-seemore1">
                                <div anima-show-on-scroll="" class="bp2-back">
                                    I want to see more
                                </div>
                                <div class="bp2-a109617">
                                    <img alt="Image" class="bp2-path" src="./img/web-1366-designco-path@2x.png"/>
                                </div>
                            </div>
                            <div class="bp2-seemorehover anima-hidden ">
                                <div anima-show-on-scroll="" class="bp2-back1">
                                    I want to see more
                                </div>
                                <div class="bp2-a1096171">
                                    <img alt="Image" class="bp2-path1" src="./img/web-1366-adobe-path-3@2x.png"/>
                                </div>
                            </div>
                        </div>
                    </a>
                </div>
                <script>
     (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp2-web1366playground .bp2-seemore-kCEM", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp2-seemorehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp2-seemorehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp2-seemorehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                </script>
                <div class="bp2-sectionfooter">
                    <img alt="Image" anima-src="./img/web-1366-designco-bg.png" class="bp2-bg" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                    <div class="bp2-footer">
                        <div class="bp2-socialicons">
                            <style>
                                .bp2-web1366playground .bp2-sectionfooter .bp2-footer .bp2-socialicons .bp2-dribbble-OJyc * {
                                    box-sizing          : border-box;
                                }
                                .bp2-web1366playground .bp2-sectionfooter .bp2-footer .bp2-socialicons .bp2-dribbble-OJyc {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 43px;
                                    width               : 43px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 85px;
                                    transform           : rotate(0deg);
                                }
                                .bp2-web1366playground .bp2-sectionfooter .bp2-footer .bp2-socialicons .bp2-dribbble-OJyc .bp2-shape {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .bp2-web1366playground .bp2-sectionfooter .bp2-footer .bp2-socialicons .bp2-dribbble-OJyc .bp2-shapehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                }
                            </style>
                            <div id="b7YuKYK">
                                <a href="https://dribbble.com/syedadam007" target="_blank">
                                    <div class="bp2-dribbble bp2-dribbble-OJyc component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <img alt="Image" class="bp2-shape" src="./img/web-1366-playground-shape-2@2x.png"/>
                                        <img alt="Image" class="bp2-shapehover anima-hidden " src="./img/web-1366-about-shapehover@2x.png"/>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp2-web1366playground .bp2-sectionfooter .bp2-footer .bp2-socialicons .bp2-dribbble-OJyc", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp2-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp2-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp2-shapehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <style>
                                .bp2-web1366playground .bp2-sectionfooter .bp2-footer .bp2-socialicons .bp2-linkedin-dpK4 * {
                                    box-sizing          : border-box;
                                }
                                .bp2-web1366playground .bp2-sectionfooter .bp2-footer .bp2-socialicons .bp2-linkedin-dpK4 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 43px;
                                    width               : 43px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .bp2-web1366playground .bp2-sectionfooter .bp2-footer .bp2-socialicons .bp2-linkedin-dpK4 .bp2-shape {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .bp2-web1366playground .bp2-sectionfooter .bp2-footer .bp2-socialicons .bp2-linkedin-dpK4 .bp2-shapehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                }
                            </style>
                            <div id="I7FtXQ9">
                                <a href="https://www.linkedin.com/in/syedadamemirputra/" target="_blank">
                                    <div class="bp2-linkedin bp2-linkedin-dpK4 component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <img alt="Image" class="bp2-shape" src="./img/web-1366-designco-shape-1@2x.png"/>
                                        <img alt="Image" class="bp2-shapehover anima-hidden " src="./img/web-1366-adobe-shapehover-1@2x.png"/>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp2-web1366playground .bp2-sectionfooter .bp2-footer .bp2-socialicons .bp2-linkedin-dpK4", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp2-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp2-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp2-shapehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <style>
                                .bp2-web1366playground .bp2-sectionfooter .bp2-footer .bp2-socialicons .bp2-instagram-7nO1 * {
                                    box-sizing          : border-box;
                                }
                                .bp2-web1366playground .bp2-sectionfooter .bp2-footer .bp2-socialicons .bp2-instagram-7nO1 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 1px;
                                    height              : 43px;
                                    width               : 43px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 171px;
                                    transform           : rotate(0deg);
                                }
                                .bp2-web1366playground .bp2-sectionfooter .bp2-footer .bp2-socialicons .bp2-instagram-7nO1 .bp2-shape {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 1.16%;
                                    height              : 97.67%;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .bp2-web1366playground .bp2-sectionfooter .bp2-footer .bp2-socialicons .bp2-instagram-7nO1 .bp2-shapehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 1.16%;
                                    height              : 97.67%;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                }
                            </style>
                            <div id="3itX3wP">
                                <a href="https://www.instagram.com/syedadam007/" target="_blank">
                                    <div class="bp2-instagram bp2-instagram-7nO1 component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <img alt="Image" class="bp2-shape" src="./img/web-1366-sslrpdeals-shape-2@2x.png"/>
                                        <img alt="Image" class="bp2-shapehover anima-hidden " src="./img/web-1366-swiftrides-shapehover-2@2x.png"/>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp2-web1366playground .bp2-sectionfooter .bp2-footer .bp2-socialicons .bp2-instagram-7nO1", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp2-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp2-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp2-shapehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                        </div>
                        <div anima-show-on-scroll="" class="bp2-h3">
                            Â© 2020 Lil Adam X
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="bp4-ipadpro129playground anima-word-break ">
            <div style="width: 1024px; height: 100%; position:relative; margin:auto;">
                <div class="bp4-group3">
                    <div class="bp4-navbarwork">
                        <div class="bp4-rectangle">
                        </div>
                        <div class="bp4-group4">
                            <style>
                                .bp4-ipadpro129playground .bp4-group3 .bp4-navbarwork .bp4-group4 .bp4-back-sMxI * {
                                    box-sizing          : border-box;
                                }
                                .bp4-ipadpro129playground .bp4-group3 .bp4-navbarwork .bp4-group4 .bp4-back-sMxI {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 3px;
                                    height              : 15px;
                                    width               : 55px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .bp4-ipadpro129playground .bp4-group3 .bp4-navbarwork .bp4-group4 .bp4-back-sMxI .bp4-back1 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 8px);
                                    height              : 15px;
                                    width               : 98.18%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0.91%;
                                    transform           : rotate(0deg);
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 15.12px;
                                    color               : rgba(16, 16, 16, 1.0);
                                    text-align          : left;
                                    letter-spacing      : 0.29px;
                                    line-height         : 18.0px;
                                }
                                .bp4-ipadpro129playground .bp4-group3 .bp4-navbarwork .bp4-group4 .bp4-back-sMxI .bp4-backhover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 8px);
                                    height              : 15px;
                                    width               : 92.73%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 15.12px;
                                    color               : rgba(126, 126, 126, 1.0);
                                    text-align          : left;
                                    letter-spacing      : 0.29px;
                                    line-height         : 18.0px;
                                }
                            </style>
                            <div id="zuKBKU1">
                                <a href="javascript:history.back()">
                                    <div class="bp4-back bp4-back-sMxI component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <div anima-show-on-scroll="" class="bp4-back1">
                                            Back
                                        </div>
                                        <div anima-show-on-scroll="" class="bp4-backhover anima-hidden ">
                                            Back
                                        </div>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp4-ipadpro129playground .bp4-group3 .bp4-navbarwork .bp4-group4 .bp4-back-sMxI", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp4-backhover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp4-backhover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp4-backhover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <style>
                                .bp4-ipadpro129playground .bp4-group3 .bp4-navbarwork .bp4-group4 .bp4-logo-off0 * {
                                    box-sizing          : border-box;
                                }
                                .bp4-ipadpro129playground .bp4-group3 .bp4-navbarwork .bp4-group4 .bp4-logo-off0 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 22px;
                                    width               : 130px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 708px;
                                    transform           : rotate(0deg);
                                }
                                .bp4-ipadpro129playground .bp4-group3 .bp4-navbarwork .bp4-group4 .bp4-logo-off0 .bp4-adamoutline {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 99.23%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0.38%;
                                    transform           : rotate(0deg);
                                }
                                .bp4-ipadpro129playground .bp4-group3 .bp4-navbarwork .bp4-group4 .bp4-logo-off0 .bp4-adamoutline .bp4-shape {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 82.17%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .bp4-ipadpro129playground .bp4-group3 .bp4-navbarwork .bp4-group4 .bp4-logo-off0 .bp4-adamoutline .bp4-path {
                                    background-color    : rgba(255,255,255,0.0);
                                    right               : 0.78%;
                                    top                 : 15.91%;
                                    height              : 68.18%;
                                    width               : 10.85%;
                                    position            : absolute;
                                    margin              : 0;
                                    transform           : rotate(0deg);
                                }
                                .bp4-ipadpro129playground .bp4-group3 .bp4-navbarwork .bp4-group4 .bp4-logo-off0 .bp4-adamfill {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 2.27%;
                                    height              : 95.45%;
                                    width               : 98.46%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0.77%;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                }
                                .bp4-ipadpro129playground .bp4-group3 .bp4-navbarwork .bp4-group4 .bp4-logo-off0 .bp4-adamfill .bp4-shape1 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 81.25%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .bp4-ipadpro129playground .bp4-group3 .bp4-navbarwork .bp4-group4 .bp4-logo-off0 .bp4-adamfill .bp4-path1 {
                                    background-color    : rgba(255,255,255,0.0);
                                    right               : 0px;
                                    bottom              : 9.52%;
                                    height              : 71.43%;
                                    width               : 11.72%;
                                    position            : absolute;
                                    margin              : 0;
                                    transform           : rotate(0deg);
                                }
                            </style>
                            <div id="L8VQWy0">
                                <a href="home.html">
                                    <div class="bp4-logo bp4-logo-off0 component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <div class="bp4-adamoutline">
                                            <img alt="Image" class="bp4-shape" src="./img/ipad-pro-129-playground-shape@2x.png"/>
                                            <img alt="Image" class="bp4-path" src="./img/ipad-pro-129-sslrpdeals-path-2@2x.png"/>
                                        </div>
                                        <div class="bp4-adamfill anima-hidden ">
                                            <img alt="Image" class="bp4-shape1" src="./img/ipad-pro-129-playground-shape-1@2x.png"/>
                                            <img alt="Image" class="bp4-path1" src="./img/ipad-pro-129-designco-path-1@2x.png"/>
                                        </div>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp4-ipadpro129playground .bp4-group3 .bp4-navbarwork .bp4-group4 .bp4-logo-off0", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp4-adamfill": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp4-adamfill": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp4-adamfill": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                        </div>
                    </div>
                </div>
                <div class="bp4-sectionfooter">
                    <img alt="Image" anima-src="./img/ipad-pro-129-adobe-bg.png" class="bp4-bg" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                    <div class="bp4-footer">
                        <div class="bp4-socialicons">
                            <style>
                                .bp4-ipadpro129playground .bp4-sectionfooter .bp4-footer .bp4-socialicons .bp4-dribbble-qFWc * {
                                    box-sizing          : border-box;
                                }
                                .bp4-ipadpro129playground .bp4-sectionfooter .bp4-footer .bp4-socialicons .bp4-dribbble-qFWc {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 33px;
                                    width               : 33px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 64px;
                                    transform           : rotate(0deg);
                                }
                                .bp4-ipadpro129playground .bp4-sectionfooter .bp4-footer .bp4-socialicons .bp4-dribbble-qFWc .bp4-shape {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 1.52%;
                                    height              : 96.97%;
                                    width               : 96.97%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 1.52%;
                                    transform           : rotate(0deg);
                                }
                                .bp4-ipadpro129playground .bp4-sectionfooter .bp4-footer .bp4-socialicons .bp4-dribbble-qFWc .bp4-shapehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 1.52%;
                                    height              : 96.97%;
                                    width               : 96.97%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 1.52%;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                }
                            </style>
                            <div id="8grRTA1">
                                <a href="https://dribbble.com/syedadam007" target="_blank">
                                    <div class="bp4-dribbble bp4-dribbble-qFWc component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <img alt="Image" class="bp4-shape" src="./img/ipad-pro-129-playground-shape-2@2x.png"/>
                                        <img alt="Image" class="bp4-shapehover anima-hidden " src="./img/ipad-pro-129-playground-shapehover@2x.png"/>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp4-ipadpro129playground .bp4-sectionfooter .bp4-footer .bp4-socialicons .bp4-dribbble-qFWc", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp4-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp4-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp4-shapehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <style>
                                .bp4-ipadpro129playground .bp4-sectionfooter .bp4-footer .bp4-socialicons .bp4-linkedin-eg87 * {
                                    box-sizing          : border-box;
                                }
                                .bp4-ipadpro129playground .bp4-sectionfooter .bp4-footer .bp4-socialicons .bp4-linkedin-eg87 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 33px;
                                    width               : 33px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .bp4-ipadpro129playground .bp4-sectionfooter .bp4-footer .bp4-socialicons .bp4-linkedin-eg87 .bp4-shape {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 1.52%;
                                    height              : 96.97%;
                                    width               : 96.97%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 1.52%;
                                    transform           : rotate(0deg);
                                }
                                .bp4-ipadpro129playground .bp4-sectionfooter .bp4-footer .bp4-socialicons .bp4-linkedin-eg87 .bp4-shapehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 1.52%;
                                    height              : 96.97%;
                                    width               : 96.97%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 1.52%;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                }
                            </style>
                            <div id="SIOODCR">
                                <a href="https://www.linkedin.com/in/syedadamemirputra/" target="_blank">
                                    <div class="bp4-linkedin bp4-linkedin-eg87 component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <img alt="Image" class="bp4-shape" src="./img/ipad-pro-129-home-shape-5@2x.png"/>
                                        <img alt="Image" class="bp4-shapehover anima-hidden " src="./img/ipad-pro-129-swiftrides-shapehover-1@2x.png"/>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp4-ipadpro129playground .bp4-sectionfooter .bp4-footer .bp4-socialicons .bp4-linkedin-eg87", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp4-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp4-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp4-shapehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <style>
                                .bp4-ipadpro129playground .bp4-sectionfooter .bp4-footer .bp4-socialicons .bp4-instagram-XtkR * {
                                    box-sizing          : border-box;
                                }
                                .bp4-ipadpro129playground .bp4-sectionfooter .bp4-footer .bp4-socialicons .bp4-instagram-XtkR {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 1px;
                                    height              : 32px;
                                    width               : 33px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 128px;
                                    transform           : rotate(0deg);
                                }
                                .bp4-ipadpro129playground .bp4-sectionfooter .bp4-footer .bp4-socialicons .bp4-instagram-XtkR .bp4-shape {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 96.97%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 1.52%;
                                    transform           : rotate(0deg);
                                }
                                .bp4-ipadpro129playground .bp4-sectionfooter .bp4-footer .bp4-socialicons .bp4-instagram-XtkR .bp4-shapehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 96.97%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 1.52%;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                }
                            </style>
                            <div id="h3Xig0E">
                                <a href="https://www.instagram.com/syedadam007/" target="_blank">
                                    <div class="bp4-instagram bp4-instagram-XtkR component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <img alt="Image" class="bp4-shape" src="./img/ipad-pro-129-designco-shape-4@2x.png"/>
                                        <img alt="Image" class="bp4-shapehover anima-hidden " src="./img/ipad-pro-129-sslrpdeals-shapehover-2@2x.png"/>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp4-ipadpro129playground .bp4-sectionfooter .bp4-footer .bp4-socialicons .bp4-instagram-XtkR", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp4-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp4-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp4-shapehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                        </div>
                        <div anima-show-on-scroll="" class="bp4-h3">
                            Â© 2020 Lil Adam X
                        </div>
                    </div>
                </div>
                <style>
                    .bp4-ipadpro129playground .bp4-seemore-CQ5p * {
                        box-sizing          : border-box;
                    }
                    .bp4-ipadpro129playground .bp4-seemore-CQ5p {
                        background-color    : rgba(255,255,255,0.0);
                        top                 : 2175px;
                        height              : 15px;
                        width               : 160px;
                        position            : absolute;
                        margin              : 0;
                        left                : 86px;
                        transform           : rotate(0deg);
                    }
                    .bp4-ipadpro129playground .bp4-seemore-CQ5p .bp4-seemore1 {
                        background-color    : rgba(255,255,255,0.0);
                        top                 : 0px;
                        height              : 100%;
                        width               : 100%;
                        position            : absolute;
                        margin              : 0;
                        left                : 0px;
                        transform           : rotate(0deg);
                    }
                    .bp4-ipadpro129playground .bp4-seemore-CQ5p .bp4-seemore1 .bp4-back {
                        background-color    : rgba(255,255,255,0.0);
                        top                 : calc(50.00% - 8px);
                        height              : 15px;
                        width               : 90.62%;
                        position            : absolute;
                        margin              : 0;
                        left                : 0px;
                        transform           : rotate(0deg);
                        font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                        font-size           : 15.12px;
                        color               : rgba(0, 0, 0, 1.0);
                        text-align          : left;
                        letter-spacing      : 0.29px;
                        line-height         : 18.0px;
                    }
                    .bp4-ipadpro129playground .bp4-seemore-CQ5p .bp4-seemore1 .bp4-a109617 {
                        background-color    : rgba(255,255,255,0.0);
                        right               : 0px;
                        top                 : 10.00%;
                        height              : 80.00%;
                        width               : 10.00%;
                        position            : absolute;
                        margin              : 0;
                        transform           : rotate(0deg);
                    }
                    .bp4-ipadpro129playground .bp4-seemore-CQ5p .bp4-seemore1 .bp4-a109617 .bp4-path {
                        background-color    : rgba(255,255,255,0.0);
                        top                 : 4.17%;
                        height              : 91.67%;
                        width               : 100%;
                        position            : absolute;
                        margin              : 0;
                        left                : 0px;
                        transform           : rotate(0deg);
                    }
                    .bp4-ipadpro129playground .bp4-seemore-CQ5p .bp4-seemorehover {
                        background-color    : rgba(255,255,255,0.0);
                        top                 : 0px;
                        height              : 100%;
                        width               : 100%;
                        position            : absolute;
                        margin              : 0;
                        left                : 0px;
                        transform           : rotate(0deg);
                        opacity             : 0.0;
                    }
                    .bp4-ipadpro129playground .bp4-seemore-CQ5p .bp4-seemorehover .bp4-back1 {
                        background-color    : rgba(255,255,255,0.0);
                        top                 : calc(50.00% - 8px);
                        height              : 15px;
                        width               : 90.62%;
                        position            : absolute;
                        margin              : 0;
                        left                : 0px;
                        transform           : rotate(0deg);
                        font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                        font-size           : 15.12px;
                        color               : rgba(126, 126, 126, 1.0);
                        text-align          : left;
                        letter-spacing      : 0.29px;
                        line-height         : 18.0px;
                    }
                    .bp4-ipadpro129playground .bp4-seemore-CQ5p .bp4-seemorehover .bp4-a1096171 {
                        background-color    : rgba(255,255,255,0.0);
                        right               : 0px;
                        top                 : 10.00%;
                        height              : 80.00%;
                        width               : 10.00%;
                        position            : absolute;
                        margin              : 0;
                        transform           : rotate(0deg);
                    }
                    .bp4-ipadpro129playground .bp4-seemore-CQ5p .bp4-seemorehover .bp4-a1096171 .bp4-path1 {
                        background-color    : rgba(255,255,255,0.0);
                        top                 : 4.17%;
                        height              : 91.67%;
                        width               : 100%;
                        position            : absolute;
                        margin              : 0;
                        left                : 0px;
                        transform           : rotate(0deg);
                    }
                </style>
                <div id="CYJwmRB">
                    <a href="work.html">
                        <div class="bp4-seemore bp4-seemore-CQ5p component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                            <div class="bp4-seemore1">
                                <div anima-show-on-scroll="" class="bp4-back">
                                    I want to see more
                                </div>
                                <div class="bp4-a109617">
                                    <img alt="Image" class="bp4-path" src="./img/ipad-pro-129-sslrpdeals-path@2x.png"/>
                                </div>
                            </div>
                            <div class="bp4-seemorehover anima-hidden ">
                                <div anima-show-on-scroll="" class="bp4-back1">
                                    I want to see more
                                </div>
                                <div class="bp4-a1096171">
                                    <img alt="Image" class="bp4-path1" src="./img/ipad-designco-path-3@2x.png"/>
                                </div>
                            </div>
                        </div>
                    </a>
                </div>
                <script>
     (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp4-ipadpro129playground .bp4-seemore-CQ5p", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp4-seemorehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp4-seemorehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp4-seemorehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                </script>
                <div class="bp4-group">
                    <div class="bp4-projectbrief">
                        <div class="bp4-projecttitle">
                            <div anima-show-on-scroll="" class="bp4-h1">
                                Playground
                            </div>
                            <div anima-show-on-scroll="" class="bp4-missioncopy">
                                Welcome to Adamâ€™s playground where creative freedom has no limit. Here you are guided by imagination, not instruction.
                            </div>
                            <div anima-show-on-scroll="" class="bp4-missioncopy2">
                                CREATIVE SPACE
                            </div>
                        </div>
                    </div>
                    <a href="https://www.instagram.com/p/B-xvzyRJafV/" target="_blank">
                        <div class="bp4-spotify">
                            <div class="bp4-mask1">
                            </div>
                            <img alt="Image" anima-src="./img/ipad-pro-129-playground-spotify.png" class="bp4-spotify1" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                        </div>
                    </a>
                    <a href="https://www.instagram.com/p/B-Bzi3cJtA_/" target="_blank">
                        <div class="bp4-mask">
                            <video anima-src="https://anima-uploads.s3.amazonaws.com/projects/5ea00c44c3550fe87c79bb5a/files/saucy.mp4" autoplay="autoplay" loop="" muted="" playsinline="" src="">
                            </video>
                        </div>
                    </a>
                    <a href="https://vimeo.com/400892225" target="_blank">
                        <div class="bp4-rectanglecopy">
                            <video anima-src="https://anima-uploads.s3.amazonaws.com/projects/5ea00c44c3550fe87c79bb5a/files/delorean.mp4" autoplay="autoplay" loop="" muted="" playsinline="" src="">
                            </video>
                        </div>
                    </a>
                    <a href="https://vimeo.com/400892288" target="_blank">
                        <div class="bp4-rectanglecopy2">
                            <video anima-src="https://anima-uploads.s3.amazonaws.com/projects/5ea00c44c3550fe87c79bb5a/files/synthwave.mp4" autoplay="autoplay" loop="" muted="" playsinline="" src="">
                            </video>
                        </div>
                    </a>
                    <a href="https://huecollective.co/" target="_blank">
                        <div class="bp4-rectanglecopy4">
                            <video anima-src="https://anima-uploads.s3.amazonaws.com/projects/5ea00c44c3550fe87c79bb5a/files/hue-spectrum.mp4" autoplay="autoplay" loop="" muted="" playsinline="" src="">
                            </video>
                        </div>
                    </a>
                    <a href="https://huecollective.co/" target="_blank">
                        <div class="bp4-rectanglecopy3">
                            <video anima-src="https://anima-uploads.s3.amazonaws.com/projects/5ea00c44c3550fe87c79bb5a/files/hue-collective.mp4
" autoplay="autoplay" loop="" muted="" playsinline="" src="">
                            </video>
                        </div>
                    </a>
                    <a href="https://lsstudios.itch.io/unit-108" target="_blank">
                        <div class="bp4-rectanglecopy5">
                            <img anima-src="https://anima-uploads.s3.amazonaws.com/projects/5ea00c44c3550fe87c79bb5a/files/weaponselect.gif" height="100%" src="" width="100%"/>
                        </div>
                    </a>
                    <a href="https://lsstudios.itch.io/unit-108" target="_blank">
                        <div class="bp4-rectanglecopy6">
                            <img anima-src="https://anima-uploads.s3.amazonaws.com/projects/5ea00c44c3550fe87c79bb5a/files/mainmenu.gif" height="100%" src="" width="100%"/>
                        </div>
                    </a>
                </div>
            </div>
        </div>
        <div class="bp6-iphonexplayground anima-word-break ">
            <div style="width: 375px; height: 100%; position:relative; margin:auto;">
                <div class="bp6-sectionhero" id="None">
                    <div class="bp6-navbar">
                        <div class="bp6-rectangle">
                        </div>
                        <style>
                            .bp6-iphonexplayground .bp6-sectionhero .bp6-navbar .bp6-logo-8CiO * {
                                box-sizing          : border-box;
                            }
                            .bp6-iphonexplayground .bp6-sectionhero .bp6-navbar .bp6-logo-8CiO {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 33px;
                                height              : 19px;
                                width               : 109px;
                                position            : absolute;
                                margin              : 0;
                                left                : 38px;
                                transform           : rotate(0deg);
                            }
                            .bp6-iphonexplayground .bp6-sectionhero .bp6-navbar .bp6-logo-8CiO .bp6-adamoutline {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp6-iphonexplayground .bp6-sectionhero .bp6-navbar .bp6-logo-8CiO .bp6-adamoutline .bp6-shape1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 2.63%;
                                height              : 94.74%;
                                width               : 82.57%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.92%;
                                transform           : rotate(0deg);
                            }
                            .bp6-iphonexplayground .bp6-sectionhero .bp6-navbar .bp6-logo-8CiO .bp6-adamoutline .bp6-path {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 0px;
                                top                 : 18.42%;
                                height              : 63.16%;
                                width               : 11.01%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                            .bp6-iphonexplayground .bp6-sectionhero .bp6-navbar .bp6-logo-8CiO .bp6-adamfill {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 0px;
                                top                 : 2.63%;
                                height              : 94.74%;
                                width               : 98.17%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                            }
                            .bp6-iphonexplayground .bp6-sectionhero .bp6-navbar .bp6-logo-8CiO .bp6-adamfill .bp6-shape1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 82.24%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .bp6-iphonexplayground .bp6-sectionhero .bp6-navbar .bp6-logo-8CiO .bp6-adamfill .bp6-path1 {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 0px;
                                top                 : 13.89%;
                                height              : 72.22%;
                                width               : 11.21%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                            }
                        </style>
                        <div id="PcD6lkr">
                            <a href="home.html">
                                <div class="bp6-logo bp6-logo-8CiO component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                    <div class="bp6-adamoutline">
                                        <img alt="Image" class="bp6-shape1" src="./img/iphone-x-sslrpdeals-shape@2x.png"/>
                                        <img alt="Image" class="bp6-path" src="./img/iphone-x-swiftrides-path@2x.png"/>
                                    </div>
                                    <div class="bp6-adamfill anima-hidden ">
                                        <img alt="Image" class="bp6-shape1" src="./img/iphone-x-sslrpdeals-shape-1@2x.png"/>
                                        <img alt="Image" class="bp6-path1 anima-hidden " src="./img/iphone-x-menu-light-hover-path-3@2x.png"/>
                                    </div>
                                </div>
                            </a>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp6-iphonexplayground .bp6-sectionhero .bp6-navbar .bp6-logo-8CiO", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp6-adamfill": {
                "delay": 0, 
                "duration": 400, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp6-adamfill": {
                "delay": 0, 
                "duration": 500, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp6-adamfill": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                        <a href="javascript:animaShowOverlay('iphonexmenulighthover', 'anima-animate-appear'); anima_loadAsyncSrc(); ">
                            <img alt="Image" anima-src="./img/iphone-x-swiftrides-shape-2@2x.png" class="bp6-shape" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                        </a>
                    </div>
                </div>
                <div class="bp6-sectionfooter">
                    <img alt="Image" anima-src="./img/iphone-x-home-bg.png" class="bp6-bg" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                    <div class="bp6-footer">
                        <div class="bp6-socialicons">
                            <style>
                                .bp6-iphonexplayground .bp6-sectionfooter .bp6-footer .bp6-socialicons .bp6-dribbble-rUz6 * {
                                    box-sizing          : border-box;
                                }
                                .bp6-iphonexplayground .bp6-sectionfooter .bp6-footer .bp6-socialicons .bp6-dribbble-rUz6 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 19px;
                                    width               : 20px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 39px;
                                    transform           : rotate(0deg);
                                }
                                .bp6-iphonexplayground .bp6-sectionfooter .bp6-footer .bp6-socialicons .bp6-dribbble-rUz6 .bp6-shape {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 95.00%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 2.50%;
                                    transform           : rotate(0deg);
                                }
                                .bp6-iphonexplayground .bp6-sectionfooter .bp6-footer .bp6-socialicons .bp6-dribbble-rUz6 .bp6-shapehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 95.00%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 2.50%;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                }
                            </style>
                            <div id="4al2lcc">
                                <a href="https://dribbble.com/syedadam007" target="_blank">
                                    <div class="bp6-dribbble bp6-dribbble-rUz6 component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <img alt="Image" class="bp6-shape" src="./img/iphone-x-adobe-shape-3@2x.png"/>
                                        <img alt="Image" class="bp6-shapehover anima-hidden " src="./img/iphone-x-about-shapehover@2x.png"/>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp6-iphonexplayground .bp6-sectionfooter .bp6-footer .bp6-socialicons .bp6-dribbble-rUz6", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp6-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp6-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp6-shapehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <style>
                                .bp6-iphonexplayground .bp6-sectionfooter .bp6-footer .bp6-socialicons .bp6-linkedin-sqmE * {
                                    box-sizing          : border-box;
                                }
                                .bp6-iphonexplayground .bp6-sectionfooter .bp6-footer .bp6-socialicons .bp6-linkedin-sqmE {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 19px;
                                    width               : 20px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .bp6-iphonexplayground .bp6-sectionfooter .bp6-footer .bp6-socialicons .bp6-linkedin-sqmE .bp6-shape {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 95.00%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 2.50%;
                                    transform           : rotate(0deg);
                                }
                                .bp6-iphonexplayground .bp6-sectionfooter .bp6-footer .bp6-socialicons .bp6-linkedin-sqmE .bp6-shapehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 95.00%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 2.50%;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                }
                            </style>
                            <div id="9lUnuXG">
                                <a href="https://www.linkedin.com/in/syedadamemirputra/" target="_blank">
                                    <div class="bp6-linkedin bp6-linkedin-sqmE component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <img alt="Image" class="bp6-shape" src="./img/iphone-x-swiftrides-shape-4@2x.png"/>
                                        <img alt="Image" class="bp6-shapehover anima-hidden " src="./img/iphone-x-about-shapehover-1@2x.png"/>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp6-iphonexplayground .bp6-sectionfooter .bp6-footer .bp6-socialicons .bp6-linkedin-sqmE", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp6-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp6-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp6-shapehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <style>
                                .bp6-iphonexplayground .bp6-sectionfooter .bp6-footer .bp6-socialicons .bp6-instagram-2dqF * {
                                    box-sizing          : border-box;
                                }
                                .bp6-iphonexplayground .bp6-sectionfooter .bp6-footer .bp6-socialicons .bp6-instagram-2dqF {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 19px;
                                    width               : 20px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 77px;
                                    transform           : rotate(0deg);
                                }
                                .bp6-iphonexplayground .bp6-sectionfooter .bp6-footer .bp6-socialicons .bp6-instagram-2dqF .bp6-shape {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 95.00%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 2.50%;
                                    transform           : rotate(0deg);
                                }
                                .bp6-iphonexplayground .bp6-sectionfooter .bp6-footer .bp6-socialicons .bp6-instagram-2dqF .bp6-shapehover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 95.00%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 2.50%;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                }
                            </style>
                            <div id="nLwcg8W">
                                <a href="https://www.instagram.com/syedadam007/" target="_blank">
                                    <div class="bp6-instagram bp6-instagram-2dqF component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <img alt="Image" class="bp6-shape" src="./img/iphone-x-designco-shape-5@2x.png"/>
                                        <img alt="Image" class="bp6-shapehover anima-hidden " src="./img/iphone-x-designco-shapehover-2@2x.png"/>
                                    </div>
                                </a>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp6-iphonexplayground .bp6-sectionfooter .bp6-footer .bp6-socialicons .bp6-instagram-2dqF", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp6-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp6-shapehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp6-shapehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                        </div>
                        <div anima-show-on-scroll="" class="bp6-h3">
                            Â© 2020 Lil Adam X
                        </div>
                    </div>
                </div>
                <style>
                    .bp6-iphonexplayground .bp6-seemore-4qfz * {
                        box-sizing          : border-box;
                    }
                    .bp6-iphonexplayground .bp6-seemore-4qfz {
                        background-color    : rgba(255,255,255,0.0);
                        top                 : 3056px;
                        height              : 12px;
                        width               : 128px;
                        position            : absolute;
                        margin              : 0;
                        left                : 30px;
                        transform           : rotate(0deg);
                    }
                    .bp6-iphonexplayground .bp6-seemore-4qfz .bp6-seemore1 {
                        background-color    : rgba(255,255,255,0.0);
                        top                 : 0px;
                        height              : 100%;
                        width               : 100%;
                        position            : absolute;
                        margin              : 0;
                        left                : 0px;
                        transform           : rotate(0deg);
                    }
                    .bp6-iphonexplayground .bp6-seemore-4qfz .bp6-seemore1 .bp6-back {
                        background-color    : rgba(255,255,255,0.0);
                        top                 : calc(50.00% - 6px);
                        height              : 12px;
                        width               : 90.62%;
                        position            : absolute;
                        margin              : 0;
                        left                : 0px;
                        transform           : rotate(0deg);
                        font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                        font-size           : 12.1px;
                        color               : rgba(0, 0, 0, 1.0);
                        text-align          : left;
                        letter-spacing      : 0.23px;
                        line-height         : 15.0px;
                    }
                    .bp6-iphonexplayground .bp6-seemore-4qfz .bp6-seemore1 .bp6-a109617 {
                        background-color    : rgba(255,255,255,0.0);
                        right               : 0px;
                        top                 : 12.50%;
                        height              : 75.00%;
                        width               : 10.16%;
                        position            : absolute;
                        margin              : 0;
                        transform           : rotate(0deg);
                    }
                    .bp6-iphonexplayground .bp6-seemore-4qfz .bp6-seemore1 .bp6-a109617 .bp6-path {
                        background-color    : rgba(255,255,255,0.0);
                        top                 : 0px;
                        height              : 100%;
                        width               : 100%;
                        position            : absolute;
                        margin              : 0;
                        left                : 0px;
                        transform           : rotate(0deg);
                    }
                    .bp6-iphonexplayground .bp6-seemore-4qfz .bp6-seemorehover {
                        background-color    : rgba(255,255,255,0.0);
                        top                 : 0px;
                        height              : 100%;
                        width               : 100%;
                        position            : absolute;
                        margin              : 0;
                        left                : 0px;
                        transform           : rotate(0deg);
                        opacity             : 0.0;
                    }
                    .bp6-iphonexplayground .bp6-seemore-4qfz .bp6-seemorehover .bp6-back1 {
                        background-color    : rgba(255,255,255,0.0);
                        top                 : calc(50.00% - 6px);
                        height              : 12px;
                        width               : 90.62%;
                        position            : absolute;
                        margin              : 0;
                        left                : 0px;
                        transform           : rotate(0deg);
                        font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                        font-size           : 12.1px;
                        color               : rgba(126, 126, 126, 1.0);
                        text-align          : left;
                        letter-spacing      : 0.23px;
                        line-height         : 15.0px;
                    }
                    .bp6-iphonexplayground .bp6-seemore-4qfz .bp6-seemorehover .bp6-a1096171 {
                        background-color    : rgba(255,255,255,0.0);
                        right               : 0px;
                        top                 : 12.50%;
                        height              : 75.00%;
                        width               : 10.16%;
                        position            : absolute;
                        margin              : 0;
                        transform           : rotate(0deg);
                    }
                    .bp6-iphonexplayground .bp6-seemore-4qfz .bp6-seemorehover .bp6-a1096171 .bp6-path1 {
                        background-color    : rgba(255,255,255,0.0);
                        top                 : 0px;
                        height              : 100%;
                        width               : 100%;
                        position            : absolute;
                        margin              : 0;
                        left                : 0px;
                        transform           : rotate(0deg);
                    }
                </style>
                <div id="SV2ge6p">
                    <a href="work.html">
                        <div class="bp6-seemore bp6-seemore-4qfz component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                            <div class="bp6-seemore1">
                                <div anima-show-on-scroll="" class="bp6-back">
                                    I want to see more
                                </div>
                                <div class="bp6-a109617">
                                    <img alt="Image" class="bp6-path" src="./img/iphone-x-sslrpdeals-path-2@2x.png"/>
                                </div>
                            </div>
                            <div class="bp6-seemorehover anima-hidden ">
                                <div anima-show-on-scroll="" class="bp6-back1">
                                    I want to see more
                                </div>
                                <div class="bp6-a1096171">
                                    <img alt="Image" class="bp6-path1" src="./img/iphone-x-designco-path-3@2x.png"/>
                                </div>
                            </div>
                        </div>
                    </a>
                </div>
                <script>
     (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".bp6-iphonexplayground .bp6-seemore-4qfz", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".bp6-seemorehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".bp6-seemorehover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".bp6-seemorehover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                </script>
                <a href="https://www.instagram.com/p/B-xvzyRJafV/" target="_blank">
                    <div class="bp6-spotify">
                        <div class="bp6-mask1">
                        </div>
                        <img alt="Image" anima-src="./img/iphone-x-playground-spotify.png" class="bp6-spotify1" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                    </div>
                </a>
                <a href="https://vimeo.com/400892225" target="_blank">
                    <div class="bp6-rectanglecopy">
                        <video anima-src="https://anima-uploads.s3.amazonaws.com/projects/5ea00c44c3550fe87c79bb5a/files/delorean.mp4" autoplay="autoplay" loop="" muted="" playsinline="" src="">
                        </video>
                    </div>
                </a>
                <a href="https://vimeo.com/400892288" target="_blank">
                    <div class="bp6-rectanglecopy2">
                        <video anima-src="https://anima-uploads.s3.amazonaws.com/projects/5ea00c44c3550fe87c79bb5a/files/synthwave.mp4" autoplay="autoplay" loop="" muted="" playsinline="" src="">
                        </video>
                    </div>
                </a>
                <a href="https://www.instagram.com/p/B-Bzi3cJtA_/" target="_blank">
                    <div class="bp6-mask">
                        <video anima-src="https://anima-uploads.s3.amazonaws.com/projects/5ea00c44c3550fe87c79bb5a/files/saucy.mp4" autoplay="autoplay" loop="" muted="" playsinline="" src="">
                        </video>
                    </div>
                </a>
                <a href="https://huecollective.co/" target="_blank">
                    <div class="bp6-rectanglecopy4">
                        <video anima-src="https://anima-uploads.s3.amazonaws.com/projects/5ea00c44c3550fe87c79bb5a/files/hue-spectrum.mp4" autoplay="autoplay" loop="" muted="" playsinline="" src="">
                        </video>
                    </div>
                </a>
                <a href="https://huecollective.co/" target="_blank">
                    <div class="bp6-rectanglecopy3">
                        <video anima-src="https://anima-uploads.s3.amazonaws.com/projects/5ea00c44c3550fe87c79bb5a/files/hue-collective.mp4
" autoplay="autoplay" loop="" muted="" playsinline="" src="">
                        </video>
                    </div>
                </a>
                <a href="https://lsstudios.itch.io/unit-108" target="_blank">
                    <div class="bp6-rectanglecopy5">
                        <img anima-src="https://anima-uploads.s3.amazonaws.com/projects/5ea00c44c3550fe87c79bb5a/files/weaponselect.gif" height="100%" src="" width="100%"/>
                    </div>
                </a>
                <a href="https://lsstudios.itch.io/unit-108" target="_blank">
                    <div class="bp6-rectanglecopy6">
                        <img anima-src="https://anima-uploads.s3.amazonaws.com/projects/5ea00c44c3550fe87c79bb5a/files/mainmenu.gif" height="100%" src="" width="100%"/>
                    </div>
                </a>
                <div class="bp6-projectbrief">
                    <div class="bp6-projecttitle">
                        <div anima-show-on-scroll="" class="bp6-h1">
                            Playground
                        </div>
                        <div anima-show-on-scroll="" class="bp6-missioncopy">
                            Welcome to Adamâ€™s playground where creative freedom has no limit. Here you are guided by imagination, not instruction.
                        </div>
                        <div anima-show-on-scroll="" class="bp6-missioncopy2">
                            CREATIVE SPACE
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="anima-overlay" id="overlay-iphonexmenulighthover" style="min-height:4580px; position:fixed;">
            <div class="iphonexmenulighthover anima-word-break ">
                <div style="width: 375px; height: 100%; position:relative; margin:auto;">
                    <div class="sectionhero" id="None">
                        <div class="darkbg">
                        </div>
                        <div class="content">
                            <div anima-show-on-scroll="" class="mission">
                                Adam designs because the world ainâ€™t right. Demystifying the ways the world should be.
                            </div>
                            <div class="present">
                                Present
                            </div>
                            <style>
                                .iphonexmenulighthover .sectionhero .content .designco-Tvig * {
                                    box-sizing          : border-box;
                                }
                                .iphonexmenulighthover .sectionhero .content .designco-Tvig {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 211px;
                                    height              : 14px;
                                    width               : 67px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 1px;
                                    transform           : rotate(0deg);
                                }
                                .iphonexmenulighthover .sectionhero .content .designco-Tvig .designco1 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 7px);
                                    height              : 13px;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 12.9px;
                                    color               : rgba(255, 255, 255, 1.0);
                                    text-align          : left;
                                    letter-spacing      : 0.25px;
                                    line-height         : 16.0px;
                                }
                                .iphonexmenulighthover .sectionhero .content .designco-Tvig .designcohover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 7px);
                                    height              : 13px;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 12.9px;
                                    color               : rgba(146, 146, 146, 1.0);
                                    text-align          : left;
                                    letter-spacing      : 0.25px;
                                    line-height         : 16.0px;
                                }
                            </style>
                            <div id="AWHXWmw">
                                <div class="designco designco-Tvig component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                    <a href="http://www.ucsddesign.co/" target="_blank">
                                        <div class="designco1">
                                            Design Co
                                        </div>
                                    </a>
                                    <a href="http://www.ucsddesign.co/" target="_blank">
                                        <div class="designcohover anima-hidden ">
                                            Design Co
                                        </div>
                                    </a>
                                </div>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".iphonexmenulighthover .sectionhero .content .designco-Tvig", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".designcohover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".designcohover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".designcohover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <div class="education">
                                Education
                            </div>
                            <style>
                                .iphonexmenulighthover .sectionhero .content .ucsd-yAD9 * {
                                    box-sizing          : border-box;
                                }
                                .iphonexmenulighthover .sectionhero .content .ucsd-yAD9 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 285px;
                                    height              : 14px;
                                    width               : 92px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 1px;
                                    transform           : rotate(0deg);
                                }
                                .iphonexmenulighthover .sectionhero .content .ucsd-yAD9 .ucsd1 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 7px);
                                    height              : 13px;
                                    width               : 98.91%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0.54%;
                                    transform           : rotate(0deg);
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 12.9px;
                                    color               : rgba(255, 255, 255, 1.0);
                                    text-align          : left;
                                    letter-spacing      : 0.25px;
                                    line-height         : 16.0px;
                                }
                                .iphonexmenulighthover .sectionhero .content .ucsd-yAD9 .ucsdhover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 7px);
                                    height              : 13px;
                                    width               : 98.91%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0.54%;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 12.9px;
                                    color               : rgba(146, 146, 146, 1.0);
                                    text-align          : left;
                                    letter-spacing      : 0.25px;
                                    line-height         : 16.0px;
                                }
                            </style>
                            <div id="ckuPUZj">
                                <div class="ucsd ucsd-yAD9 component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                    <a href="https://ucsd.edu/" target="_blank">
                                        <div class="ucsd1">
                                            UC San Diego
                                        </div>
                                    </a>
                                    <a href="https://ucsd.edu/" target="_blank">
                                        <div class="ucsdhover anima-hidden ">
                                            UC San Diego
                                        </div>
                                    </a>
                                </div>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".iphonexmenulighthover .sectionhero .content .ucsd-yAD9", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".ucsdhover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".ucsdhover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".ucsdhover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <div class="previous">
                                Previous
                            </div>
                            <style>
                                .iphonexmenulighthover .sectionhero .content .longstorystudios-4c5W * {
                                    box-sizing          : border-box;
                                }
                                .iphonexmenulighthover .sectionhero .content .longstorystudios-4c5W {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 206px;
                                    height              : 35px;
                                    width               : 108px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 178px;
                                    transform           : rotate(0deg);
                                }
                                .iphonexmenulighthover .sectionhero .content .longstorystudios-4c5W .ls {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 17px);
                                    height              : 34px;
                                    width               : 65.74%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 12.9px;
                                    color               : rgba(255, 255, 255, 1.0);
                                    text-align          : left;
                                    letter-spacing      : 0.25px;
                                    line-height         : 17.0px;
                                }
                                .iphonexmenulighthover .sectionhero .content .longstorystudios-4c5W .lshover {
                                    background-color    : rgba(255,255,255,0.0);
                                    right               : 0.93%;
                                    top                 : calc(50.00% - 13px);
                                    height              : 26px;
                                    width               : 65.74%;
                                    position            : absolute;
                                    margin              : 0;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 12.9px;
                                    color               : rgba(146, 146, 146, 1.0);
                                    text-align          : left;
                                    letter-spacing      : 0.25px;
                                    line-height         : 16.0px;
                                }
                            </style>
                            <div id="0eJ5H1Y">
                                <div class="longstorystudios longstorystudios-4c5W component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                    <a href="https://www.longstorystudios.com/" target="_blank">
                                        <div class="ls">
                                            Long Story Studios
                                        </div>
                                    </a>
                                    <a href="https://www.longstorystudios.com/" target="_blank">
                                        <div class="lshover anima-hidden ">
                                            Long Story Studios
                                        </div>
                                    </a>
                                </div>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".iphonexmenulighthover .sectionhero .content .longstorystudios-4c5W", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".lshover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".lshover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".lshover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                        </div>
                        <div class="navbar">
                            <div class="rectangle">
                            </div>
                            <style>
                                .iphonexmenulighthover .sectionhero .navbar .logo-tT1f * {
                                    box-sizing          : border-box;
                                }
                                .iphonexmenulighthover .sectionhero .navbar .logo-tT1f {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 33px;
                                    height              : 19px;
                                    width               : 110px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 38px;
                                    transform           : rotate(0deg);
                                }
                                .iphonexmenulighthover .sectionhero .navbar .logo-tT1f .adamoutline {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 99.09%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0.45%;
                                    transform           : rotate(0deg);
                                }
                                .iphonexmenulighthover .sectionhero .navbar .logo-tT1f .adamoutline .shape1 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 2.63%;
                                    height              : 94.74%;
                                    width               : 82.57%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0.92%;
                                    transform           : rotate(0deg);
                                }
                                .iphonexmenulighthover .sectionhero .navbar .logo-tT1f .adamoutline .path {
                                    background-color    : rgba(255,255,255,0.0);
                                    right               : 0px;
                                    top                 : 18.42%;
                                    height              : 63.16%;
                                    width               : 11.01%;
                                    position            : absolute;
                                    margin              : 0;
                                    transform           : rotate(0deg);
                                }
                                .iphonexmenulighthover .sectionhero .navbar .logo-tT1f .adamfill {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 2.63%;
                                    height              : 94.74%;
                                    width               : 98.18%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0.91%;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                }
                                .iphonexmenulighthover .sectionhero .navbar .logo-tT1f .adamfill .shape1 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 81.48%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .iphonexmenulighthover .sectionhero .navbar .logo-tT1f .adamfill .path1 {
                                    background-color    : rgba(255,255,255,0.0);
                                    right               : 0px;
                                    top                 : 13.89%;
                                    height              : 72.22%;
                                    width               : 11.11%;
                                    position            : absolute;
                                    margin              : 0;
                                    transform           : rotate(0deg);
                                }
                            </style>
                            <div id="s1kHDMi">
                                <div class="logo logo-tT1f component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                    <div class="adamoutline">
                                        <img alt="Image" class="shape1" src="./img/iphone-x-work-shape@2x.png"/>
                                        <img alt="Image" class="path" src="./img/iphone-x-home-path@2x.png"/>
                                    </div>
                                    <div class="adamfill anima-hidden ">
                                        <img alt="Image" class="shape1" src="./img/iphone-x-home-menu-hover-shape-4@2x.png"/>
                                        <img alt="Image" class="path1" src="./img/iphone-x-menu-light-hover-path-1@2x.png"/>
                                    </div>
                                </div>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".iphonexmenulighthover .sectionhero .navbar .logo-tT1f", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".adamfill": {
                "delay": 0, 
                "duration": 400, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".adamfill": {
                "delay": 0, 
                "duration": 500, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".adamfill": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <a href="javascript:animaShowOverlay('ipadhomemenuhover', 'anima-animate-appear'); anima_loadAsyncSrc(); ">
                                <img alt="Image" anima-src="./img/iphone-x-home-menu-hover-shape-2@2x.png" class="shape" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                            </a>
                        </div>
                    </div>
                    <div class="group3">
                        <div class="rectangle">
                        </div>
                        <style>
                            .iphonexmenulighthover .group3 .work-5nCT * {
                                box-sizing          : border-box;
                            }
                            .iphonexmenulighthover .group3 .work-5nCT {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 205px;
                                height              : 41px;
                                width               : 134px;
                                position            : absolute;
                                margin              : 0;
                                left                : 37px;
                                transform           : rotate(0deg);
                            }
                            .iphonexmenulighthover .group3 .work-5nCT .work1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 20px);
                                height              : 40px;
                                width               : 99.25%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.37%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 20.9px;
                                color               : rgba(16, 16, 16, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.58px;
                                line-height         : 25.0px;
                            }
                        </style>
                        <div id="wgMeRes">
                            <a href="work.html">
                                <div anima-show-on-scroll="" class="work anima-animate-enter7 work-5nCT component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                    <div class="work1 anima-valign-text-middle">
                                        Work
                                    </div>
                                </div>
                            </a>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".iphonexmenulighthover .group3 .work-5nCT", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {}, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {}, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ".work1"
          }
        ], 
        "overrides": {}
      }
    }
  }
];
})();
                        </script>
                        <style>
                            .iphonexmenulighthover .group3 .workcopy-9dou * {
                                box-sizing          : border-box;
                            }
                            .iphonexmenulighthover .group3 .workcopy-9dou {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 150px;
                                height              : 41px;
                                width               : 134px;
                                position            : absolute;
                                margin              : 0;
                                left                : 37px;
                                transform           : rotate(0deg);
                            }
                            .iphonexmenulighthover .group3 .workcopy-9dou .work1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 20px);
                                height              : 40px;
                                width               : 99.25%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.37%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 20.9px;
                                color               : rgba(16, 16, 16, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.58px;
                                line-height         : 25.0px;
                            }
                        </style>
                        <div id="hGehqHe">
                            <a href="home.html">
                                <div anima-show-on-scroll="" class="workcopy anima-animate-enter8 workcopy-9dou component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                    <div class="work1 anima-valign-text-middle">
                                        Home
                                    </div>
                                </div>
                            </a>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".iphonexmenulighthover .group3 .workcopy-9dou", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {}, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {}, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ".work1"
          }
        ], 
        "overrides": {}
      }
    }
  }
];
})();
                        </script>
                        <style>
                            .iphonexmenulighthover .group3 .workcopy2-PHfL * {
                                box-sizing          : border-box;
                            }
                            .iphonexmenulighthover .group3 .workcopy2-PHfL {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 260px;
                                height              : 41px;
                                width               : 134px;
                                position            : absolute;
                                margin              : 0;
                                left                : 37px;
                                transform           : rotate(0deg);
                            }
                            .iphonexmenulighthover .group3 .workcopy2-PHfL .work1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 20px);
                                height              : 40px;
                                width               : 99.25%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.37%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 20.9px;
                                color               : rgba(16, 16, 16, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.58px;
                                line-height         : 25.0px;
                            }
                        </style>
                        <div id="GARvk8c">
                            <a href="about.html">
                                <div anima-show-on-scroll="" class="workcopy2 anima-animate-enter9 workcopy2-PHfL component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                    <div class="work1 anima-valign-text-middle">
                                        About
                                    </div>
                                </div>
                            </a>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".iphonexmenulighthover .group3 .workcopy2-PHfL", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {}, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {}, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ".work1"
          }
        ], 
        "overrides": {}
      }
    }
  }
];
})();
                        </script>
                        <style>
                            .iphonexmenulighthover .group3 .workcopy3-1qQH * {
                                box-sizing          : border-box;
                            }
                            .iphonexmenulighthover .group3 .workcopy3-1qQH {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 315px;
                                height              : 41px;
                                width               : 134px;
                                position            : absolute;
                                margin              : 0;
                                left                : 37px;
                                transform           : rotate(0deg);
                            }
                            .iphonexmenulighthover .group3 .workcopy3-1qQH .work1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 20px);
                                height              : 40px;
                                width               : 99.25%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.37%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 20.9px;
                                color               : rgba(16, 16, 16, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.58px;
                                line-height         : 25.0px;
                            }
                        </style>
                        <div id="OCCeaqB">
                            <a href="https://drive.google.com/file/d/1KxPEStKpGkBtJaURrrckkRjVntkcITWU/view?usp=sharing" target="_blank">
                                <div class="workcopy3 workcopy3-1qQH component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                    <div class="work1 anima-valign-text-middle">
                                        Resume
                                    </div>
                                </div>
                            </a>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".iphonexmenulighthover .group3 .workcopy3-1qQH", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {}, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {}, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ".work1"
          }
        ], 
        "overrides": {}
      }
    }
  }
];
})();
                        </script>
                        <style>
                            .iphonexmenulighthover .group3 .logo-N0BE * {
                                box-sizing          : border-box;
                            }
                            .iphonexmenulighthover .group3 .logo-N0BE {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 33px;
                                height              : 19px;
                                width               : 110px;
                                position            : absolute;
                                margin              : 0;
                                left                : 38px;
                                transform           : rotate(0deg);
                            }
                            .iphonexmenulighthover .group3 .logo-N0BE .adamoutline {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 99.09%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.45%;
                                transform           : rotate(0deg);
                            }
                            .iphonexmenulighthover .group3 .logo-N0BE .adamoutline .shape {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 2.63%;
                                height              : 94.74%;
                                width               : 82.57%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.92%;
                                transform           : rotate(0deg);
                            }
                            .iphonexmenulighthover .group3 .logo-N0BE .adamoutline .path {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 0px;
                                top                 : 18.42%;
                                height              : 63.16%;
                                width               : 11.01%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                            .iphonexmenulighthover .group3 .logo-N0BE .adamfill {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 2.63%;
                                height              : 94.74%;
                                width               : 97.27%;
                                position            : absolute;
                                margin              : 0;
                                left                : 1.36%;
                                transform           : rotate(0deg);
                                opacity             : 0.0;
                            }
                            .iphonexmenulighthover .group3 .logo-N0BE .adamfill .shape1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 100%;
                                width               : 82.24%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .iphonexmenulighthover .group3 .logo-N0BE .adamfill .path1 {
                                background-color    : rgba(255,255,255,0.0);
                                right               : 0px;
                                top                 : 13.89%;
                                height              : 72.22%;
                                width               : 11.21%;
                                position            : absolute;
                                margin              : 0;
                                transform           : rotate(0deg);
                            }
                        </style>
                        <div id="uguNRhr">
                            <a href="home.html">
                                <div class="logo logo-N0BE component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                    <div class="adamoutline">
                                        <img alt="Image" class="shape" src="./img/iphone-x-sslrpdeals-shape@2x.png"/>
                                        <img alt="Image" class="path" src="./img/iphone-x-swiftrides-path@2x.png"/>
                                    </div>
                                    <div class="adamfill anima-hidden ">
                                        <img alt="Image" class="shape1" src="./img/iphone-x-sslrpdeals-shape-1@2x.png"/>
                                        <img alt="Image" class="path1" src="./img/iphone-x-menu-light-hover-path-3@2x.png"/>
                                    </div>
                                </div>
                            </a>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".iphonexmenulighthover .group3 .logo-N0BE", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".adamfill": {
                "delay": 0, 
                "duration": 400, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".adamfill": {
                "delay": 0, 
                "duration": 500, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".adamfill": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                        </script>
                    </div>
                    <a href="javascript:animaHideOverlay('iphonexmenulighthover', 'anima-animate-disappear');">
                        <div class="group2">
                            <img alt="Image" anima-src="./img/iphone-x-menu-light-hover-path-5@2x.png" class="path" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                            <img alt="Image" anima-src="./img/iphone-x-menu-light-hover-path-5@2x.png" class="path1" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                        </div>
                    </a>
                    <div anima-show-on-scroll="" class="h3">
                        Â© 2020 Lil Adam X
                    </div>
                </div>
            </div>
        </div>
        <script>
   var overlay_id = "overlay-iphonexmenulighthover";
  document.getElementById(overlay_id).addEventListener("click", function( event ) {
    var e = event || window.event;
    var clickedDiv = e.toElement || e.target;
    if (clickedDiv.parentElement.id == overlay_id) {
        animaHideOverlay('iphonexmenulighthover', 'anima-animate-disappear');
    }
  }, false);
        </script>
        <div class="anima-overlay" id="overlay-ipadlightmenuhover" style="min-height:4580px; position:fixed;">
            <div class="ipadlightmenuhover anima-word-break ">
                <div style="width: 768px; height: 100%; position:relative; margin:auto;">
                    <div class="sectionhero" id="None">
                        <div class="darkbg">
                        </div>
                        <div class="content">
                            <div anima-show-on-scroll="" class="mission">
                                Adam designs because the world ainâ€™t right. <br />Demystifying the ways the world should be.
                            </div>
                            <div class="present">
                                Present
                            </div>
                            <style>
                                .ipadlightmenuhover .sectionhero .content .designco-tS0y * {
                                    box-sizing          : border-box;
                                }
                                .ipadlightmenuhover .sectionhero .content .designco-tS0y {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 175px;
                                    height              : 17px;
                                    width               : 84px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .ipadlightmenuhover .sectionhero .content .designco-tS0y .designco1 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 8px);
                                    height              : 16px;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 16.13px;
                                    color               : rgba(255, 255, 255, 1.0);
                                    text-align          : left;
                                    letter-spacing      : 0.31px;
                                    line-height         : 19.0px;
                                }
                                .ipadlightmenuhover .sectionhero .content .designco-tS0y .designcohover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 8px);
                                    height              : 16px;
                                    width               : 100%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 16.13px;
                                    color               : rgba(146, 146, 146, 1.0);
                                    text-align          : left;
                                    letter-spacing      : 0.31px;
                                    line-height         : 19.0px;
                                }
                            </style>
                            <div id="GV2gxCl">
                                <div class="designco designco-tS0y component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                    <a href="http://www.ucsddesign.co/" target="_blank">
                                        <div class="designco1">
                                            Design Co
                                        </div>
                                    </a>
                                    <a href="http://www.ucsddesign.co/" target="_blank">
                                        <div class="designcohover anima-hidden ">
                                            Design Co
                                        </div>
                                    </a>
                                </div>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".ipadlightmenuhover .sectionhero .content .designco-tS0y", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".designcohover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".designcohover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".designcohover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <div class="education">
                                Education
                            </div>
                            <style>
                                .ipadlightmenuhover .sectionhero .content .ucsd-rqwn * {
                                    box-sizing          : border-box;
                                }
                                .ipadlightmenuhover .sectionhero .content .ucsd-rqwn {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 261px;
                                    height              : 17px;
                                    width               : 115px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .ipadlightmenuhover .sectionhero .content .ucsd-rqwn .ucsd1 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 8px);
                                    height              : 16px;
                                    width               : 99.13%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0.43%;
                                    transform           : rotate(0deg);
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 16.13px;
                                    color               : rgba(255, 255, 255, 1.0);
                                    text-align          : left;
                                    letter-spacing      : 0.31px;
                                    line-height         : 19.0px;
                                }
                                .ipadlightmenuhover .sectionhero .content .ucsd-rqwn .ucsdhover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 8px);
                                    height              : 16px;
                                    width               : 99.13%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0.43%;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 16.13px;
                                    color               : rgba(146, 146, 146, 1.0);
                                    text-align          : left;
                                    letter-spacing      : 0.31px;
                                    line-height         : 19.0px;
                                }
                            </style>
                            <div id="IlDKsa1">
                                <div class="ucsd ucsd-rqwn component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                    <a href="https://ucsd.edu/" target="_blank">
                                        <div class="ucsd1">
                                            UC San Diego
                                        </div>
                                    </a>
                                    <a href="https://ucsd.edu/" target="_blank">
                                        <div class="ucsdhover anima-hidden ">
                                            UC San Diego
                                        </div>
                                    </a>
                                </div>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".ipadlightmenuhover .sectionhero .content .ucsd-rqwn", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".ucsdhover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".ucsdhover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".ucsdhover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                            <div class="previous">
                                Previous
                            </div>
                            <style>
                                .ipadlightmenuhover .sectionhero .content .longstorystudios-mOEh * {
                                    box-sizing          : border-box;
                                }
                                .ipadlightmenuhover .sectionhero .content .longstorystudios-mOEh {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 175px;
                                    height              : 17px;
                                    width               : 153px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 297px;
                                    transform           : rotate(0deg);
                                }
                                .ipadlightmenuhover .sectionhero .content .longstorystudios-mOEh .ls {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 8px);
                                    height              : 16px;
                                    width               : 99.35%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0.33%;
                                    transform           : rotate(0deg);
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 16.13px;
                                    color               : rgba(255, 255, 255, 1.0);
                                    text-align          : left;
                                    letter-spacing      : 0.31px;
                                    line-height         : 19.0px;
                                }
                                .ipadlightmenuhover .sectionhero .content .longstorystudios-mOEh .lshover {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : calc(50.00% - 8px);
                                    height              : 16px;
                                    width               : 99.35%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0.33%;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                    font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                    font-size           : 16.13px;
                                    color               : rgba(146, 146, 146, 1.0);
                                    text-align          : left;
                                    letter-spacing      : 0.31px;
                                    line-height         : 19.0px;
                                }
                            </style>
                            <div id="hdocgS5">
                                <div class="longstorystudios longstorystudios-mOEh component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                    <a href="https://www.longstorystudios.com/" target="_blank">
                                        <div class="ls">
                                            Long Story Studios
                                        </div>
                                    </a>
                                    <a href="https://www.longstorystudios.com/" target="_blank">
                                        <div class="lshover anima-hidden ">
                                            Long Story Studios
                                        </div>
                                    </a>
                                </div>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".ipadlightmenuhover .sectionhero .content .longstorystudios-mOEh", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".lshover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".lshover": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".lshover": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                        </div>
                        <div class="lightsaber">
                            <div class="lightsaberoff">
                                <div class="lightsaberoff1">
                                    <div class="rectangle">
                                    </div>
                                    <div class="rectangle1">
                                    </div>
                                    <div class="rectangle2">
                                    </div>
                                    <div class="rectangle3">
                                    </div>
                                    <div class="rectangle4">
                                    </div>
                                    <img alt="Image" anima-src="./img/ipad-about-shape-1@2x.png" class="shape" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                                    <div class="rectangle5">
                                    </div>
                                    <div class="rectangle6">
                                    </div>
                                    <div class="rectangle7">
                                    </div>
                                    <div class="rectangle8">
                                    </div>
                                    <div class="rectangle9">
                                    </div>
                                    <img alt="Image" anima-src="./img/ipad-light-menu-hover-path-4@2x.png" class="path" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                                    <img alt="Image" anima-src="./img/ipad-home-path-5@2x.png" class="path1" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                                    <div class="rectangle10">
                                    </div>
                                    <div class="rectangle11">
                                    </div>
                                    <div class="rectangle12">
                                    </div>
                                    <div class="rectangle13">
                                    </div>
                                </div>
                                <a href="playground.html">
                                    <div class="playground">
                                        <div class="rectangle">
                                        </div>
                                        <div class="playground1">
                                            Playground
                                        </div>
                                    </div>
                                </a>
                            </div>
                            <div class="lightsaberon">
                                <div class="lightsaberon1">
                                    <div class="group">
                                        <img alt="Image" anima-src="./img/ipad-pro-129-home-path-2@2x.png" class="path2" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                                        <img alt="Image" anima-src="./img/ipad-about-path-3@2x.png" class="path11" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                                    </div>
                                    <div class="rectangle">
                                    </div>
                                    <div class="rectangle1">
                                    </div>
                                    <div class="rectangle2">
                                    </div>
                                    <div class="rectangle3">
                                    </div>
                                    <div class="rectangle4">
                                    </div>
                                    <img alt="Image" anima-src="./img/ipad-about-shape-1@2x.png" class="shape" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                                    <div class="rectangle5">
                                    </div>
                                    <div class="rectangle6">
                                    </div>
                                    <div class="rectangle7">
                                    </div>
                                    <div class="rectangle8">
                                    </div>
                                    <div class="rectangle9">
                                    </div>
                                    <img alt="Image" anima-src="./img/ipad-light-menu-hover-path-4@2x.png" class="path" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                                    <img alt="Image" anima-src="./img/ipad-home-path-5@2x.png" class="path1" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                                    <div class="rectangle10">
                                    </div>
                                    <div class="rectangle11">
                                    </div>
                                    <div class="rectangle12">
                                    </div>
                                    <div class="rectangle13">
                                    </div>
                                </div>
                                <a href="playground.html">
                                    <div class="playground">
                                        <div class="rectangle">
                                        </div>
                                        <div class="playground1">
                                            Playground
                                        </div>
                                    </div>
                                </a>
                            </div>
                        </div>
                        <div class="navbar">
                            <div class="rectangle">
                            </div>
                            <style>
                                .ipadlightmenuhover .sectionhero .navbar .logo1-JEgx * {
                                    box-sizing          : border-box;
                                }
                                .ipadlightmenuhover .sectionhero .navbar .logo1-JEgx {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 41px;
                                    height              : 24px;
                                    width               : 137px;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 69px;
                                    transform           : rotate(0deg);
                                }
                                .ipadlightmenuhover .sectionhero .navbar .logo1-JEgx .adamoutline {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 0px;
                                    height              : 100%;
                                    width               : 99.27%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0.36%;
                                    transform           : rotate(0deg);
                                }
                                .ipadlightmenuhover .sectionhero .navbar .logo1-JEgx .adamoutline .shape {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 2.08%;
                                    height              : 95.83%;
                                    width               : 82.35%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .ipadlightmenuhover .sectionhero .navbar .logo1-JEgx .adamoutline .path {
                                    background-color    : rgba(255,255,255,0.0);
                                    right               : 0px;
                                    top                 : 18.75%;
                                    height              : 62.50%;
                                    width               : 11.03%;
                                    position            : absolute;
                                    margin              : 0;
                                    transform           : rotate(0deg);
                                }
                                .ipadlightmenuhover .sectionhero .navbar .logo1-JEgx .adamfill {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 2.08%;
                                    height              : 95.83%;
                                    width               : 98.54%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0.73%;
                                    transform           : rotate(0deg);
                                    opacity             : 0.0;
                                }
                                .ipadlightmenuhover .sectionhero .navbar .logo1-JEgx .adamfill .shape1 {
                                    background-color    : rgba(255,255,255,0.0);
                                    top                 : 2.17%;
                                    height              : 95.65%;
                                    width               : 81.48%;
                                    position            : absolute;
                                    margin              : 0;
                                    left                : 0px;
                                    transform           : rotate(0deg);
                                }
                                .ipadlightmenuhover .sectionhero .navbar .logo1-JEgx .adamfill .path1 {
                                    background-color    : rgba(255,255,255,0.0);
                                    right               : 0px;
                                    top                 : 15.22%;
                                    height              : 69.57%;
                                    width               : 11.11%;
                                    position            : absolute;
                                    margin              : 0;
                                    transform           : rotate(0deg);
                                }
                            </style>
                            <div id="GOEqDg5">
                                <div class="logo1 logo1-JEgx component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                    <div class="adamoutline">
                                        <img alt="Image" class="shape" src="./img/ipad-home-menu-hover-shape-4@2x.png"/>
                                        <img alt="Image" class="path" src="./img/ipad-home-menu-hover-path-6@2x.png"/>
                                    </div>
                                    <div class="adamfill anima-hidden ">
                                        <img alt="Image" class="shape1" src="./img/ipad-home-shape-3@2x.png"/>
                                        <img alt="Image" class="path1" src="./img/ipad-home-path-7@2x.png"/>
                                    </div>
                                </div>
                            </div>
                            <script>
        (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".ipadlightmenuhover .sectionhero .navbar .logo1-JEgx", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".adamfill": {
                "delay": 0, 
                "duration": 400, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".adamfill": {
                "delay": 0, 
                "duration": 500, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".adamfill": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                            </script>
                        </div>
                    </div>
                    <div class="group3">
                        <div class="rectangle">
                        </div>
                        <style>
                            .ipadlightmenuhover .group3 .workcopy-T1fF * {
                                box-sizing          : border-box;
                            }
                            .ipadlightmenuhover .group3 .workcopy-T1fF {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 149px;
                                height              : 332px;
                                width               : 134px;
                                position            : absolute;
                                margin              : 0;
                                left                : 51px;
                                transform           : rotate(0deg);
                            }
                            .ipadlightmenuhover .group3 .workcopy-T1fF .work-YGPL {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 29.22%;
                                height              : 12.35%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .ipadlightmenuhover .group3 .workcopy-T1fF .work-YGPL .work1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 20px);
                                height              : 40px;
                                width               : 99.25%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.37%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 28.0px;
                                color               : rgba(16, 16, 16, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.78px;
                                line-height         : 34.0px;
                            }
                            .ipadlightmenuhover .group3 .workcopy-T1fF .workcopy1-Xz53 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : 0px;
                                height              : 12.35%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .ipadlightmenuhover .group3 .workcopy-T1fF .workcopy1-Xz53 .work1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 20px);
                                height              : 40px;
                                width               : 99.25%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.37%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 28.0px;
                                color               : rgba(16, 16, 16, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.78px;
                                line-height         : 34.0px;
                            }
                            .ipadlightmenuhover .group3 .workcopy-T1fF .workcopy2-3B3m {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 29.22%;
                                height              : 12.35%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .ipadlightmenuhover .group3 .workcopy-T1fF .workcopy2-3B3m .work1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 20px);
                                height              : 40px;
                                width               : 99.25%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.37%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 28.0px;
                                color               : rgba(16, 16, 16, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.78px;
                                line-height         : 34.0px;
                            }
                            .ipadlightmenuhover .group3 .workcopy-T1fF .workcopy3-Hkpp {
                                background-color    : rgba(255,255,255,0.0);
                                bottom              : 0px;
                                height              : 12.35%;
                                width               : 100%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0px;
                                transform           : rotate(0deg);
                            }
                            .ipadlightmenuhover .group3 .workcopy-T1fF .workcopy3-Hkpp .work1 {
                                background-color    : rgba(255,255,255,0.0);
                                top                 : calc(50.00% - 20px);
                                height              : 40px;
                                width               : 99.25%;
                                position            : absolute;
                                margin              : 0;
                                left                : 0.37%;
                                transform           : rotate(0deg);
                                font-family         : "Gilroy-Medium", Helvetica, Arial, serif;
                                font-size           : 28.0px;
                                color               : rgba(16, 16, 16, 1.0);
                                text-align          : left;
                                letter-spacing      : 0.78px;
                                line-height         : 34.0px;
                            }
                        </style>
                        <div id="wfa7M9C">
                            <div anima-show-on-scroll="" class="workcopy anima-animate-enter6 workcopy-T1fF component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                <a href="work.html">
                                    <div anima-show-on-scroll="" class="work anima-animate-enter3 work-YGPL component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <div class="work1 anima-valign-text-middle">
                                            Work
                                        </div>
                                    </div>
                                </a>
                                <a href="home.html">
                                    <div anima-show-on-scroll="" class="workcopy1 anima-animate-enter4 workcopy1-Xz53 component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <div class="work1 anima-valign-text-middle">
                                            Home
                                        </div>
                                    </div>
                                </a>
                                <a href="about.html">
                                    <div anima-show-on-scroll="" class="workcopy2 anima-animate-enter5 workcopy2-3B3m component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <div class="work1 anima-valign-text-middle">
                                            About
                                        </div>
                                    </div>
                                </a>
                                <a href="https://drive.google.com/file/d/1KxPEStKpGkBtJaURrrckkRjVntkcITWU/view?usp=sharing" target="_blank">
                                    <div class="workcopy3 workcopy3-Hkpp component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                        <div class="work1 anima-valign-text-middle">
                                            Resume
                                        </div>
                                    </div>
                                </a>
                            </div>
                        </div>
                        <script>
       (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".ipadlightmenuhover .group3 .workcopy-T1fF", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {}, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {}, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ".work-YGPL"
          }
        ], 
        "overrides": {}
      }
    }
  }, 
  {
    "initial_state_name": "state1", 
    "root_element": ".ipadlightmenuhover .group3 .workcopy-T1fF .work-YGPL", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {}, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {}, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ".work1"
          }
        ], 
        "overrides": {}
      }
    }
  }, 
  {
    "initial_state_name": "state1", 
    "root_element": ".ipadlightmenuhover .group3 .workcopy-T1fF .workcopy1-Xz53", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {}, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {}, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ".work1"
          }
        ], 
        "overrides": {}
      }
    }
  }, 
  {
    "initial_state_name": "state1", 
    "root_element": ".ipadlightmenuhover .group3 .workcopy-T1fF .workcopy2-3B3m", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {}, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {}, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ".work1"
          }
        ], 
        "overrides": {}
      }
    }
  }, 
  {
    "initial_state_name": "state1", 
    "root_element": ".ipadlightmenuhover .group3 .workcopy-T1fF .workcopy3-Hkpp", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {}, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {}, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ".work1"
          }
        ], 
        "overrides": {}
      }
    }
  }
];
})();
                        </script>
                        <a href="javascript:animaHideOverlay('ipadlightmenuhover', 'anima-animate-disappear');">
                            <div class="group2">
                                <img alt="Image" anima-src="./img/ipad-light-menu-hover-path-8@2x.png" class="path" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                                <img alt="Image" anima-src="./img/ipad-light-menu-hover-path-8@2x.png" class="path1" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="/>
                            </div>
                        </a>
                    </div>
                    <div anima-show-on-scroll="" class="h3">
                        Â© 2020 Lil Adam X
                    </div>
                    <style>
                        .ipadlightmenuhover .logo-GgIL * {
                            box-sizing          : border-box;
                        }
                        .ipadlightmenuhover .logo-GgIL {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 41px;
                            height              : 23px;
                            width               : 135px;
                            position            : absolute;
                            margin              : 0;
                            left                : 50px;
                            transform           : rotate(0deg);
                        }
                        .ipadlightmenuhover .logo-GgIL .adamoutline {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 0px;
                            height              : 100%;
                            width               : 100%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0px;
                            transform           : rotate(0deg);
                        }
                        .ipadlightmenuhover .logo-GgIL .adamoutline .shape {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 0px;
                            height              : 100%;
                            width               : 82.22%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0px;
                            transform           : rotate(0deg);
                        }
                        .ipadlightmenuhover .logo-GgIL .adamoutline .path {
                            background-color    : rgba(255,255,255,0.0);
                            right               : 0.74%;
                            bottom              : 13.04%;
                            height              : 65.22%;
                            width               : 11.11%;
                            position            : absolute;
                            margin              : 0;
                            transform           : rotate(0deg);
                        }
                        .ipadlightmenuhover .logo-GgIL .adamfill {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 2.17%;
                            height              : 95.65%;
                            width               : 99.26%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0.37%;
                            transform           : rotate(0deg);
                            opacity             : 0.0;
                        }
                        .ipadlightmenuhover .logo-GgIL .adamfill .shape1 {
                            background-color    : rgba(255,255,255,0.0);
                            top                 : 0px;
                            height              : 100%;
                            width               : 81.34%;
                            position            : absolute;
                            margin              : 0;
                            left                : 0px;
                            transform           : rotate(0deg);
                        }
                        .ipadlightmenuhover .logo-GgIL .adamfill .path1 {
                            background-color    : rgba(255,255,255,0.0);
                            right               : 0.75%;
                            bottom              : 9.09%;
                            height              : 72.73%;
                            width               : 11.19%;
                            position            : absolute;
                            margin              : 0;
                            transform           : rotate(0deg);
                        }
                    </style>
                    <div id="uANPu0I">
                        <a href="home.html">
                            <div class="logo logo-GgIL component anima-component-wrapper anima-not-ready anima-word-break state1" data-initial-state="state1">
                                <div class="adamoutline">
                                    <img alt="Image" class="shape" src="./img/ipad-sslrpdeals-shape@2x.png"/>
                                    <img alt="Image" class="path" src="./img/ipad-sslrpdeals-path-2@2x.png"/>
                                </div>
                                <div class="adamfill anima-hidden ">
                                    <img alt="Image" class="shape1" src="./img/ipad-playground-shape-1@2x.png"/>
                                    <img alt="Image" class="path1" src="./img/ipad-adobe-path-1@2x.png"/>
                                </div>
                            </div>
                        </a>
                    </div>
                    <script>
      (() => {
    const sides_opposites = {
        left: 'right',
        right: 'left',
        top: 'bottom',
        bottom: 'top'
    };
    const sides_containers = {
        left: 'width',
        right: 'width',
        top: 'height',
        bottom: 'height'
    };
    const containers = ['height', 'width'];
    function normalize_to_percent_and_offset(value) {
        let percent = 0.0;
        let pixel_offset = 0;
        const calc_match = value.match(/calc\(\s*([0-9.]*)%\s*([-+])\s*([0-9]*)px/);
        if (calc_match) {
            percent = parseFloat(calc_match[1]);
            pixel_offset = parseInt(calc_match[3]);
            if (calc_match[2] === "-") {
                pixel_offset = -pixel_offset;
            }
        } else if (String(value).includes('%')) {
            percent = parseFloat(value.replace('%', ''));
        } else {
            pixel_offset = parseInt(value, 10);
        }
        return {
            percent,
            pixel_offset
        }
    }
    /**
     * converts px to % for  width/height/left/right/top/bottom
     * @param element a DOM element
     * @param property width/height or direction
     * @param value property value in px
     */
    function to_relative_percent(element, property, value) {
        const offsetParent = element.offsetParent;
        if (!offsetParent) {
            return 0;
        }
        let target_style_property = property; // width/height
        if (sides_containers.hasOwnProperty(property)) {
            target_style_property = sides_containers[property]; //left/right/top/bottom
        }
        const parent_size = Math.max(1, parseInt(getComputedStyle(offsetParent)[target_style_property], 10));
        return parseFloat(100 * value / parent_size);
    }
    /**
     * this funciton changes px positioniong to % and back, keeping the element at the same place
     * margins are dissovled into position
     * @param element - target element to modify
     * @param new_props - next props map e.g.: {width:'100px',left:'10%'} will change element's width by px and left by %...
     * ... if the element previosly had 'right', 'right-margin' it will be reomved while keeping element in the same place
     */
    function convert_to_matching_positioning(element, new_props) {
        const computed_element_style = getComputedStyle(element);
        Object.entries(new_props).forEach(([property, value]) => {
            if (sides_opposites.hasOwnProperty(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property], 10) +
                    parseInt(computed_element_style['margin-' + property], 10);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
                element.style['margin-' + property] = 0;
                element.style['margin-' + sides_opposites[property]] = 0;
                if (element.style[sides_opposites[property]]) {
                    element.style[sides_opposites[property]] = 'auto';
                }
            } else if (containers.includes(property)) {
                const to_percent = String(value).includes('%');
                let new_prop_value = parseInt(computed_element_style[property]);
                if (to_percent) {
                    new_prop_value = to_relative_percent(element, property, new_prop_value).toFixed(4) + '%';
                } else {
                    new_prop_value += 'px';
                }
                element.style[property] = new_prop_value;
            }
        });
    }
    /** this function sets up  listeners. when a listener is activated event_handler is called.
     * it returns a cleanup closure which cleans up those listeners when invoked
     **/
    function setup_listener(root_element, listener_specs, event_handler) {
        let cleaner = null;
        if (listener_specs.listener_type === "timer") {
            const timeout = setTimeout(event_handler, listener_specs.delay);
            cleaner = () => clearTimeout(timeout)
        } else if (['click', 'mouseenter', 'mouseleave'].includes(listener_specs.listener_type)) {
            const target_element = listener_specs.target_selector === "" ? root_element : root_element.querySelector(listener_specs.target_selector);
            let event_handler_fixed = (event) => {
                if (event.type === 'click' || event.target === target_element) {
                    event.stopPropagation();
                    event_handler();
                }
            };
            // these will set pointer-events and cursor for nested elements
            target_element.classList.add('anima-listeners-active');
            if (listener_specs.listener_type === "click") {
                target_element.classList.add('anima-listeners-active-click');
            }
            target_element.addEventListener(listener_specs.listener_type, event_handler_fixed, true);
            cleaner = () => {
                target_element.removeEventListener(listener_specs.listener_type, event_handler_fixed, true);
                target_element.classList.remove('anima-listeners-active');
                target_element.classList.remove('anima-listeners-active-click');
            };
        }
        return cleaner;
    }
    function animate_elements(root_element, selector_to_properties_map, transition_props) {
        Object.entries(selector_to_properties_map).forEach(([selector, prop_values_map]) => {
            const element = selector === "" ? root_element : root_element.querySelector(selector);
            if (element) {
                const update_element_visibility = (visible) => {
                    if (visible) {
                        element.classList.toggle("anima-hidden", false)
                    } else {
                        element.classList.toggle("anima-hidden", true)
                    }
                };
                update_element_visibility(prop_values_map['opacity'] > 0 || getComputedStyle(element).opacity > 0.001 );
                // remove current animations, pausing elements in their current state
                anime.remove(element);
                let full_params = {
                    ...transition_props, // transition properties: easing, duration...
                    ...prop_values_map, // this element's animated properties: width? color? ...
                    targets: [element],
                    complete: () => update_element_visibility(getComputedStyle(element).opacity > 0.001)
                };
                // translate to anime js form
                if (prop_values_map.hasOwnProperty("transform")) {
                    const transform_val = full_params['transform'];
                    delete full_params['transform'];
                    transform_val.match(/\S*\([^)]*/g).map((x) => x.split('(')).forEach(([key, val]) => {
                            full_params[key] = val;
                        }
                    );
                }
                //match css easing curves
                if (full_params.hasOwnProperty("easing")) {
                    const mapping = {
                        // linear: 'linear',
                        "ease-in-out": "cubicBezier(0.42, 0, 0.58, 1)",
                        "ease-in": "cubicBezier(0.42, 0, 1, 1)",
                        "ease-out": "cubicBezier(0, 0, 0.58, 1)",
                    };
                    let ease = full_params["easing"].trim();
                    if (mapping.hasOwnProperty(ease)) {
                        ease = mapping[ease];
                    } else if (ease.startsWith('cubic-bezier')) {
                        ease = ease.replace('cubic-bezier', 'cubicBezier');
                    }
                    full_params["easing"] = ease;
                }
                // "width", "height",
                convert_to_matching_positioning(element, full_params);
                Object.keys(sides_opposites).forEach((side) => {
                    if (full_params.hasOwnProperty(side)) {
                        const value = full_params[side];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[side] = pixel_offset + 'px';
                        } else {
                            full_params[side] = percent + '%';
                            full_params['margin-' + side] = pixel_offset + 'px';
                        }
                        element.style[sides_opposites[side]] = 'auto';
                    }
                });
                containers.forEach((container) => {
                    if (full_params.hasOwnProperty(container)) {
                        const value = full_params[container];
                        let {percent, pixel_offset} = normalize_to_percent_and_offset(value);
                        if (Math.abs(percent) < 0.001) {
                            full_params[container] = pixel_offset + 'px';
                        } else {
                            if (Math.abs(pixel_offset) > 0) {
                                // convert pixels to additional percents
                                percent += to_relative_percent(element, container, pixel_offset);
                                percent = Math.max(0, percent);
                            }
                            full_params[container] = percent + '%';
                        }
                    }
                });
                anime(full_params); // anime js library globally available
            }
        })
    }
    function get_changed_properties_between_states(initial_element_state, from_state_element_state, to_state_element_state) {
        /**
         this function returns a mapping from elements affected by either states
         to their properties in 'to_state'
         e.g. {"#some_obj": {width: 100, height: 50}}
         values changed by 'from_state' are reverted to initial values
         **/
        let selector_to_props = {};
        // set all old state properties back to initial
        Object.entries(from_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = initial_element_state[selector][property];
            });
        });
        // override with new state properties
        Object.entries(to_state_element_state).forEach(([selector, properties]) => {
            selector_to_props[selector] = selector_to_props[selector] || {};
            Object.entries(properties).forEach(([property, value]) => {
                selector_to_props[selector][property] = value;
            });
        });
        return selector_to_props;
    }
    function transitioning_to_state(root_element, initial_properties, states_flow, now_state_name, transition_animation_time) {
        /**
         * called when a changing to a new state
         * registers listeners such as on_click, timers...
         * recursively calls itself and remove listeners when a listener is fired
         */
        const new_state_flow = states_flow[now_state_name];
        // set up new listeners
        let listener_cleanup_callbacks = [];
        for (const listener_specs of new_state_flow.listeners) {
            // this function is only called when the listener is fired
            function on_listener_run() {
                // remove all current listeners
                listener_cleanup_callbacks.forEach(callback => callback());
                listener_cleanup_callbacks = [];
                const next_state_name = listener_specs.change_to_state;
                const this_state_element_state = states_flow[now_state_name].overrides;
                const next_state_element_state = states_flow[next_state_name].overrides;
                // get all animated properties between the two states
                let element_selector_to_changed_properties = get_changed_properties_between_states(initial_properties, this_state_element_state, next_state_element_state);
                let longest_animation_time_ms = 0;
                Object.entries(listener_specs.animations).forEach(([selector, animation_specs]) => {
                    let filtered_props = {};
                    if (element_selector_to_changed_properties.hasOwnProperty(selector)) {
                        filtered_props[selector] = element_selector_to_changed_properties[selector];
                        longest_animation_time_ms = Math.max(longest_animation_time_ms, animation_specs.delay + animation_specs.duration);
                        animate_elements(root_element, filtered_props, animation_specs)
                    }
                });
                transitioning_to_state(root_element, initial_properties, states_flow, next_state_name, longest_animation_time_ms);
            }
            let final_listener_specs = {...listener_specs};
            if (listener_specs.listener_type === 'timer') {
                // timers should start ticking after animation is over
                final_listener_specs.delay += transition_animation_time;
            }
            const cleanup_callback = setup_listener(root_element, final_listener_specs, on_listener_run);
            listener_cleanup_callbacks.push(cleanup_callback);
        }
    }
    function run_when_doc_ready(fn) {
        // make sure anime js is loaded and available globally
        if (!document.getElementById('anime-js-script')) {
            let animejs_element = document.createElement('script');
            animejs_element.id = "anime-js-script";
            animejs_element.setAttribute('src', 'https://cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js');
            animejs_element.setAttribute('integrity', 'sha256-98Q574VkbV+PkxXCKSgL6jVq9mrVbS7uCdA+vt0sLS8=');
            animejs_element.setAttribute('crossorigin', 'anonymous');
            document.head.appendChild(animejs_element);
        }
        if (window.anime === undefined) {
            setTimeout(() => run_when_doc_ready(fn), 50);
            return;
        }
        // see if DOM is already available
        if (document.readyState === "complete" || document.readyState === "interactive") {
            // call on next available tick
            setTimeout(fn, 1);
        } else {
            document.addEventListener("DOMContentLoaded", fn);
        }
    }
    function load_initial_values(anima_components) {
        anima_components.forEach((anima_component) => {
            const root_element = document.querySelector(anima_component.root_element);
            const states_flow = anima_component.states_flow;
            const initial_state_name = anima_component.initial_state_name;
            // const initial_properties = anima_component.initial_properties;
            let initial_properties = {};
            Object.values(anima_component.states_flow).forEach((state_spec) => {
                Object.entries(state_spec.overrides).forEach(([selector, properties]) => {
                    initial_properties[selector] = initial_properties[selector] || {};
                    const element = selector === "" ? root_element : root_element.querySelector(selector);
                    Object.keys(properties).forEach((property) => {
                        initial_properties[selector][property] = element.style[property] ||
                            property === 'transform' && 'rotate(0deg)' ||
                            window.getComputedStyle(element)[property];
                    })
                });
            });
            // set properties to first state
            Object.entries(anima_component.states_flow[initial_state_name].overrides).forEach(([selector, properties]) => {
                const element = selector === "" ? root_element : root_element.querySelector(selector);
                animate_elements(element, {"": properties}, {duration: 0})
            });
            transitioning_to_state(root_element, initial_properties, states_flow, initial_state_name, 0);
        });
        document.querySelectorAll('.anima-not-ready').forEach((x) => x.classList.remove('anima-not-ready'));
    }
    run_when_doc_ready(() => load_initial_values(anima_components));
    // each of these describes a timeline 
    const anima_components = [
  {
    "initial_state_name": "state1", 
    "root_element": ".ipadlightmenuhover .logo-GgIL", 
    "states_flow": {
      "state1": {
        "listeners": [
          {
            "animations": {
              ".adamfill": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state2", 
            "listener_type": "mouseenter", 
            "target_selector": ""
          }
        ], 
        "overrides": {}
      }, 
      "state2": {
        "listeners": [
          {
            "animations": {
              ".adamfill": {
                "delay": 0, 
                "duration": 200, 
                "easing": "ease-in-out"
              }
            }, 
            "change_to_state": "state1", 
            "listener_type": "mouseleave", 
            "target_selector": ""
          }
        ], 
        "overrides": {
          ".adamfill": {
            "opacity": "1.0"
          }
        }
      }
    }
  }
];
})();
                    </script>
                </div>
            </div>
        </div>
        <script>
   var overlay_id = "overlay-ipadlightmenuhover";
  document.getElementById(overlay_id).addEventListener("click", function( event ) {
    var e = event || window.event;
    var clickedDiv = e.toElement || e.target;
    if (clickedDiv.parentElement.id == overlay_id) {
        animaHideOverlay('ipadlightmenuhover', 'anima-animate-disappear');
    }
  }, false);
        </script>
        <!-- Scripts -->
        <script>
   anima_isHidden=function(e){if(!(e instanceof HTMLElement))return!1;if(getComputedStyle(e).display=="none")return!0;else if(e.parentNode&&anima_isHidden(e.parentNode))return!0;return!1};anima_loadAsyncSrcForTag=function(tag){var elements=document.getElementsByTagName(tag);var toLoad=[];for(var i=0;i<elements.length;i++){var e=elements[i];var src=e.getAttribute("src");var loaded=(src!=undefined&&src.length>0&&src!='data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==');if(loaded)continue;var asyncSrc=e.getAttribute("anima-src");if(asyncSrc==undefined||asyncSrc.length==0)continue;if(anima_isHidden(e))continue;toLoad.push(e)}
toLoad.sort(function(a,b){return anima_getTop(a)-anima_getTop(b)});for(var i=0;i<toLoad.length;i++){var e=toLoad[i];var asyncSrc=e.getAttribute("anima-src");e.setAttribute("src",asyncSrc)}};anima_pauseHiddenVideos=function(tag){var elements=document.getElementsByTagName("video");for(var i=0;i<elements.length;i++){var e=elements[i];var isPlaying=!!(e.currentTime>0&&!e.paused&&!e.ended&&e.readyState>2);var isHidden=anima_isHidden(e);if(!isPlaying&&!isHidden&&e.getAttribute("autoplay")=="autoplay"){e.play()}
else if(isPlaying&&isHidden){e.pause()}}};anima_loadAsyncSrc=function(tag){anima_loadAsyncSrcForTag("img");anima_loadAsyncSrcForTag("iframe");anima_loadAsyncSrcForTag("video");anima_pauseHiddenVideos()};var anima_getTop=function(e){var top=0;do{top+=e.offsetTop||0;e=e.offsetParent}while(e);return top};anima_loadAsyncSrc();anima_old_onResize=window.onresize;anima_new_onResize=undefined;anima_updateOnResize=function(){if(anima_new_onResize==undefined||window.onresize!=anima_new_onResize){anima_new_onResize=function(x){if(anima_old_onResize!=undefined)anima_old_onResize(x);anima_loadAsyncSrc()}
window.onresize=anima_new_onResize;setTimeout(function(){anima_updateOnResize()},3000)}};anima_updateOnResize();setTimeout(function(){anima_loadAsyncSrc()},200)
        </script>
        <script>
   animaShowOverlay = function(overlayName, animationName) {
        overlayName = 'overlay-' + overlayName;
        var cssClasses = document.getElementById(overlayName).className.split(' ');
        var last = cssClasses.slice(-1)[0];
        if (last.lastIndexOf('anima-animate') == -1) {
            document.getElementById(overlayName).className = document.getElementById(overlayName).className + " " + animationName;
        }
        if (window.anima_loadAsyncSrc != undefined) {
            anima_loadAsyncSrc();
        }
    };
    animaHideOverlay = function(overlayName, animationName) {
        overlayName = 'overlay-' + overlayName;
        var cssClasses = document.getElementById(overlayName).className.split(' ');
        var last = cssClasses.slice(-1)[0];
        if (last.lastIndexOf('anima-animate') != -1) {
            cssClasses.splice(-1)
            cssClasses.push(animationName)
            document.getElementById(overlayName).className = cssClasses.join(' ');
            cssClasses.splice(-1)
            setTimeout(function() {
                document.getElementById(overlayName).className = cssClasses.join(' ');
            }, 1100);
        }
        var vids = document.getElementsByTagName('video');
        if (vids) {
            for( var i = 0; i < vids.length; i++ ) {
                var video = vids.item(i);
                video.pause();
            }
        }
    };
        </script>
        <!-- End of Scripts -->
    </body>
</html>
